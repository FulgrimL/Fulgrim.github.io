<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>ES 6 基础 | 俊劫、的前端博客</title>
<meta name="description" content="讲个笑话，你可别哭。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://alexwjj.github.io//favicon.ico?v=1561095721317">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://alexwjj.github.io//styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://alexwjj.github.io/">
        <img src="https://alexwjj.github.io//images/avatar.png?v=1561095721317" class="site-logo">
        <h1 class="site-title">俊劫、的前端博客</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
        
          <a href="https://alexwjj.github.io//post/about/" class="site-nav">
            微医
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/alexwjj" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
          <a class="social-link" href="https://weibo.com/u/3027423487/home" target="_blank">
            <i class="fab fa-weibo"></i>
          </a>
        
      
        
          <a class="social-link" href="https://www.zhihu.com/people/biuzhu-biubiu/activities" target="_blank">
            <i class="fab fa-zhihu"></i>
          </a>
        
      
        
      
    </div>
    <div class="site-description">
      讲个笑话，你可别哭。
    </div>
    <div class="site-footer">
      来自一个炒鸡牛批的前端工程师！ | <a class="rss" href="https://alexwjj.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">ES 6 基础</h2>
            <div class="post-date">2019-06-05</div>
            
              <div class="feature-container" style="background-image: url('https://alexwjj.github.io//post-images/es-6-ji-chu.jpeg')">
              </div>
            
            <div class="post-content">
              <blockquote>
<p>自己对 ES6做的部分总结</p>
</blockquote>
<!-- more -->
<h2 id="1数组中迭代方法的使用">1.数组中迭代方法的使用</h2>
<pre><code>1、forEach()
var arr = [1,2,3,4];
arr.forEach((item,index,arr) =&gt; {
    console.log(item) //结果为1,2,3,4
})
//forEach遍历数组，无返回值，不改变原数组，仅仅只是遍历、常用于注册组件、指令等等。

2、map()
var arr = [1,2,3,4];
arr.map((item,index,arr) =&gt; {
    return item*10 //新数组为10,20,30,40
})
//map遍历数组，返回一个新数组，不改变原数组的值。

3、filter()
var arr = [1,2,3,4];
arr.filter((item,index,arr) =&gt; {
    return item &gt; 2 //新数组为[3,4]
})
//filter过滤掉数组中不满足条件的值，返回一个新数组，不改变原数组的值。

4、reduce()
var arr = [1,2,3,4];
arr.reduce((result,item,index,arr) =&gt; {
    console.log(result) // 1  3  6  result为上次一计算的结果
    console.log(item)  // 2  3  4
    console.log(index) // 1  2  3
    return result+item //最终结果为10
})
//reduce 让数组的前后两项进行某种计算。然后返回其值，并继续计算。不改变原数组，返回计算的最终结果，从数组的第二项开始遍历。

5、some()
var arr = [1,2,3,4];
arr.some((item,index,arr) =&gt; {
    return item &gt; 3 //结果为true
})
//遍历数组每一项，有一项返回true,则停止遍历，结果返回true。不改变原数组

6、every()
var arr = [1,2,3,4];
arr.every((item,index,arr) =&gt; {
    return item &gt; 1 //结果为false
})
//遍历数组每一项，每一项返回true,则最终结果为true。当任何一项返回false时，停止遍历，返回false。不改变原数组

7.find()
[1, 4, -5, 10].find((n) =&gt; n &lt; 0)  // -5
用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，

直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。

以上均不改变原数组。 
some、every返回true、false。 
map、filter返回一个新数组。 
reduce让数组的前后两项进行某种计算，返回最终操作的结果。 
forEach 无返回值。
</code></pre>
<h2 id="2-set">2. Set</h2>
<pre><code>set 去重 两者完全相等 === 才会被清除掉

Set数据格式Set(3) {1, 2, 3}

Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。

下面先介绍四个操作方法。
add(value)：添加某个值，返回 Set 结构本身。
delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
has(value)：返回一个布尔值，表示该值是否为Set的成员。
clear()：清除所有成员，没有返回值。
Array.from方法可以将 Set 结构转为数组。
</code></pre>
<h2 id="3map">3.Map</h2>
<p>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<pre><code>Map数据格式：  Map(3) {1 =&gt; &quot;one&quot;, 2 =&gt; &quot;two&quot;, 3 =&gt; &quot;three&quot;}
Map转化为数组结构
const map = new Map([
  [1, 'one'],
  [2, 'two'],
  [3, 'three'],
]);

[...map.keys()]
// [1, 2, 3]

[...map.values()]
// ['one', 'two', 'three']

[...map.entries()]
// [[1,'one'], [2, 'two'], [3, 'three']]

[...map]
// [[1,'one'], [2, 'two'], [3, 'three']]
</code></pre>
<h2 id="4for-in-for-of">4.for in &amp; for of</h2>
<p>for in循环设计之初，是给普通以字符串的值为key的对象使用的。而非数组。</p>
<p>for of循环不仅仅支持数组的遍历。同样适用于很多类似数组的对象,字符串得遍历也行</p>
<p>in key   of value 尽量使用of，避免其他问题带来得麻烦</p>
<h2 id="5json">5.JSON</h2>
<pre><code>JSON.stringify( {} , [ ] , &quot;&quot;)  // 转化为json字符串
//参数一 ：要序列化的数据（object）
//参数二 ：控制对象的键值，只想输出指定的属性，传入一个数组
//参数三 ：序列化后，打印输出的格式（一个Tab ，可以更直观查看json）
JSON.parse( json.DATA ) //传入json字符串 转化为json对象
JSON有两种格式 数组和对象    后端一般传过来的都是对象形式
</code></pre>
<h2 id="6解构赋值">6.解构赋值</h2>
<p>只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p>
<p>解构赋值允许指定默认值</p>
<pre><code>let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 
let [x = 1] = [null]; //x=null只有===undefined默认值才有用
</code></pre>
<p>对象和数组解构的区别： 数组按次序来，对象则要变量与属性同名</p>
<p>解构失败 ，变量的值就是undefined</p>
<p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<pre><code>const [a, b, c, d, e] = 'hello';
函数参数解构     [[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ]
ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。
</code></pre>
<h3 id="解构用途">解构用途</h3>
<pre><code>交换变量的值
[x, y] = [y, x];
从函数返回多个值  
function example() {return [1, 2, 3];}    let [a, b, c] = example();
函数参数的定义
function f({x, y, z}) { ... }        f({z: 3, y: 2, x: 1});
提取 JSON 数据                                                                                                                                                       
let jsonData = {
  id: 42,
  status: &quot;OK&quot;,
  data: [867, 5309]
};
let { id, status, data: number } = jsonData;
console.log(id, status, number);
// 42, &quot;OK&quot;, [867, 5309]

遍历 Map 结构      
for (let [key, value] of map) { console.log(key + &quot; is &quot; + value);}  
// 获取value ：for (let [,value] of map) { // ...}
输入模块的指定方法
const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);
</code></pre>
<h2 id="7es6-字符串扩展">7.es6 字符串扩展</h2>
<pre><code>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。

ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。

JavaScript 只有indexOf方法，ES6 includes()是否存在  startsWith() endsWith() 开头和结尾处是否存在

repeat方法返回一个新字符串，表示将原字符串重复n次。    'x'.repeat(3) // &quot;xxx&quot;  

ES2017 (ES8)引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。

padStart()用于头部补全，padEnd()用于尾部补全。 'x'.padStart(5, 'ab') // 'ababx'

模板字符串 `${ xxx }`   `foo ${fn()} bar` 可以调用函数，进行运算，嵌套。反引号中的空格也会被输出

模板编译 &lt;%   javascript %&gt;

</code></pre>
<h2 id="8generator">8.Generator</h2>
<p>调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，返回一个遍历器对象，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。</p>
<p>function* foo(x, y) { ··· }    写法带个 *
每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能</p>
<h2 id="9async">9.async</h2>
<p>async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</p>
<p>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<p>使用方式：</p>
<pre><code>// 函数声明 async function foo() {}
// 函数表达式 const foo = async function () {};
// 对象的方法 let obj = { async foo() {} };obj.foo().then(...)
 // 箭头函数  const foo = async () =&gt; {};
</code></pre>
<p>await命令后面是一个 Promise 对象。如果不是，就返回对应的值  await 123 等同于 123只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行。
await的第一个异步操作失败，Promise变为reject  。如果想不影响后面的操作：1.将第一个await卸载try{ await  }catch（）{} 中  2.await后面的Promise后面接上一个catch方法
同时触发多个await</p>
<pre><code>// 写法一   
let [foo, bar] = await Promise.all([getFoo(), getBar()]);
// 写法二
let fooPromise = getFoo();
let barPromise = getBar();
let foo = await fooPromise;
let bar = await barPromise;
</code></pre>
<p>async原理：将 Generator 函数和自动执行器，包装在一个函数里。</p>
<h2 id="10fetch">10.fetch</h2>
<p>Fetch API 提供了一个获取资源的接口（包括跨域）。XMLHttpRequest的一种替代方案，类似于ajax
fetch() 必须接受一个参数——资源的路径。无论请求成功与否，它都返回一个 promise 对象，resolve 对应请求的 Response。你也可以传一个可选的第二个参数init
新技术，兼容性不行</p>
<h2 id="11shtml-html">11.shtml &amp; html</h2>
<p>shtml 与html的区别 shtml不是html 而是一种服务器API,shtml是服务器动态产生的html</p>
<p>shtml用于SSI技术文件（服务器端包含指令/服务器端嵌入） 包含 SSI 指令的文件要求特殊处理，所以必须为所有 SSI 文件赋予 SSI 文件扩展名。默认扩展名是 .stm、.shtm 和 .shtml</p>
<h2 id="12es6-promise">12.es6 promise</h2>
<p>异步操作，统一API，状态不可改变resolve（已定型）</p>
<p>ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。</p>
<p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p>
<p>promise.resolve()  将现有的对象转换为promise对象 具有then方法,调用resolve或reject并不会终结Promise 的参数函数的执行。一般来说，为了结束直接return resolve（）；then里面返回的是一个新的promise，可以使用链式写法，catch运行时发生错误的回调函数，then里面的错误也会被捕捉到 。</p>
<p>不使用catch的话then报错后，后面的语句依旧会执行 。 Promise 会吃掉错误
catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。promise没有错误就会跳过catch</p>
<p>.finally (es9)不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。 finally方法的回调函数不接受任何参数，其实本质是是then的特例</p>
<p>事件循环 setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log('one')则是立即执行，因此最先输出。</p>
<p>promise 应用 图片加载</p>
<p>同步 立即执行  ；promise中的属于异步，会在本轮事件循环的末尾执行。</p>
<p>promise.resolve().then(f) 会将同步函数转换为异步。 可以结合async来解决这个问题</p>
<p>详情参考文档： http://es6.ruanyifeng.com/?search=**&amp;x=0&amp;y=0#docs/promise</p>
<h2 id="13es6-数值扩展">13.es6 数值扩展</h2>
<pre><code>Math.trunc方法用于去除一个数的小数部分，返回整数部分。 原理ceil和floor结合
Math.sign方法用来判断一个数到底是正数、负数、还是零
Math.cbrt方法用于计算一个数的立方根。x³=a 求x  根号a的3次
Math.hypot方法返回所有参数的平方和的平方根。 
ES2016 新增了一个指数运算符（**） x ^ y = x ** y 特点是右结合 2 ** 3 ** 2 = 2 ^ (3 ^ 2)
**= a **=2 等于 a * a   b **=3 等于 b * b * b
</code></pre>
<h2 id="14es6-函数扩展">14.es6 函数扩展</h2>
<pre><code>* ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。function fn(x = '1') {}
* 函数中使用解构 function fn( { } ) 函数调用的时候 fn( )按顺序传值
* 函数的length属性 在设置默认值之后，后面的包括设置默认值的都不在计算length 
* 作用域  在设置了默认值以后 会形成一个单独的context. 函数初始化结束，消失。先在f（）中寻找，再去全局找
* rest参数 （...变量名） function fn（...values） {}  调用传入任意数量的参数  fn( x, y, z ) 代替了argument，...变量名  搭配数组使用 values可以直接使用数组的方法，argument不行。rest 参数一般放在最后，后面继续跟参数就报错
* es6规定只要函数参数使用了默认值、解构赋值、或扩展运算符，那么函数内部就不能显式设定为严格模式，会报错。
* f.name 会返回当前函数名
* 箭头函数 f =&gt; (x) =&gt; y ；  f函数名 x 参数  y返回值  只有一个参数时可以省略（），只有一个表达式时可以省略{}
* 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。
* 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。在箭头函数中，它是固定的。箭头函数导致this总是指向函数定义生效时所在的对象or作用域
* this指向的固定化，原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。
* 由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。
* 需要动态this的时候，不应使用箭头函数。比如想让this指向按钮中的某一个元素
* 函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。
* 尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数，尾调用不一定出现在函数尾部，只要是最后一步操作即可
* 尾递归
</code></pre>
<h2 id="15objectassign">15.Object.assign()</h2>
<pre><code>* Object.assign是ES6新添加的接口，主要的用途是用来合并多个JavaScript的对象。
* Object.assign()接口可以接收多个参数，第一个参数是目标对象，后面的都是源对象，assign方法将多个原对象的属性和方法都合并到了目标对象上面，如果在这个过程中出现同名的属性（方法），后合并的属性（方法）会覆盖之前的同名属性（方法）。
* 第一个参数target决定了你的对象被拷贝到哪个目标对象上面，如果你不想对原始对象产生影响，就定义一个空对象{}作为target，
* Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。
* Object.assign进行的拷贝是浅拷贝
* 作用：为对象添加属性，为对象添加方法，克隆对象，为属性指定默认值
* https://blog.csdn.net/qs8lk88/article/details/79018481
* 
 枚举
* 事先考虑到某一变量可能取的值，尽量用自然语言中含义清楚的单词来表示它的每一个值，这种方法称为枚举方法，用这种方法定义的类型称枚举类型。enum
* 枚举是指对象中的属性是否可以遍历出来，再简单点说就是属性是否可以以列举出来。
* 16.Object.entries()
* Object.entries()方法返回一个给定对象自身可枚举属性的键值对 数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。
* Object.entries方法对于原型链上继承的非自有属性无能为力。
</code></pre>
<h2 id="17objectkeys">17.Object.keys()</h2>
<p>ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（ enumerable ）属性的键名。</p>
<p>ES7 Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（ enumerable ）属性的键值。</p>
<h2 id="18classextentssuper">18.class，extents，super</h2>
<pre><code>* 为了解决es5中原型，构造函数，继承写法复杂，理解困难的问题
* constructor 构造方法，在一个class中constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实力对象可以共享的。
* Class之间可以通过extends关键字实现继承，继承constructor外的属性及方法
* super关键字，它指代父类的实例（即父类的this对象），子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。
* ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。
</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://alexwjj.github.io//tag/JavaScript" class="tag">
                    JavaScript
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://alexwjj.github.io//post/webpack-ru-men-pei-zhi">
                  <h3 class="post-title">
                    Webpack  入门配置
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '3a75e9876da102702b06',
        clientSecret: '9b9c930a40f564a860f43ce401d79bebd588137f',
        repo: 'alexwjj.github.io',
        owner: 'alexwjj',
        admin: ['alexwjj'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
