<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title> Vue ---  computed vs watch | 俊劫、的前端博客</title>
<meta name="description" content="讲个笑话，你可别哭。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://alexwjj.github.io//favicon.ico?v=1563929983485">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://alexwjj.github.io//styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://alexwjj.github.io/">
        <img src="https://alexwjj.github.io//images/avatar.png?v=1563929983485" class="site-logo">
        <h1 class="site-title">俊劫、的前端博客</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
        
          <a href="https://alexwjj.github.io//post/wei-yi-ji-tuan/" class="site-nav">
            微医
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/alexwjj" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
          <a class="social-link" href="https://weibo.com/u/3027423487/home" target="_blank">
            <i class="fab fa-weibo"></i>
          </a>
        
      
        
          <a class="social-link" href="https://www.zhihu.com/people/biuzhu-biubiu/activities" target="_blank">
            <i class="fab fa-zhihu"></i>
          </a>
        
      
        
      
    </div>
    <div class="site-description">
      讲个笑话，你可别哭。
    </div>
    <div class="site-footer">
      访问量：3.2 W | <a class="rss" href="https://alexwjj.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title"> Vue ---  computed vs watch</h2>
            <div class="post-date">2019-06-28</div>
            
              <div class="feature-container" style="background-image: url('https://alexwjj.github.io//post-images/tan-jiu-vue-ji-suan-shu-xing-computed-he-zhen-ting-shu-xing-watch.png')">
              </div>
            
            <div class="post-content">
              <blockquote>
<p>初学 vue 的时候就分不清computed和 watch 的区别</p>
<p>在写了一段时间的业务逻辑后，对两者有了一些认识。</p>
<p>结合各位大佬的分析，自己总结了一下。</p>
</blockquote>
<!-- more -->
<h1 id="计算属性-computed">计算属性 computed</h1>
<h2 id="1computed">1.computed</h2>
<p>计算属性是自动监听<strong>依赖值</strong>的变化，从而动态返回内容，监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些事情。它有以下几个特点：</p>
<ul>
<li>数据可以进行逻辑处理，<strong>减少模板中计算逻辑</strong>。</li>
<li>对计算属性中的数据进行监视</li>
<li>依赖固定的数据类型（响应式数据）</li>
</ul>
<p>计算属性由两部分组成：get和set，分别用来获取计算属性和设置计算属性。<strong>默认只有get</strong>，如果需要set，要自己添加。另外set设置属性，并不是直接修改计算属性，而是修改它的依赖。</p>
<pre><code>computed: {
  fullName: {
    // getter
    get: function () {
      return this.nickName + '-' + this.trueName
    },
    // setter
    set: function (newValue) {
      //this.fullName = newValue 这种写法会报错
      var names = newValue.split('-')
      this.nickName = names[0]//对它的依赖进行赋值
      this.trueName = names[names.length - 1]
    }
  }
}
</code></pre>
<p>现在再运行 vm.fullName = 'alex wjj' 时，setter 会被调用，vm.nickName 和 vm.trueName 也会相应地被更新。</p>
<h2 id="2computed-vs-methods">2.computed   vs  methods</h2>
<p>两者最主要的区别：computed 是可以<strong>缓存的</strong>，methods 不能缓存；</p>
<p>只要<strong>相关依赖</strong>没有改变，多次访问计算属性得到的值是之前缓存的计算结果，不会多次执行。</p>
<p>网上有种说法就是方法可以传参，而计算属性不能，其实并不准确，<strong>计算属性可以通过闭包来实现传参</strong>：</p>
<pre><code>:data=&quot;closure(item, itemName, blablaParams)&quot;
computed: {
 closure () {
   return function (a, b, c) {
        /** do something */
        return data
    }
 }
}

</code></pre>
<h1 id="侦听属性-watch">侦听属性 watch</h1>
<h2 id="1watch">1.watch</h2>
<p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性watch</p>
<h2 id="2使用-watch-的深度遍历deep和立即调用功能immediate">2.使用 watch 的深度遍历deep和立即调用功能immediate</h2>
<p>使用 watch 来监听数据变化的时候除了常用到 <strong>handler 回调</strong>，其实其还有两个参数，便是：</p>
<ul>
<li>deep 设置为 true 用于监听对象内部值的变化</li>
<li>immediate 设置为 true 将立即以表达式的当前值触发回调</li>
</ul>
<pre><code>&lt;template&gt;
    &lt;button @click=&quot;obj.a = 2&quot;&gt;修改&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    data() {
        return {
            obj: {
                a: 1,
            }
        }
    },
    watch: {
        obj: {
            handler: function(newVal, oldVal) {
                console.log(newVal); 
            },
            deep: true,
            immediate: true 
        }
    }
}
&lt;/script&gt;

</code></pre>
<p>以上代码修改了 obj 对象中 a 属性的值，可以触发其 watch 中的 handler 回调输出新的对象，而如果不加 deep: true，我们只能监听 obj 的改变，并不会触发回调。同时我们也添加了 immediate: true 配置，其会立即以 obj 的当前值触发回调。</p>
<pre><code>watch: {
    searchInputValue:{
        handler: 'fetchPostList',
        immediate: true
    }
}
// 声明immediate:true表示创建组件时立马执行一次。
</code></pre>
<h1 id="computed-vs-watch">computed vs watch</h1>
<p><img src="https://alexwjj.github.io//post-images/1561690381163.png" alt=""></p>
<p>流程图中，我们可以看出它们之间的区别：</p>
<ul>
<li>watch：监测的是<strong>属性值</strong>， 只要属性值发生变化，其都会触发执行回调函数来执行一系列操作。</li>
<li>computed：监测的是<strong>依赖值</strong>，依赖值不变的情况下其会直接读取缓存进行复用，变化的情况下才会重新计算。</li>
</ul>
<p>除此之外，有点很重要的区别是：计算属性不能执行异步任务，计算属性必须同步执行。也就是说计算属性不能向服务器请求或者执行异步任务。如果遇到异步任务，就交给侦听属性。watch也可以检测computed属性。</p>
<h1 id="小结">小结</h1>
<p>计算属性适合用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。</p>
<ul>
<li>computed能做的，watch都能做，反之则不行</li>
<li>能用computed的尽量用computed</li>
</ul>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://alexwjj.github.io//tag/Vue" class="tag">
                    Vue
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://alexwjj.github.io//post/wei-sha-yao-var-_this-this">
                  <h3 class="post-title">
                    var _this = this  的含义
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '3a75e9876da102702b06',
        clientSecret: '9b9c930a40f564a860f43ce401d79bebd588137f',
        repo: 'alexwjj.github.io',
        owner: 'alexwjj',
        admin: ['alexwjj'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
