<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>前端面试基础知识点  20190329 | 俊劫、的前端博客</title>
<meta name="description" content="讲个笑话，你可别哭。">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://alexwjj.github.io//favicon.ico?v=1566127672819">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://alexwjj.github.io//styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://alexwjj.github.io/">
        <img src="https://alexwjj.github.io//images/avatar.png?v=1566127672819" class="site-logo">
        <h1 class="site-title">俊劫、的前端博客</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
        
          <a href="https://alexwjj.github.io//post/wei-yi-ji-tuan/" class="site-nav">
            微医
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/alexwjj" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
          <a class="social-link" href="https://weibo.com/u/3027423487/home" target="_blank">
            <i class="fab fa-weibo"></i>
          </a>
        
      
        
          <a class="social-link" href="https://www.zhihu.com/people/biuzhu-biubiu/activities" target="_blank">
            <i class="fab fa-zhihu"></i>
          </a>
        
      
        
      
    </div>
    <div class="site-description">
      讲个笑话，你可别哭。
    </div>
    <div class="site-footer">
      访问量：3.2 W | <a class="rss" href="https://alexwjj.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">前端面试基础知识点  20190329</h2>
            <div class="post-date">2019-03-29</div>
            
              <div class="feature-container" style="background-image: url('https://alexwjj.github.io//post-images/qian-duan-mian-shi-ji-chu-zhi-shi-dian-20190329.png')">
              </div>
            
            <div class="post-content">
              <blockquote>
<p>个人总结的面试技巧</p>
<p>针对个人基础知识点来梳理的</p>
</blockquote>
<!-- more -->
<h2 id="1注意点">1.注意点</h2>
<p>在js逻辑运算中，0、NaN、&quot;&quot;、null、false、undefined都会判为false，其他都为true</p>
<p>IOS 无法识别yy-mm-dd这种带 - 的时间格式</p>
<h2 id="2foreach-map">2.forEach  Map</h2>
<p>forEach()方法不会返回执行结果，而是undefined。也就是说，forEach()会修改原来的数组。而map()方法会得到一个新的数组并返回。</p>
<h2 id="3数据类型">3.数据类型</h2>
<p>六种基本类型：string, number, boolean, undefined, null，symbol 三种引用类型: function, array, object<br>
在js中， number没有整型，导致NaN 也属于 number 类型， NaN 不等于自身。</p>
<h2 id="4判断一个数组的类型">4.判断一个数组的类型</h2>
<p>1.判断是否具有数组某些方法：if(arr.sort()){}</p>
<p>2.instanceof(某些IE版本不正确)：arr instanceof Array</p>
<p>3.Array.isArray()</p>
<p>4.Object.prototype.toString.call(arr); // '[object Array]'</p>
<p>5.constructor方法</p>
<pre><code>arr.constructor === Array
var arr = []  arr instanceOf Array //true typeof arr //object 
instanceof 原型链上所有特殊对象的__proto__最终都会指向Object.prototype，
所以instanceof判断类型也不完全准确

Array.isArray 是 es5 的方法，并不兼容所有浏览器，ie9 以下浏览器都不支持

通用办法
var isArray = Array.isArray || function(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
};
</code></pre>
<h2 id="5变量提升-函数提升">5.变量提升 &amp;&amp; 函数提升</h2>
<p>js查找变量 先在当前作用域中查找 存在则返回，不存在则向上查找</p>
<p>函数的优先权是最高的，它永远被提升至作用域最顶部，然后才是函数表达式和变量按顺序执行</p>
<p>变量提升是人为实现的问题，而函数提升在当初设计时是有目的的。</p>
<p><strong>规范代码，提高可读性，先声明，后使用。</strong></p>
<h2 id="6事件">6.事件</h2>
<p>事件委托：让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！</p>
<p>事件捕获阶段(与冒泡相反)）=&gt;目标元素阶段=&gt;事件冒泡阶段</p>
<h3 id="addeventlistener">addEventListener</h3>
<p>该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false 。useCapture 决定了注册的事件是捕获事件(false)还是冒泡事件(true)。如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上。阻止事件冒泡event.stopPropagation()。阻止默认事件：event.preventDefault()</p>
<h3 id="event-loop">Event loop</h3>
<p>JS 是门非阻塞单线程语言,如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点），当然可以引入读写锁解决这个问题。</p>
<h3 id="执行环境">执行环境</h3>
<p>JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 任务（有多种任务） 队列中。一旦执行栈为空，Event Loop 就会从 任务 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。</p>
<h3 id="任务队列">任务队列</h3>
<p>不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）<br>
微任务包括 process.nextTick ，promise ，Object.observe ，MutationObserver<br>
宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering</p>
<p><strong>Event loop</strong> 顺序是这样的</p>
<pre><code>* 执行同步代码，这属于宏任务
* 执行栈为空，查询是否有微任务需要执行
* 执行所有微任务
* 必要的话渲染 UI
* 然后开始下一轮 Event loop，执行宏任务中的异步代码
* Node 的 Event loop 分为 6 个阶段，它们会按照顺序反复运行
</code></pre>
<h2 id="7http">7.HTTP</h2>
<h3 id="特点">特点</h3>
<p>简单快速：客户向服务器请求服务时，只需传送请求方法和路径</p>
<p>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记</p>
<p>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接 (深入-持久连接、管线化)</p>
<p>无状态：HTTP协议是无状态协议( Cookie 的出现)</p>
<p>https 即在HTTP下加入SSL层</p>
<h3 id="http-请求方法">http 请求方法</h3>
<p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</p>
<p>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>
<h3 id="一般的http连接都是">一般的http连接都是：</h3>
<pre><code>* 三次握手建立连接，
* 发送http请求报文，获取响应报文，
* 通过四次握手，中断连接
* HTTP1.1中connection默认开启keep-alive，就不需要连续的建立然后中断
</code></pre>
<h3 id="http-状态码">http 状态码</h3>
<pre><code>1xx指示信息，请求已接收，继续处理
2xx成功，请求已成功
3xx重定向，要完成请求必须要进行下一步操作
4xx客户端错误，请求有语法错误或无法实现
5xx服务端错误，服务器未能实现合法的请求
 
200：请求已成功，请求所希望的响应头或数据体将随此响应返回。
302：请求的资源临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或Expires 中进行了指定的情况下， 这个响应才是可缓存的
304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。
403：服务器已经理解请求，但是拒绝执行它。
404：请求失败，请求所希望得到的资源未被在服务器上发现。
502 Bad Gateway是指错误网关，无效网关
</code></pre>
<h2 id="8typeof-null">8.typeOf null</h2>
<p>在 JS 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。</p>
<h2 id="9浏览器渲染页面的过程">9.浏览器渲染页面的过程</h2>
<p>从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面五件事情上：</p>
<pre><code>1. DNS 查询
2. TCP 连接
3. HTTP 请求即响应
4. 服务器响应
5. 客户端渲染
</code></pre>
<p>第五个部分，即浏览器对内容的渲染，这一部分（渲染树构建、布局及绘制），又可以分为下面五个步骤：</p>
<pre><code>1. * 处理 HTML 标记并构建 DOM 树。
2. * 处理 CSS 标记并构建 CSSOM 树。
3. * 将 DOM 与 CSSOM 合并成一个渲染树。
4. * 根据渲染树来布局，以计算每个节点的几何信息。
5. * 将各个节点绘制到屏幕上。
</code></pre>
<h2 id="10objectis-objectisfoo-foo-true">10.object.is() Object.is('foo', 'foo') true</h2>
<h2 id="11原生sort使用的是哪些排序算法">11.原生sort使用的是哪些排序算法？</h2>
<p>插入排序和快速排序结合的排序算法<br>
sort 的排序规则：</p>
<pre><code>    var values = [0, 1, 5, 10, 15];
    values.sort();
    alert(values);     //0,1,10,15,5
</code></pre>
<h2 id="12原型">12.原型</h2>
<p>所有引用类型（数组、对象、函数）都有一个__proto__隐式原型属性，属性值是一个普通对象。 此外，Object.prototype.__proto__指向null</p>
<p>所有函数都有一个prototype显式原型属性，属性值是一个普通对象。 Function.prototype.bind()没有prototype属性</p>
<p>所有引用类型（数组、对象、函数）的__proto__执行它的构造函数的prototype属性</p>
<h2 id="13-迭代方法">13. 迭代方法</h2>
<pre><code>// every()查询数组是否每一项都满足条件
// some()查询数组中是否有满足条件的项
// filter()过滤，返回true的项组成的数组
// map()对每一项运行给定函数，返回每次函数调用结果组成的数组
// forEach()对每一项运行给定函数，无返回值  
// reduce 让数组的前一项和后一项做某种计算，累计最终值
var numbers = [1,2,3,4,5,4,3,2,1];
numbers.every(function(item,index,array){
    return item&gt;2;
})  // false
numbers.some(function(item,index,array){
    return item&gt;2;
})  // true
numbers.filter(function(item,index,array){
    return item&gt;2;
})  // [3,4,5,4,3]
numbers.map(function(item,index,array){
    return item*2;
})  // [2,4,6,8,10,8,6,4,2]
numbers.forEach(function(item,index,array){
    // 执行某些操作
})  // 无返回值
</code></pre>
<h2 id="14new操作符具体干了什么">14.new操作符具体干了什么？</h2>
<pre><code>构造函数相当于一个模板
* 创建一个空对象
* 将对象的__proto指向构造函数的原型prototype
* 执行构造函数中的代码，传递参数，并将this指向这个对象
* 返回对象
</code></pre>
<h2 id="15通过new的方式创建对象和通过字面量创建的区别">15.通过new的方式创建对象和通过字面量创建的区别</h2>
<p>更推荐字面量的方式创建对象，性能和可读性都更好。使用var o=new Object()和var o={}的区别是前者会调用构造函数</p>
<h2 id="16继承">16.继承</h2>
<p>ES 5实现思路就是将子类的原型设置为父类的原型。在 ES6 中，我们可以通过 class 语法</p>
<h2 id="17闭包">17.闭包</h2>
<p>闭包指有权访问另一个函数内部变量的函数，当在函数内部定义了其他函数，也就创建了闭包</p>
<p>想要访问一个f1内的变量，在f1内在创建一个函数f2，将f2的值作为返回值，在调用f1时就能访问到f1里面的局部变量</p>
<p><strong>场景1：使用函数内部变量</strong></p>
<p><img src="https://alexwjj.github.io//post-images/1559726116412.png" alt=""></p>
<p><strong>场景2：保存变量在内存中</strong></p>
<p><img src="https://alexwjj.github.io//post-images/1559726149136.png" alt=""></p>
<p>在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。销毁闭包：res = null。闭包的this默认指向window</p>
<h3 id="内存泄露">内存泄露</h3>
<p>闭包会引用包含函数的整个变量对象，如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素无法被销毁。所以我们有必要在对这个元素操作完之后主动销毁。 = null</p>
<p>函数内部定时器<br>
当函数内部的定时器引用了外部函数的变量对象时，该变量对象不会被销毁。</p>
<h3 id="应用场景">应用场景</h3>
<pre><code>设计私有的变量和方法
模块模式：为单例创建私有的变量和方法
单例：指的是只有一个实例的对象。一般以对象字面量的方式来创建一个单例对象。
匿名函数最大的用途是创建闭包，并且还可以构建命名空间，以减少全局变量的使用。
从而使用闭包模块化代码，减少全局变量的污染。
</code></pre>
<p><img src="https://alexwjj.github.io//post-images/1559726283838.png" alt=""><br>
在这段代码中函数 addEvent 和 removeEvent 都是局部变量，但我们可以通过全局变量 objEvent 使用它，这就大大减少了全局变量的使用，增强了网页的安全性。</p>
<p><strong>经典面试题</strong>，循环中使用闭包解决 var 定义函数的问题</p>
<pre><code>for ( var i=1; i&lt;=5; i++) {
	setTimeout( function timer() {
		console.log( i );
	}, i*1000 );
}
</code></pre>
<p>首先因为 setTimeout 是个异步函数，所有会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出5个6。解决办法两种，第一种使用闭包</p>
<pre><code>for (var i = 1; i &lt;= 5; i++) {
  (function(j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
</code></pre>
<p>第二种就是使用 setTimeout 的第三个参数</p>
<pre><code>for ( var i=1; i&lt;=5; i++) {
	setTimeout( function timer(j) {
		console.log( j );
	}, i*1000, i);
}
</code></pre>
<p>第三种就是使用 let 定义 i 了</p>
<pre><code>for ( let i=1; i&lt;=5; i++) {
	setTimeout( function timer() {
		console.log( i );
	}, i*1000 );
}
</code></pre>
<h2 id="18bom对象">18.BOM对象</h2>
<pre><code>window JS最顶层对象
location 浏览器当前URL信息
navigator 浏览器本身信息
screen 客户端屏幕信息
history 浏览器访问历史信息
window对象的方法：
alert(),prompt(),confirm(),open(),close(),print(),focus(),blur(),
moveBy(),moveTo(),resizeBy(),resizeTo(),scrollBy(),scrollTo(),
setInterval(),setTimeout(),clearInterval(),clearTimeout()
</code></pre>
<h2 id="19拆解url的各部分">19.拆解url的各部分</h2>
<pre><code>* 使用location的属性
* href 完整url地址
* protocol 协议
* host 主机名+端口号
* hostname 主机名
* port 端口号
* pathname 相对路径
* hash #锚点
* search ?查询字符串
</code></pre>
<h2 id="20为什么操作dom慢">20.为什么操作DOM慢？</h2>
<p>因为DOM属于渲染引擎的东西，JS又是JS引擎的东西，当我们通过JS操作DOM的时候，涉及到两个线程间的通信，而且操作DOM可能会带来重绘回流的情况，所以就导致了性能问题。DOM对象本身也是一个js对象，操作了这个对象后，会触发一些浏览器行为，比如布局（layout）和绘制（paint）。重绘是当节点改变样式而不影响布局，回流是当布局或几何属性需要改变。回流必定会发生重绘，回流的成本比重绘高</p>
<h2 id="21什么情况阻塞渲染">21.什么情况阻塞渲染</h2>
<p>1.HTML和CSS都会阻塞渲染，如果想渲染快就应该降低一开始渲染的文件大小，扁平层级，优化选择器</p>
<p>2.浏览器解析到script标签时会暂停构建DOM，</p>
<h2 id="22dom">22.Dom</h2>
<pre><code>document.querySelector // 返回第一个匹配的元素
document.querySelectorAll  // 返回匹配的所有元素
// 获取文档中所有 class=&quot;example&quot; 的 &lt;p&gt; 元素
var x = document.querySelectorAll(&quot;p.example&quot;); 

DOM事件

DOM事件的级别
DOM0 element.onclick=function(){}
DOM2 element.addEventListener('click',function(){},false)
DOM3 element.addEventListener('keyup',function(){},false)
DOM0级事件就是将一个函数赋值给一个事件处理属性，缺点在于一个处理程序无法同时绑定多个处理函数。
DOM2级事件运行给一个程序添加多个处理函数，定义了addEventListener和removeEventListener两个方

法，分别用于绑定和解绑事件，方法包含三个参数分别是绑定的事件处理的属性名称，处理函数，是否在

捕获时执行事件

IE8以下使用attachEvent和detachEvent实现，不需要传入第三个参数，因为IE8以下只支持冒泡型事件
btn.attachEvent('onclick', showFn);
btn.detachEvent('onclick', showFn);
复制代码

DOM3级事件是在DOM2级事件的基础上添加很多事件类型如

load,scroll,blur,focus,dbclick,mouseup,mousewheel,textInput,keydown,keypress，
同时也允许使用者自定义一些事件
</code></pre>
<h2 id="23js获取盒模型宽高">23.js获取盒模型宽高</h2>
<pre><code>最常用，兼容性最好 dom.offsetWidth/offsetHeight
offsetWidth/offsetHeight,clientWidth/clientHeight与srcollWidth/scrollHeight的区别

* offsetWidth/offsetHeight返回包含content+padding+**border** **全部宽高**
* clientWidth/clientHeight返回包含content+padding，如果有滚动条，也不包含滚动条
* scrollWidth/scrollHeight返回包含content+paddin+溢出内容的尺寸
</code></pre>
<h2 id="24ajax">24.Ajax</h2>
<pre><code>// 创建XMLHTTPRequest对象
var xhr = new XMLHttpRequest();
// 创建一个新的http请求
xhr.open(&quot;get&quot;, url, true)
// 设置响应HTTP请求状态变化的函数
xhr.onreadystatechange = function(){
    if(xhr.readyState == 4){
        if(xhr.status == 200){
            // 获取异步调用返回的数据
            alert(xhr.responseText)
        }
    }
}
// 发送HTTP请求
xhr.send(null);
</code></pre>
<p>状态码readyState说明：0：未初始化，未调用send()；1：已调用send()，正在发生请求；2:send()方法执行完毕，已经接收到全部响应内容；3：正在解析响应内容；4：解析完成，可以在客户端调用了</p>
<h2 id="25跨域">25.跨域</h2>
<p>跨域指通过JS在不同的域之间进行数据传入或通信。 协议，域名，端口有一个不同就是跨域。同源策略是为了防止CSRF攻击，它是利用用户的登录态发起恶意请求。</p>
<h3 id="解决跨域方式">解决跨域方式</h3>
<p>1.JSONP使用简单，兼容性不错但仅限GET请求</p>
<p>2.CORS需要前后端同时支持，服务器端设置Access-Control-Origin开启CORS，该属性表明哪些域名可以访问资源。</p>
<p>3.document.domain 只适用于二级域名相同，a.test.com。在页面添加docuemtn.domain = 'test.com'表示二级域名相同即可跨域</p>
<p>4.postMessage 通常用于获取嵌入页面(iframe)的第三方页面数据，一个页面发送消息，另一个页面判断来源并接收消息.</p>
<pre><code>// 发送消息
window.parent.postMessage('message', 'http://www.test.com')
// 接收消息
let mc=new MessageChannel()
mc.addEventListener('message', event =&gt; {
    let origin = event.origin || event.originalEvent.origin;
    if(origin === 'http://www.test.com'){
        console.log('验证通过')
    }
}
</code></pre>
<h2 id="26server-worker的工作">26.Server Worker的工作？</h2>
<h3 id="缓存文件">缓存文件</h3>
<p>与缓存进行交互，当用户请求缓存中的东西时，Service Worker能立刻从缓存中获取数据不通过外部https调用,传输协议必须为https，目前该技术通常用来做缓存文件，提高首屏速度</p>
<h3 id="发送推送通知">发送推送通知</h3>
<p>运行背景同步：在离线的情况下用浏览器发送一个文件，Service Worker可以保存此任务，等网络连接恢复后将文件上传至外部服务器</p>
<h2 id="27indexdb">27.indexDB</h2>
<p>Cookie 的大小不超过4KB，且每次请求都会发送回服务器；LocalStorage 在 2.5MB 到 10MB 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。indexDB都可以做到，存储无上限</p>
<h2 id="28浅拷贝-深拷贝">28.浅拷贝 &amp;&amp; 深拷贝</h2>
<p>1.栈（stack）为自动分配的内存空间，它由系统自动释放，存放基本类型（不可改变）；而堆（heap）则是动态分配的内存，大小不定也不会自动释放，存放引用类型。</p>
<p>2.基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的；引用类型的比较是引用的比较，比较是否指向同一块堆内存</p>
<p>3.基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中。引用类型的赋值是传址。只是改变指针的指向</p>
<p>4.深拷贝：将 B 对象拷贝到 A 对象中，包括 B 里面的子对象；浅拷贝：将 B 对象拷贝到 A 对象中，但不包括 B 里面的子对象</p>
<pre><code>深拷贝： JSON.parse(JSON.stringify(Obj))对象中存在循环对象无法处理
Object.create()
Object.assign() 对象只有一层
obj2 = _.cloneDeep(obj1) 复杂情况的深拷贝使用lodash实现
浅拷贝： 
= 赋值
...  es6展开符
object.assign()  对象有多层
</code></pre>
<h2 id="29flex-rem-vw-wh">29.flex + rem + vw wh</h2>
<p>flexible+vue    使用lib-flexible和px2rem</p>
<h3 id="flex">flex</h3>
<p>flex 是 flex-grow（放大），flex-shrink （缩放）和 flex-based （基本）的缩写  默认flex:0 1 auto;</p>
<p>flex-grow 控制的是 flex 项的拉伸比例，而不是占据 flex 容器的空间比例。当设置为 0 时，该 flex 项将不会被拉伸去填补剩余空间；两个项的比例是 1:2，意思是在被拉伸时，第一个 flex 项将占用 1/3，而第二个 flex 项将占据余下的空间。flex-shrink相反；flex-based 自定义元素宽度，200px ,10%都行</p>
<p>以下6个属性设置在容器上。</p>
<pre><code>* 		flex-direction
* 		flex-wrap
* 		flex-flow
* 		justify-content
* 		align-items
* 		align-content
</code></pre>
<p>以下6个属性设置在项目上。</p>
<pre><code>* 		order
* 		flex-grow
* 		flex-shrink
* 		flex-basis
* 		flex
* 		align-self
</code></pre>
<h3 id="rem">rem</h3>
<p>计算方式： 设计稿px  /  根节点px  =  真实rem；flexible实际上就是能过JS来动态改写meta标签，动态改写<meta>标签，给<html>元素添加data-dpr属性，并且动态改写data-dpr的值，给<html>元素添加font-size属性，并且动态改写font-size的值</p>
<h3 id="vh-vw">vh vw</h3>
<p>vh vw是相对视口（viewport）的宽度而定的，长度等于视口宽度的1/100，当前屏幕可见高度的1%。 假如浏览器的宽度为200px，那么1vw就等于2px（200px/100）。 vh是相对视口（viewport）的高度而定的，长度等于视口高度的1/100。 假如浏览器的高度为500px，那么1vh就等于5px（500px/100<br>
calc(100vh - 10px)  表示整个浏览器窗口高度减去10px的大小</p>
<h2 id="30js-结果舍入运算">30.js 结果舍入运算</h2>
<pre><code>* x.toFixed( num)  将x保留num位小数  
* Math.round(x)   四舍五入 round() 方法可把一个数字舍入为最接近的整数
* parseInt() 丢弃小数部分,保留整数部分
* Math.ceil() 向上取整,有小数就整数部分加1 
* Math.floor()  向下取整
</code></pre>
<h2 id="31类型转换">31.类型转换</h2>
<p>只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。1 + '1' = '11'  2 * '2' = 4</p>
<h2 id="32防抖-节流">32.防抖 &amp;&amp; 节流</h2>
<p>防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数wait）调用函数。</p>
<p><strong>防抖</strong>：通过定时器延迟执行某个函数，点击时，只有过了自定义的time，才能再次点击</p>
<p><strong>节流</strong>：防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。</p>
<h2 id="33-this">33. this</h2>
<h3 id="this指向">this指向</h3>
<p>定义：this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象。总结：</p>
<pre><code>1.在普通函数内部，this的指向是window
2.在方法内部，this的指向是方法的拥有者。
3.在箭头函数内部，this指向是创建箭头函数时所在的环境中的this指向的值。
4.在对象中，this指向当前对象，这里的this指向会发生改变     
5.计时器中的this
6.回调函数中的this
7.事件处理函数中的this指向事件的绑定者
</code></pre>
<h2 id="34安全">34.安全</h2>
<h3 id="xss">XSS</h3>
<p>XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站。<br>
最普遍的做法是转义（replace）输入输出的内容，对于引号，尖括号，斜杠进行转义。显示富文本的采用白名单过滤的方式<br>
CSP CSP 本质上也是建立白名单，通常可以通过 HTTP Header 中的 Content-Security-Policy 来开启 CSP</p>
<h3 id="csrf">CSRF</h3>
<p>CSRF 就是利用用户的登录态发起恶意请求。<br>
防御：</p>
<pre><code>1.请求时附带验证信息，比如验证码或者 token
2.验证 Referer:对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。
3.Token:服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效
4.信息加密
</code></pre>
<h3 id="sql注入">SQL注入</h3>
<p>就是攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。 攻击者通过在应用程序预先定义好的SQL语句结尾加上额外的SQL语句元素，欺骗数据库服务器执行非授权的查询,篡改命令。</p>
<p><strong>参数化查询</strong>已被视为最有效的可防御SQL注入攻击的防御方式。目前主流的ORM 框架都内置支持并且推荐使用这种方式进行持久层封装。<strong>参数化查询</strong>是指在设计与数据库链接并访问数据时，在需要填入数值或数据的地方，使用参数来给值。</p>
<h2 id="35为什么不推荐使用setinterval">35.为什么不推荐使用setInterval</h2>
<p>js 的执行原理：js引擎是单线程的，主要分为主线程和事件队列，同步操作是在主线程上执行，而异步操作的函数会先放在事件队列当中，等到js主线程空闲了，才会去事件队列取出放到主线程执行。定时器是属于异步事件，参数里面设置的时间，并不是延迟多少秒去执行回调函数，这个时间代表的是延迟多少秒，把回调函数放到异步队列，等待主线程空闲再被执行。</p>
<p>如果当事件队列当中，已经存在了定时器的回调函数，即使已经到了规定的间隔时间，也不会再把这个时间点的定时器回调函数放到事件队列当中，定时器依旧运行。当下一个约定时间又到了，如果事件队列当中依然存在定时器的回调函数，这个时间点的定时器回调函数也不会放进事件队列…</p>
<h2 id="36中文版chrome浏览器不支持12px以下字体的解决方案">36.中文版Chrome浏览器不支持12px以下字体的解决方案</h2>
<p>一般解决方案是禁止webkit浏览器配置调整网页的字体大小。如下CSS定义方式：<br>
.classstyle{ -webkit-text-size-adjust:none; font-size:9px; }</p>
<h2 id="37const定义的对象属性是否可以改变">37.const定义的对象属性是否可以改变</h2>
<p>const仅保证指针不发生改变，修改对象的属性不会改变对象的指针，所以是被允许的。也就是说const定义的引用类型只要指针不发生改变，其他的不论如何改变都是允许的</p>
<h2 id="38函数柯里化curry">38.函数柯里化（curry）</h2>
<p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。curry 的这种用途可以理解为：参数复用。本质上是降低通用性，提高适用性。<br>
对于需要传入多个参数的函数，可以写一个公共的函数，其他地方需要时传入对应值</p>
<pre><code>var prop = curry(function (key, obj) {
    return obj[key]
});
var name = person.map(prop('name'))
</code></pre>
<h2 id="39getelementby-和-queryselector-区别">39.getElementBy*  和 querySelector 区别</h2>
<p>getElementById / querySelector 这两个获取到的都是dom节点，结果没有区别。</p>
<p>getElement* 的实时性体现在返回集合的时候，我们知道getElementsBy*和querySelectorAll返回的都是一个节点集合，类似于数组，两种方法的区别就在于这个集合会不会自动更新。<br>
getEle会，queryS不会</p>
<h2 id="39性能">39.性能</h2>
<h3 id="1缓存强缓存-协商缓存">1.缓存（强缓存 &amp; 协商缓存）</h3>
<p><strong>强缓存</strong>：实现强缓存可以通过两种响应头实现：Expires （1.0）和 Cache-Control （1.1）。强缓存表示在缓存期间不需要请求，state code 为 200；设置资源的到期时间</p>
<p><strong>协商缓存</strong>：缓存过期，使用协商缓存需要发送请求，如果缓存有效这返回304。两种实现方式1.Last-Modified 和 If-Modified-Since 2.ETag 和 If-None-Match</p>
<h3 id="2使用http-20">2.使用HTTP / 2.0</h3>
<p>在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小。</p>
<h3 id="3懒加载">3.懒加载</h3>
<p>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。</p>
<h3 id="4图片优化">4.图片优化</h3>
<pre><code>1.计算图片大小,减少像素点，减少每个像素点能够显示的颜色
2.使用css代替部分图片
3.移动端使用cdn根据屏幕大小加载已经剪切好的图片
4.雪碧图
5.可以的话使用webP格式图片
</code></pre>
<p>题型：如何渲染几万条数据并不卡住界面</p>
<p>可以通过 requestAnimationFrame 来每 16 ms 刷新一次。</p>
<h1 id="2019-3-29">2019-3-29</h1>
<p><strong>为了春招准备的，由于菜， 零offer。。。</strong></p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://alexwjj.github.io//tag/interView" class="tag">
                    面试技巧
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://alexwjj.github.io//post/fe-study">
                  <h3 class="post-title">
                    前端自学31天
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '3a75e9876da102702b06',
        clientSecret: '9b9c930a40f564a860f43ce401d79bebd588137f',
        repo: 'alexwjj.github.io',
        owner: 'alexwjj',
        admin: ['alexwjj'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
