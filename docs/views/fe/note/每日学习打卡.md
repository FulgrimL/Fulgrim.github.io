---
title: 每日学习打卡
sidebar: 'false'
date: 2021-01-12
tags:
 - 学习打卡
categories:
 - 学习打卡
---

> 当身边发生了这样的案例，你就知道学习的重要性了
<!-- more -->

# 一月份

## 1.12

### node返回一个html
```
response.writeHead(200,{'Content-Type':'text/html'})
fs.readFile('./practice/login.html','utf-8',function(err,data){
if(err){
throw err ;
}
response.end(data);
});
```
egg中参考：[egg 模板渲染](https://eggjs.org/zh-cn/core/view.html)

注意配置静态文件存放地址：一般放在app/view中
###  Object.defineProperty() 不能监听数组长度变化以及对象新属性的变化

通过下标修改数组长度，数组的length属性被初始化configurable	false，所以想要通过get/set方法来监听length属性是不可行的。

vue中通过重写了七个能改变原数组的方法来进行数据监听

对象还是使用Object.defineProperty()添加get和set来监听

参考
- [vue通过数组索引修改数据，视图会变化吗？](https://mp.weixin.qq.com/s/PepQf9LtxIER9xE9MVEAxw)

- [为什么defineProperty不能检测到数组长度的变化](https://youngzhang08.github.io/2018/07/30/%E4%B8%BA%E4%BB%80%E4%B9%88defineProperty%E4%B8%8D%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E7%9A%84%E5%8F%98%E5%8C%96/)
### 实现一个拖拽组件
```
document.onmousedown = function(e) {
	//获取目标元素
	let dropDom = e.target; 
	//算出鼠标相对元素的位置
	let disX = e.clientX - dropDom.offsetLeft;
	let disY = e.clientY - dropDom.offsetTop;
	//鼠标按下并移动的事件
	document.onmousemove = (e) => {
		//用鼠标的位置减去鼠标相对元素的位置，得到元素的位置
		let left = e.clientX - disX;
		let top = e.clientY - disY;

		//绑定元素位置到positionX和positionY上面,貌似没啥用
		this.positionX = top;
		this.positionY = left;

		//移动当前元素
		dropDom.style.left = left + "px";
		dropDom.style.top = top + "px";
	};
	document.onmouseup = (e) => {
		document.onmousemove = null;
		document.onmouseup = null;
	};
};
```
### 不知道父元素宽高，水平垂直居中兼容性较好的方案
```
position: absolute;
left: 0;
top: 0;
bottom: 0;
right: 0;
margin: auto;
```

### 输入字符串 '1,5,3,2,10,8,7' 输出字符串 '1~3,5,7~8,10'
```
const str = '1,5,3,2,10,8,7';
const test = (str) => {
	// 分割（注意分割后的每一项字符串）
	// sort排序，a-b从小，b-a从大
	const arr = str.split(',').sort((a, b) => +a - +b)
  let res = [];
  let pre = arr[0];
  let next = arr[0];
  let j = 0;
  arr.forEach((v, i) => {
    if (+v + 1 === +arr[i + 1]) {
      next = arr[i + 1];
    } else {
      res[j] = (pre === next ? arr[i] : `${pre}~${next}`);
      pre = next = arr[i + 1];
      j++;
    }
  });
  return res.join(',');
};
console.log(test(str));
```

## 1.13
### 搭建UI组件库

- 正常编写一个组件，只是最后需要install一下导出的组件
- umd规范打包产物 package配置`vue-cli-service build --target lib --name tag-textarea --dest lib src/index.js`或者打包入口配置`libraryTarget: 'umd'`
- `import { Alert, Button } from 'ui-library'` 这种按需引入方式，还需要借助第三方的 babel 插件来,Element-ui 的 `babel-plugin-component`,Ant Design 的 `babel-plugin-import`
- npm包发布，`npm login /  npm puslish`
- 参考：[前端 UI 组件库搭建指南](https://juejin.cn/post/6844904009535324173#heading-17)

### OAuth 2.0

OAuth 2.0 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。

较多的做法是：客户端发起请求，通过client_id和redirect_uri跳转到授权页，拿到授权code后回来，与服务端换取后续鉴权的token

参考： [理解OAuth 2.0   阮一峰](https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)

### HTTP请求的限制

`HTTP/1.1` 存在一个问题：单个 TCP 连接在同一时刻只能处理`一个请求`,只能在同一连接上顺序处理多个请求。
虽然 `HTTP/1.1` 规范中规定了 `Pipelining` 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。

HTTP2 提供了 `Multiplexing` 多路传输特性，可以在一个 TCP 连接中同时完成`多个 HTTP 请求`

Chrome 最多允许对`同一个 Host` 建立`6个` TCP 连接,不同的浏览器有一些区别

参考：[你知道一个TCP连接上能发起多少个HTTP请求吗？](http://www.52im.net/thread-2680-1-1.html)

### TCP 三次握手和四次挥手，同事大佬总结的
#### 三次握手
目的：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误

过程：
- 第一次握手：建立连接时，客户端发送`syn（握手信号）包`（syn=j）到服务器，并进入SYN_SENT（请求连接）状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
- 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即`SYN+ACK包`，此时服务器进入SYN_RECV（服务端被动打开后,接收到了客户端的SYN并且发送了ACK时的状态）状态；
- 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包`ACK(ack=k+1）（确认字符）`，此包发送完毕，客户端和服务器进入ESTABLISHED（`TCP连接成功`）状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据

在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包（syn=j）开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于 Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。
####  四次挥手
目的：TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。`TCP是全双工模式`，双方都要发送FIN包来确认断开连接。这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。

过程:
- 第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。
- 第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。
- 第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。
- 第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。
### js 驼峰命名和下划线互换
```
// 下划线转换驼峰
function toHump(name) {
    return name.replace(/\_(\w)/g, function(all, letter){
        return letter.toUpperCase();
    });
}
// 驼峰转换下划线
function toLine(name) {
  return name.replace(/([A-Z])/g,"_$1").toLowerCase();
}


// 测试
let a = 'a_b2_345_c2345';
console.log(toHump(a));

let b = 'aBdaNf';
console.log(toLine(b));
```

## 1.14
- 树结构生成
- 动态规划-股票最大利益算法题
- typescript学习
- interface 和 type 的区别