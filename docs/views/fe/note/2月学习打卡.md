---
title: 【每日学习打卡】2.6
sidebar: "auto"
date: 2021-02-06
tags:
  - 学习打卡
categories:
  - 学习打卡
---

> 把自己当做 30 岁来活，30 岁的自己会感谢 24 岁的你，加油 🆙

<!-- more -->

<!-- :::tip
::: -->
## 过年在杭州计划 9天
- vue3 + TS  实现部分当前业务逻辑
- react hooks + TS  实现部分当前业务逻辑
- webpack 源码
- 算法打卡10题
- 浏览器原理学习+文章输出
<!-- ## 目录

[[toc]] -->

<!-- ## 计划中
- webpack系统性学习
- babel
- typescript应用到微服务中
- 计算机网络系统性复习，毕竟专业
- vite
- lodash源码加入学习计划
- 正则表达式  -->
<!-- ## 计划 -->
<!-- ### 浏览器内部机制 -->
## 2.6 
买了门课， 【JavaScript 核心原理精讲】看一波
### http协议中301和302的区别
- 301代表资源的永久重定向，302代表资源的临时重定向
- 很多的第三方授权，授权过后的回跳地址经常会使用301形式，改变浏览器的回跳地址。

### 单个input enter会刷新页面
- 写一个隐藏的input
- el-form @submit.native.prevent
- 屏蔽回车键，比较low

### 正则表达式符号，老是忘
- ^以什么为开始
- \s匹配任意的空白符
- *只匹配出现 0 次及以上 * 前的字符
- ()分组 []匹配方括号内的任意字符
- ?之前字符可选
- \d匹配数字
- +只匹配出现 1 次及以上 + 前的字符 .匹配任意字符除了换行符和回车符(贪婪匹配)
## 2.5
### lodash _get()实现
访问a.b.c.d.e 报错处理，最新的语法可以写：a?.b?.c?.d?.e 来访问,但是语义不明确，兼容性要求较高。

使用lodash get较好
```js
function get (source, path, defaultValue) {
  const paths = path.replace(/\[(\d+)\]/g, '.$1').split('.')
  let result = source
  for (const p of paths) {
    result = Object(result)[p]
    if (!result) {
      return defaultValue
    }
  }
  return result
}

```

### 计算时区
迷迷糊糊
```js
// 将一天24小时按每半小划分成48段，我们用一个位图表示选中的时间区间，
// 例如`110000000000000000000000000000000000000000000000`，
// 表示第一个半小时和第二个半小时被选中了，其余时间段都没有被选中，
// 也就是对应00:00~01:00这个时间区间。一个位图中可能有多个不连续的
// 时间区间被选中，例如`110010000000000000000000000000000000000000000000`，
// 表示00:00-1:00和02:00-02:30这两个时间区间被选中了。

// 要求：写一个函数timeBitmapToRanges，将上述规则描述的时间位图转换成一个选中时间区间的数组。
// 示例输入：`"110010000000000000000000000000000000000000000000"`
// 示例输出：`["00:00~01:00", "02:00~02:30"]`
function format(start, end) {
    let endHour = (end / 2).toFixed(1);
    let startHour = (start / 2).toFixed(1);
    let reg = /(\d+)\.(\d+)/;
    const endRes = endHour.match(reg);
    const startRes = startHour.match(reg);
    return (
        addZero(startRes[1]) +
        ':' +
        addZero(startRes[2]) +
        '~' +
        addZero(endRes[1]) +
        ':' +
        addZero(endRes[2])
    );
}
function addZero(num) {
    num = num === '5' ? '30' : num;
    return num.length > 1 ? num : '0' + num;
}
function timeBitmapToRanges(timeBitmap) {
    let timeArr = timeBitmap.split('').map(v => +v);
    const res = [];
    let range = {};
    let start = 0;
    for (let i = 0; i <= timeArr.length; i++) {
        if (timeArr[i]) {
            start++;
        }
        if (!timeArr[i] && timeArr[i - 1]) {
            range[i] = start;
            start = 0;
        }
    }
    for (let j in range) {
        res.push(format(parseInt(j - range[j]), parseInt(j)));
    }
    return res;
}

console.log(
    timeBitmapToRanges('110010000000000000001110000000000000000000000111')
);
// [ '00:00~01:00', '02:00~02:30', '10:00~11:30', '22:30~24:00' ]


```

### 实现 getValue 函数来获取path对应的值
```js
var object = { 'a': [{ 'b': { 'c': 3 } }] }; // path: 'a[0].b.c'
var array = [{ "a": { b: [1] } }]; // path: '[0].a.b[0]'

function getValue(target, valuePath, defaultValue) {
    let res = ''
    if(Object.prototype.toString.call(target) === '[object Object]') {
        let pathArr = valuePath.split('.'); // [a[0],b,c]
        pathArr.forEach(item => {
            if(item.includes('[')) {
                let iItem = 0;
                item.match(/[0-9]/g, function($0) {
                    iItem = $0
                })
                let key = item.split('[')[0]
                res = target[key][iItem]
            } else {
                res = res[item]
            }
        })
    }
    // 数组处理有点问题。后面再想想
    // if(Array.isArray(target)) {
    //     target.forEach(item => {
    //         getValue(item)
    //     })
    // };
    return res || defaultValue;
}

console.log(getValue(object, 'a[0].b.c', 0));  // 输出3
// console.log(getValue(array, '[0].a.b[0]', 12)); // 输出 1
// console.log(getValue(array, '[0].a.b[0].c', 12));  // 输出 12
```



## 2.4

### 提醒自己保持学习

### lodash 源码加入学习计划

### 天天开会太忙了，年后都安排满了，周六恶补一下

### 实现 isEqual 函数 思路

要考虑的情况很多，可以参考 lodash 的实现

- +0 -0 ，NaN， null undefined 都可以用 Object.is 判断
- 对象 Object.prototype.toString.call === [object Object] 注意第二个 Object O 大写

只考虑对象和数组，基本就是递归的思想

```js
function isEqual(a, b) {
  // 只考虑对象，或者数组
  if (areArrays) {
    length = a.length;
    if (length !== b.length) return false;

    while (length--) {
      if (!eq(a[length], b[length])) return false;
    }
  } else {
    var keys = Object.keys(a),
      key;
    length = keys.length;

    if (Object.keys(b).length !== length) return false;

    while (length--) {
      key = keys[length];
      if (!(b.hasOwnProperty(key) && eq(a[key], b[key]))) return false;
    }
  }
  return true;
}
```

## 2.3

### 页面白屏 loading

spa 应用可以直接在容器里面写，当 vue、react 挂载阶段完成以后，会替换掉其中的内容，自动移除掉 loading 了。

```html
<div id="app">
  <div id="loadding"></div>
</div>
```

### vite 真的 nb，得系统学习一波，产出一篇文章试试

## 2.2

### Reflect

Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 proxy handlers 的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。

Reflect 的所有属性和方法都是静态的，该对象提供了与 Proxy handler 对象相关的 13 个方法。这里只列举以下 5 个常用的方法：

- Reflect.get(target, propertyKey[, receiver])：获取对象身上某个属性的值，类似于 target[name]。
- Reflect.set(target, propertyKey, value[, receiver])：将值赋值给属性的函数。返回一个布尔值，如果更新成功，则返回 true。
- Reflect.deleteProperty(target, propertyKey)：删除 target 对象的指定属性，相当于执行 delete target[name]。
- Reflect.has(target, propertyKey)：判断一个对象是否存在某个属性，和 in 运算符的功能完全相同。
- Reflect.ownKeys(target)：返回一个包含所有自身属性（不包含继承属性）的数组

### 让文字的显示变为垂直方向

作用与父元素：`writing-mode: vertical-lr;` 注意兼容性

### grid 垂直居中

```css
.wrapper {
  width: 300px;
  height: 300px;
  border: 1px solid #ccc;

  display: grid;
}

.wrapper > p {
  align-self: center;
  justify-self: center;
}
```

### 行内元素的 margin 和 padding

- 水平方向：水平方向上，都有效；
- 垂直方向：垂直方向上，都无效；（padding-top 和 padding-bottom 会显示出效果，但是高度不会撑开，不会对周围元素有影响）

### 什么是 CSP？

- CSP（Content-Security-Policy）指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。
- 通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 <meta http-equiv="Content-Security-Policy">
- CSP 也是解决 XSS 攻击的一个强力手段。

### 什么是尾调用？

尾调用指的是函数的最后一步调用另一个函数。我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。

### 打印背景，浏览器默认不勾选

#### 1、css

```js
@media print {
     body{
        -webkit-print-color-adjust:exact;
        -moz-print-color-adjust:exact;
        -ms-print-color-adjust:exact;
        print-color-adjust:exact;
    }
}
```

### 2、js 基本就是写背景图

### apply 实现 bind

```js
// bind没有立即执行函数
Function.prototype.Mybind = function(context) {
  let _me = this;
  return function() {
    return _me.apply(context);
  };
};
```

## 2.1

### react hooks

- useState: 用来声明状态 state，修改值需要手动合并
- useEffect: 用来替换类组件中的生命周期函数，简化重复的操作
- useContext: 全局共享状态，解决祖先/子孙组件之间的传参问题
- useReducer: useState 的替换方案，将操作和更新解绑,配合 useContxet 可以实现简易 redux
- useCallback: 对函数进行缓存，优化性能
- useMemo: 对值进行缓存，优化性能
- useRef:获取 DOM 节点或组件实例， 保存变量

### vite

- 当浏览器识别 type="module"引入 js 文件的时候，内部的 import 就会发起一个网络请求，尝试去获取这个文件

- vite 主要是是开发时做到了真正的动态加载，打包还是需要借助于 rollup
