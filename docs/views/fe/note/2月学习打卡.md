---
title: 【每日学习打卡】2.1
sidebar: 'auto'
date: 2021-02-01
tags:
 - 学习打卡
categories:
 - 学习打卡
---

> 你看你胖的那个熊样🐻，必须减肥了。曾经120+的我
<!-- more -->
:::tip
没有什么比别人的刺激能让自己进步更快了
:::

<!-- ## 目录

[[toc]] -->

<!-- ## 计划中
- webpack系统性学习
- babel
- typescript应用到微服务中
- 计算机网络系统性复习，毕竟专业
- vite
- 正则表达式  -->
<!-- ## 计划 -->
<!-- ### 浏览器内部机制 -->
## 2.1

### react hooks
- useState: 用来声明状态state，修改值需要手动合并
- useEffect: 用来替换类组件中的生命周期函数，简化重复的操作
- useContext: 全局共享状态，解决祖先/子孙组件之间的传参问题
- useReducer: useState的替换方案，将操作和更新解绑,配合useContxet可以实现简易redux
- useCallback: 对函数进行缓存，优化性能
- useMemo: 对值进行缓存，优化性能
- useRef:获取DOM节点或组件实例， 保存变量

### vite 
- 当浏览器识别type="module"引入js文件的时候，内部的import 就会发起一个网络请求，尝试去获取这个文件

- vite 主要是是开发时做到了真正的动态加载，打包还是需要借助于rollup


## 2.2
### Reflect

Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 proxy handlers 的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。

Reflect 的所有属性和方法都是静态的，该对象提供了与 Proxy handler 对象相关的 13 个方法。这里只列举以下 5 个常用的方法：

- Reflect.get(target, propertyKey[, receiver])：获取对象身上某个属性的值，类似于 target[name]。
- Reflect.set(target, propertyKey, value[, receiver])：将值赋值给属性的函数。返回一个布尔值，如果更新成功，则返回 true。
- Reflect.deleteProperty(target, propertyKey)：删除 target 对象的指定属性，相当于执行 delete target[name]。
- Reflect.has(target, propertyKey)：判断一个对象是否存在某个属性，和 in 运算符的功能完全相同。
- Reflect.ownKeys(target)：返回一个包含所有自身属性（不包含继承属性）的数组

### 让文字的显示变为垂直方向

作用与父元素：`writing-mode: vertical-lr;` 注意兼容性

### grid 垂直居中
```css
.wrapper {
    width: 300px;
    height: 300px;
    border: 1px solid #ccc;

    display: grid;
}

.wrapper > p {
    align-self: center;
    justify-self: center;
}
```

### 行内元素的margin 和 padding
- 水平方向：水平方向上，都有效；
- 垂直方向：垂直方向上，都无效；（padding-top 和 padding-bottom 会显示出效果，但是高度不会撑开，不会对周围元素有影响）

### 什么是 CSP？
- CSP（Content-Security-Policy）指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。
- 通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 <meta http-equiv="Content-Security-Policy">
- CSP 也是解决 XSS 攻击的一个强力手段。

### 什么是尾调用？

尾调用指的是函数的最后一步调用另一个函数。我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。

### 打印背景，浏览器默认不勾选
#### 1、css
```js
@media print {
     body{
        -webkit-print-color-adjust:exact;
        -moz-print-color-adjust:exact;
        -ms-print-color-adjust:exact;
        print-color-adjust:exact;
    } 
}
```
### 2、js 基本就是写背景图

### apply 实现bind
```js
// bind没有立即执行函数
Function.prototype.Mybind = function (context) {
    let _me = this
    return function () {
    return _me.apply(context)
    }
}
```
## 2.3 
### 页面白屏loading
spa应用可以直接在容器里面写，当vue、react挂载阶段完成以后，会替换掉其中的内容，自动移除掉loading了。
```html
<div id="app">
    <div id="loadding">
    </div>
</div>
```
### vite真的nb，得系统学习一波，产出一篇文章试试

