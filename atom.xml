<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://alexwjj.github.io/</id>
    <title>俊劫、的前端博客</title>
    <updated>2019-07-24T01:02:29.398Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://alexwjj.github.io/"/>
    <link rel="self" href="https://alexwjj.github.io//atom.xml"/>
    <subtitle>讲个笑话，你可别哭。</subtitle>
    <logo>https://alexwjj.github.io//images/avatar.png</logo>
    <icon>https://alexwjj.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 俊劫、的前端博客</rights>
    <entry>
        <title type="html"><![CDATA[TypeScript 入门]]></title>
        <id>https://alexwjj.github.io//post/typescript-ru-men</id>
        <link href="https://alexwjj.github.io//post/typescript-ru-men">
        </link>
        <updated>2019-07-23T09:48:47.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>想到怎么牛皮的 vsCode 是 TS 写的。<br>
立马就跑去了解了一下<br>
死亡如风~~~ eeeeeeee</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>想到怎么牛皮的 vsCode 是 TS 写的。<br>
立马就跑去了解了一下<br>
死亡如风~~~ eeeeeeee</p>
</blockquote>
<!-- more -->
<h1 id="1注意点">1.注意点</h1>
<ul>
<li>约定使用 TypeScript 编写的文件以 .ts 为后缀，用 TypeScript 编写 React 时，以 .tsx 为后缀。</li>
<li>TypeScript 编译的时候即使报错了，还是会生成编译结果。如果要在报错的时候终止 js 文件的生成，可以在 tsconfig.json 中配置 noEmitOnError 即可</li>
<li>注意，使用构造函数 Boolean 创造的对象不是布尔值，返回的是一个 Boolean 对象</li>
<li>可以使用 null 和 undefined 来定义这两个原始数据类型。let n: null = null;</li>
</ul>
<h1 id="2基础">2.基础</h1>
<h2 id="any-类型">any 类型</h2>
<p>则允许被赋值为任意类型。let myFavoriteNumber: any = 'seven';  myFavoriteNumber = 7。 不报错</p>
<h2 id="类型推论">类型推论</h2>
<pre><code>let myFavoriteNumber = 'seven';  myFavoriteNumber = 7;  报错
// 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查
let myFavoriteNumber;
myFavoriteNumber = 'seven';
myFavoriteNumber = 7; // 不报错
</code></pre>
<h2 id="联合类型">联合类型</h2>
<pre><code>// let myFavoriteNumber: string | number;
// 当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：
function getLength(something: string | number): number {
    return something.length; // 报错
    return something.toString(); // 不报错
}
</code></pre>
<h2 id="interface">interface</h2>
<p>使用接口（Interface）来定义对象的类型，需要注意的是，</p>
<pre><code>interface Person {
    name: string;
    age: number;// 变量与 interface 定义的要相同，多或者少都会报错
    sex?: string;// 加？的变量可以不存在，但是仍然不可以添加未声明的变量
    [propName: string]: any; // 接口允许有任意的属性，确定属性和可选属性的类型都必须是它的类型的子集
    readonly id: number;  // 创建时只读，不可修改
}
</code></pre>
<h2 id="数组类型">数组类型</h2>
<pre><code>let fibonacci: number[] = [1, 1, 2, 3, 5];
let fibonacci: number[] = [1, '1', 2, 3, 5]; // 报错，数组中不允许出现其他类型
fibonacci.push('8');  // 数组的一些方法的参数也会根据数组在定义时约定的类型进行限制,只能 push number 类型的参数
// 数组泛型
let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];  
// interface 表示数组
interface NumberArray {
    [index: number]: number;
}
let fibonacci: NumberArray = [1, 1, 2, 3, 5];

let list: any[] = ['Xcat Liu', 25, { website: 'http://xcatliu.com' }]; // any 表示数组中允许出现任意类型
</code></pre>
<h2 id="函数">函数</h2>
<pre><code>// 函数声明，必选参数个数不对就报错，定义可选参数 z?: string, 注：可选参数必须在必选参数后面定义
// 默认参数：lastName: string = 'Cat' 。TypeScript 会将添加了默认值的参数识别为可选参数：
function sum(x: number, y: number): number {
    return x + y;
}
// 函数表达式
// ts 类型推论出来的
let mySum = function (x: number, y: number): number {
    return x + y;
};
// 标准定义
let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number {
    return x + y;
};
// 注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。
// 在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。
// 接口定义函数
interface SearchFunc {
(source: string, subString: string): boolean;
}
// 函数重载, eg:reverse 函数，定义多个 reverse 函数
function reverse(x: number): number; // 函数定义
function reverse(x: string): string; // 函数定义
// 函数实现
function reverse(x: number | string): number | string {
    if (typeof x === 'number') {
        return Number(x.toString().split('').reverse().join(''));
    } else if (typeof x === 'string') {
        return x.split('').reverse().join('');
    }
}
</code></pre>
<h2 id="类型断言">类型断言</h2>
<pre><code>// 有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法
// 类型断言的用法如下，在需要断言的变量前加上 &lt;Type&gt; 即可
function getLength(something: string | number): number {
    if ((&lt;string&gt;something).length) {
        return (&lt;string&gt;something).length;
    } else {
        return something.toString().length;
    }
}
</code></pre>
<h1 id="3-声明">3. 声明</h1>
<h2 id="注意点">注意点</h2>
<ul>
<li>声明文件必需以 .d.ts 为后缀</li>
<li>一般来说，全局变量都是禁止修改的常量，所以大部分情况都应该使用declare const</li>
<li>声明语句中只能定义类型，切勿在声明语句中定义具体的实现</li>
<li>declare namespace 还是比较常用的，它用来表示全局变量是一个对象，包含很多子属性。</li>
<li>与普通的 npm 模块不同，@types 是统一由 DefinitelyTyped 管理的。要将声明文件发布到 @types 下，就需要给 DefinitelyTyped 创建一个 pull-request，其中包含了类型声明文件，测试代码，以及 tsconfig.json 等。</li>
</ul>
<pre><code>* declare var 声明全局变量
* declare function 声明全局方法
* declare class 声明全局类
* declare enum 声明全局枚举类型
* declare namespace 声明（含有子属性的）全局对象
* interface 和 type 声明全局类型
* export 导出变量
* export namespace 导出（含有子属性的）对象
* export default ES6 默认导出
* export = commonjs 导出模块
* export as namespace UMD 库声明全局变量
* declare global 扩展全局变量
* declare module 扩展模块
* /// &lt;reference /&gt; 三斜线指令
</code></pre>
<h1 id="4内置对象">4.内置对象</h1>
<pre><code>let b: Boolean = new Boolean(1);
let e: Error = new Error('Error occurred');
let d: Date = new Date();
let r: RegExp = /[a-z]/;
let body: HTMLElement = document.body;
let allDiv: NodeList = document.querySelectorAll('div');
document.addEventListener('click', function(e: MouseEvent) {
  // Do something
});
// Node.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：
npm install @types/node --save-dev
</code></pre>
<h1 id="5类">5.类</h1>
<ul>
<li>使用 class 定义类，使用 constructor 定义构造函数。</li>
<li>通过 new 生成新实例的时候，会自动调用构造函数。</li>
<li>使用 extends 关键字实现继承，子类中使用 super 关键字来调用父类的构造函数和方法。</li>
</ul>
<pre><code>class Cat extends Animal {
    constructor(name) {
        super(name); // 调用父类的 constructor(name)
        console.log(this.name);
    }
    sayHi() {
        return 'Meow, ' + super.sayHi(); // 调用父类的 sayHi()
    }
}

let c = new Cat('Tom'); // Tom
console.log(c.sayHi()); // Meow, My name is Tom
</code></pre>
<p>TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected。</p>
<ul>
<li>public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的</li>
<li>private 修饰的属性或方法是私有的，不能在声明它的类的外部访问，它在子类中不允许被访问的</li>
<li>protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的</li>
</ul>
<h2 id="抽象类abstract">抽象类abstract</h2>
<pre><code>// 抽象类中的抽象方法必须被子类实现
abstract class Animal {
    public name;
    public constructor(name) {
        this.name = name;
    }
    public abstract sayHi();
}

class Cat extends Animal {
    public sayHi() {
        console.log(`Meow, My name is ${this.name}`);
    }
}

let cat = new Cat('Tom');
</code></pre>
<h1 id="6类与接口">6.类与接口</h1>
<p>实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性。</p>
<p>接口可以继承接口，也可以继承类</p>
<p>举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它：</p>
<pre><code>interface Alarm {
    alert();
}

class Door {
}

class SecurityDoor extends Door implements Alarm {
    alert() {
        console.log('SecurityDoor alert');
    }
}

class Car implements Alarm {
    alert() {
        console.log('Car alert');
    }
}

一个类可以实现多个接口：Car 实现了 Alarm 和 Light 接口，既能报警，也能开关车灯。
interface Alarm {
    alert();
}

interface Light {
    lightOn();
    lightOff();
}

class Car implements Alarm, Light {
    alert() {
        console.log('Car alert');
    }
    lightOn() {
        console.log('Car light on');
    }
    lightOff() {
        console.log('Car light off');
    }
}
</code></pre>
<h1 id="7泛型">7.泛型</h1>
<p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>
<pre><code>function createArray(length: number, value: any): Array&lt;any&gt; {
    let result = [];
    for (let i = 0; i &lt; length; i++) {
        result[i] = value;
    }
    return result;
}

createArray(3, 'x'); // ['x', 'x', 'x']
// 不会报错，但有缺陷，没有指名函数返回类型。
function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {
    let result: T[] = [];
    for (let i = 0; i &lt; length; i++) {
        result[i] = value;
    }
    return result;
}

createArray&lt;string&gt;(3, 'x'); // ['x', 'x', 'x']
// 其中 T 用来指代任意输入的类型，在后面的输入 value: T 和输出 Array&lt;T&gt; 中即可使用了。
</code></pre>
<h2 id="泛型约束">泛型约束</h2>
<p>函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法<br>
这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 length 属性的变量。这就是泛型约束</p>
<pre><code>interface Lengthwise {
    length: number;
}

function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {
    console.log(arg.length);
    return arg;
}
// 传入的参数如果没有 length 属性，就会报错
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript 高级程序设计 笔记]]></title>
        <id>https://alexwjj.github.io//post/javascript-gao-ji-cheng-xu-she-ji-bi-ji</id>
        <link href="https://alexwjj.github.io//post/javascript-gao-ji-cheng-xu-she-ji-bi-ji">
        </link>
        <updated>2019-07-05T08:33:48.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>利用工作空闲之余，阅读 这本红宝书</p>
<p>收获很多，前端必读</p>
<p>记录一下自己觉得比较重要的点</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>利用工作空闲之余，阅读 这本红宝书</p>
<p>收获很多，前端必读</p>
<p>记录一下自己觉得比较重要的点</p>
</blockquote>
<!-- more -->
<h2 id="1注意点">1.注意点</h2>
<ol>
<li>创造一个<code>&lt;noscript&gt;</code>元素，用以在浏览器不支持 JavaScript 的浏览器显示替代的内容。比如：浏览器不支持，脚本功能被禁用。</li>
<li>省略 var 操作符，相当于声明了一个全局变量。  a = [1,2]</li>
<li>null 表示一个空对象指针。null === undefined // false  == // true 双等号会进行强制类型转换</li>
<li>0.1 + 0.2 === 0.3 // false IEEE754数值浮点计算通病</li>
<li>通过 addEventListener() 添加的事件只能用 removeEventListener清除</li>
<li>JSON 数据格式中对象属性 必须 加双引号</li>
</ol>
<h2 id="2基本知识点">2.基本知识点</h2>
<ol>
<li>保存浮点数需要的内存空间是整数的两倍</li>
<li>e 表示法：数值等于 e 前面的数值乘以10的指数次幂，eg：3.125e7 = 31250000。 负值：0.003 = 3e - 3</li>
<li>任何数值乘以 0 会返回 NaN.  NaN == NaN // false   isNaN() 函数</li>
<li><code>Number()</code>接受任何参数，转换规则：0false1true ,null &gt; 0, undefined &gt; NaN, '011' &gt; 11, 0xf &gt; 15 , '' &gt; 0</li>
<li>parseInt() 挨个解析，遇到非数字返回 '123blue' &gt; 123;  22.5 &gt; 22 ; '' &gt; NaN; '070' &gt; 56(八进制）；parseInt 第二个参数表示转换的基数，默认十进制；<br>
<code>[12,3].map(i =&gt; parseInt(i)) [1,NaN,NaN]</code></li>
<li>toString(n) n 表示输出数值的基数</li>
<li>逻辑与（&amp;&amp;） 进行的是短路操作。第一个为 false，后面的不会执行</li>
<li>arguments一种类数组对象 代表函数的参数，可以通过 arguments[0]访问函数第一个参数，没有则是 undefined；通过判断传入参数的类型和数量，模仿方法的重载。</li>
<li>作用域链本质上是一个指向变量对象的指针列表</li>
<li>单例（singleton） 指的是只有一个实例的对象</li>
<li>addHandler（element, event, function)   添加事件</li>
<li>postMessage（发送的消息，接收方域名）</li>
<li>JSON.stringify(obj, 过滤器、函数、数组， 是否保留缩进）</li>
<li></li>
</ol>
<h2 id="3函数">3.函数</h2>
<ol>
<li>arguments.callee 该属性是一个指针，指向拥有这个 arguments 对象的函数，可以理解为 arguments.callee 代表当前函数。一般用于递归调用</li>
<li>arguments.callee.caller 保存着当前函数的引用</li>
<li>apply(obj, []) call(obj , x,y,z...)</li>
<li>charAt() 返回指定位置的字符</li>
<li>encodeURIComponent 对 uri 进行编码，浏览器可以识别。 / =&gt; % encodeURI 解码</li>
</ol>
<h2 id="4程序设计">4.程序设计</h2>
<h3 id="1数据属性">1.数据属性</h3>
<p>object.defineProperty() 默认情况下,configurable,enumerable,writable 都为 false<br>
<img src="https://alexwjj.github.io//post-images/1563267201804.png" alt=""></p>
<p><img src="https://alexwjj.github.io//post-images/1563267283128.png" alt=""></p>
<h3 id="2访问器属性">2.访问器属性</h3>
<p><img src="https://alexwjj.github.io//post-images/1563267475597.png" alt=""></p>
<h3 id="3实例-原型-构造函数">3.实例、原型、构造函数</h3>
<p><img src="https://alexwjj.github.io//post-images/1563267661253.png" alt=""></p>
<h3 id="4继承">4.继承</h3>
<p>JavaScript 主要通过原型链实现继承，原型链的构建是讲一个类型的实例赋值给另一个构造函数的原型实现的，寄生组合继承是最理想的方式</p>
<h3 id="5settimeout">5.setTimeOut</h3>
<p><img src="https://alexwjj.github.io//post-images/1563268663074.png" alt=""></p>
<h3 id="6location">6.location</h3>
<p><img src="https://alexwjj.github.io//post-images/1563268758666.png" alt=""></p>
<h3 id="7dom">7.DOM</h3>
<h4 id="1node">1.node</h4>
<p><img src="https://alexwjj.github.io//post-images/1563268989021.png" alt=""></p>
<h4 id="2偏移量">2.偏移量</h4>
<p><img src="https://alexwjj.github.io//post-images/1563269342635.png" alt=""><br>
<img src="https://alexwjj.github.io//post-images/1563269418415.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue Cli 2.0/3.0 环境变量配置]]></title>
        <id>https://alexwjj.github.io//post/vue-cli-2030-huan-jing-bian-liang-pei-zhi</id>
        <link href="https://alexwjj.github.io//post/vue-cli-2030-huan-jing-bian-liang-pei-zhi">
        </link>
        <updated>2019-07-04T02:15:17.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>在公司负责维护两个系统，一个使用的2.0，一个是3.0</p>
<p>在需要根据运行环境判断时，需要对项目做不同的配置</p>
<p>hashaki~ 面对疾风吧！</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>在公司负责维护两个系统，一个使用的2.0，一个是3.0</p>
<p>在需要根据运行环境判断时，需要对项目做不同的配置</p>
<p>hashaki~ 面对疾风吧！</p>
</blockquote>
<!-- more -->
<h1 id="vue-cli-20">Vue Cli 2.0</h1>
<h2 id="配置">配置</h2>
<p><strong>config</strong>目录下的*.env.js可以配置环境变量，编译过程中会自动载入对应模式下的环境变量。<br>
dev.env.js  test.env.js  prod.env.js</p>
<pre><code>// 开发环境,其他类比
var merge = require('webpack-merge');
var prodEnv = require('./prod.env');

module.exports = merge(prodEnv, {
  NODE_ENV: '&quot;development&quot;',
  API_LOCATION: '&quot;/api&quot;',
});
</code></pre>
<h2 id="使用">使用</h2>
<ul>
<li>在js文件或者在vue文件中<strong>process.env.{环境变量名}</strong>，比如上文定义的API_LOCATION，使用process.env.API_LOCATION即可获取环境变量的值。</li>
<li>在html文件中使用环境变量，采用模板引用指令&lt;%= .process.env.{环境变量名} %&gt;，比如</li>
</ul>
<pre><code>&lt;script src=&quot;&lt;%= process.env.API_LOCATION %&gt;&quot;/&gt;
</code></pre>
<h1 id="vue-cli-30">Vue Cli 3.0</h1>
<h2 id="配置与使用">配置与使用</h2>
<p>参考官方文档：<a href="https://cli.vuejs.org/zh/guide/mode-and-env.html#%E6%A8%A1%E5%BC%8F">3.0环境配置</a></p>
<h2 id="目录">目录</h2>
<p><img src="https://alexwjj.github.io//post-images/1562207612677.png" alt=""></p>
<h2 id="配置-2">配置</h2>
<pre><code>NODE_ENV = development
VUE_APP_CURRENTMODE = development
VUE_APP_API_LOCATION = /api
</code></pre>
<h2 id="使用-2">使用</h2>
<pre><code>// 模板文件
process.env.VUE_APP_API_LOCATION

// index.html
&lt;script src=&quot;&lt;%= VUE_APP_API_LOCATION %&gt;&quot;&gt;&lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[去除dispaly：inline-block造成的间距]]></title>
        <id>https://alexwjj.github.io//post/qu-chu-dispalyinline-block-zao-cheng-de-jian-ju</id>
        <link href="https://alexwjj.github.io//post/qu-chu-dispalyinline-block-zao-cheng-de-jian-ju">
        </link>
        <updated>2019-07-03T11:28:50.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>做管理系统，样式很多都是组件统一的</p>
<p>最近写组件的时候，遇到莫名其妙的间距问题</p>
<p>不懂就问，一问就会，哈哈哈。下面总结几种去除 inline-block造成的间距的几种方法</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>做管理系统，样式很多都是组件统一的</p>
<p>最近写组件的时候，遇到莫名其妙的间距问题</p>
<p>不懂就问，一问就会，哈哈哈。下面总结几种去除 inline-block造成的间距的几种方法</p>
</blockquote>
<!-- more -->
<h2 id="问题源泉">问题源泉</h2>
<p><img src="https://alexwjj.github.io//post-images/1562154263184.png" alt=""></p>
<p>一个小小的间距，用 chrome 检查元素发现不了问题，困扰了几天( 遇到的问题，不是很紧急的，我不会立刻去问大佬，先带着问题做其他的事情，没事多思考，想到解决方案就试试，没办法的时候找机会问大佬。这样可能会浪费点时间，但是我觉得可以提升自己思考问题及提出解决方案的能力，自己通过这种方式也确实解决了很多问题，逐渐成为一个 dalao，尽量少的依赖别人去解决问题。）</p>
<h2 id="间距现象">间距现象</h2>
<pre><code>&lt;style&gt;
  p {
    display: inline-block;
  }
&lt;/style&gt;
&lt;body&gt;
    &lt;div&gt;
        &lt;p&gt;间距测试前&lt;/p&gt;
        &lt;p&gt;间距测试后&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p><img src="https://alexwjj.github.io//post-images/1562155907938.png" alt=""></p>
<h2 id="1最简单的解决方案">1.最简单的解决方案</h2>
<p>这种现象，实际上是因为有一个换行符导致</p>
<pre><code>    &lt;div&gt;
        &lt;p&gt;间距测试前&lt;/p&gt;&lt;p&gt;间距测试后&lt;/p&gt;
    &lt;/div&gt;
</code></pre>
<p><img src="https://alexwjj.github.io//post-images/1562154864755.png" alt=""></p>
<h2 id="2去除闭合标签">2.去除闭合标签</h2>
<pre><code>    &lt;div&gt;
        &lt;p&gt;间距测试前
        &lt;p&gt;间距测试后
    &lt;/div&gt;
</code></pre>
<h2 id="3font-size0">3.font-size:0</h2>
<pre><code>&lt;style&gt;
  p {
    display: inline-block;
    font-size: 16px;
  }
&lt;/style&gt;
&lt;body&gt;
    &lt;div style=&quot;font-size: 0&quot;&gt;
        &lt;p&gt;间距测试前&lt;/p&gt;
        &lt;p&gt;间距测试后&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<h2 id="4letter-spacing-0-word-spacing0">4.letter-spacing: 0 ，word-spacing：0</h2>
<p>不准确，不推荐使用</p>
<pre><code>&lt;style&gt;
  p {
    display: inline-block;
    letter-spacing: 0;
  }
&lt;/style&gt;
&lt;body&gt;
    &lt;div style=&quot;letter-spacing: -5px&quot;&gt;
        &lt;p&gt;间距测试前&lt;/p&gt;
        &lt;p&gt;间距测试后&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<h2 id="小结">小结</h2>
<p>调整代码不换行是<strong>最简单的方式</strong>，其次是设置 **font-size：0  **</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue --- provide/inject]]></title>
        <id>https://alexwjj.github.io//post/vue-provideinject</id>
        <link href="https://alexwjj.github.io//post/vue-provideinject">
        </link>
        <updated>2019-06-28T10:27:16.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>vue2.2新增api，用于跨组件通信</p>
<p>目前还没写过，但是看项目里面几个大佬在用。学习学习</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>vue2.2新增api，用于跨组件通信</p>
<p>目前还没写过，但是看项目里面几个大佬在用。学习学习</p>
</blockquote>
<!-- more -->
<h2 id="1定义">1.定义</h2>
<p>Vue2.2.0新增API,provide和inject需要一起使用，以允许一个<strong>祖先组件</strong>向其所有<strong>子孙后代</strong>注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里<strong>始终生效</strong>。一言而蔽之：祖先组件中通过<strong>provider来提供变量</strong>，然后在<strong>子孙组件中通过inject来注入变量</strong>。</p>
<p>provide / inject API 主要解决了<strong>跨级组件间的通信问题</strong>，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p>
<h2 id="2demo">2.demo</h2>
<p>A.vue 和 B.vue，B 是 A 的子组件</p>
<pre><code>// A.vue
export default {
  provide: {
    name: '俊劫'
  }
}
</code></pre>
<pre><code>// B.vue
export default {
  inject: ['name'],
  mounted () {
    console.log(this.name);  // 俊劫
  }
}
</code></pre>
<p>provide 和 inject 绑定<strong>并不是可响应的</strong>。这是刻意为之的。但是，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。所以，上面 A.vue 的 name 如果改变了，B.vue 的 this.name 是不会改变的。</p>
<h2 id="ref-组件通信">ref 组件通信</h2>
<p>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</p>
<p>$parent / $children：访问父 / 子实例</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue --- Virtual Dom]]></title>
        <id>https://alexwjj.github.io//post/vue-virtual-dom</id>
        <link href="https://alexwjj.github.io//post/vue-virtual-dom">
        </link>
        <updated>2019-06-28T09:17:12.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>Virtual Dom是什么，这个问题在面试中会经常问到</p>
<p>但是实际开发中并不会直接去接触到Virtual Dom</p>
<p>之前对于Virtual Dom的理解都是背的，这次来深层探究下。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>Virtual Dom是什么，这个问题在面试中会经常问到</p>
<p>但是实际开发中并不会直接去接触到Virtual Dom</p>
<p>之前对于Virtual Dom的理解都是背的，这次来深层探究下。</p>
</blockquote>
<!-- more -->
<h2 id="vue模板转换成视图的过程">vue模板转换成视图的过程</h2>
<ul>
<li>Vue.js通过编译将<strong>template 模板</strong>转换成渲染函数(render ) ，执行渲染函数就可以得到一个虚拟节点树</li>
<li>在对 Model 进行操作的时候，会触发对应 Dep 中的 Watcher 对象。Watcher 对象会调用对应的 update 来修改视图。这个过程主要是将<strong>新旧虚拟节点</strong>进行<strong>差异对比</strong>，然后根据对比结果进行DOM操作来更新视图。<br>
<img src="https://alexwjj.github.io//post-images/1561713907738.png" alt=""><br>
<img src="https://alexwjj.github.io//post-images/1561715602464.png" alt=""></li>
</ul>
<h2 id="virtual-dom">Virtual DOM</h2>
<h3 id="1定义">1.定义</h3>
<p>Virtual DOM 其实就是一棵以 JavaScript 对象( VNode 节点)作为基础的树，用<strong>对象属性来描述节点</strong>，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。</p>
<p>简单来说，可以把Virtual DOM 理解为一个<strong>简单的JS对象</strong>，并且最少包含标签名( tag)、属性(attrs)和子元素对象( children)三个属性。</p>
<h3 id="模板-渲染函数-虚拟dom树-真实dom">模板 → 渲染函数 → 虚拟DOM树 → 真实DOM</h3>
<p><img src="https://alexwjj.github.io//post-images/1561714145195.png" alt=""></p>
<h3 id="2作用">2.作用</h3>
<p>虚拟DOM的最终目标是将<strong>虚拟节点渲染到视图上</strong>。但是如果直接使用虚拟节点覆盖旧节点的话，会有很多不必要的DOM操作。例如，一个ul标签下很多个li标签，其中只有一个li有变化，这种情况下如果使用新的ul去替代旧的ul,因为这些不必要的DOM操作而造成了性能上的浪费。</p>
<p>为了避免不必要的DOM操作，虚拟DOM在虚拟节点映射到视图的过程中，将虚拟节点与上一次渲染视图所使用的旧虚拟节点（oldVnode）做对比，找出<strong>真正需要更新的节点</strong>来进行DOM操作，从而避免操作其他无需改动的DOM。</p>
<ul>
<li>提供与真实DOM节点所对应的<strong>虚拟节点vnode</strong></li>
<li>将虚拟节点vnode和旧虚拟节点<strong>oldVnode</strong>进行对比，然后更新视图</li>
<li>运用<strong>patching算法</strong>来计算出真正需要更新的节点</li>
<li>类比 CPU、硬盘中加入内存条</li>
</ul>
<h3 id="3diff算法">3.diff算法</h3>
<p>Vue的diff算法是基于snabbdom改造过来的，仅在<strong>同级的vnode间做diff</strong>，<strong>递归</strong>地进行同级vnode的diff，最终实现整个DOM树的更新。因为跨层级的操作是非常少的，忽略不计，这样时间复杂度就从<strong>O(n3)变成O(n)</strong>。</p>
<h4 id="diff-算法包括几个步骤">diff 算法包括几个步骤：</h4>
<ul>
<li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中</li>
<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li>
<li>把<strong>所记录的差异</strong>应用到所构建的真正的DOM树上，视图就更新了<br>
<img src="https://alexwjj.github.io//post-images/1561715188395.png" alt=""></li>
</ul>
<p>diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁：</p>
<ul>
<li>patch(container,vnode)  :初次渲染的时候，将Virtual Dom渲染成真正的DOM然后插入到容器里面。</li>
<li>patch(vnode,newVnode):再次渲染的时候，将新的vnode和旧的vnode相对比，然后之间差异应用到所构建的真正的DOM树上。</li>
<li>如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。两个children的比较是使用双向链表，<strong>边patch边操作dom</strong>。<br>
<img src="https://alexwjj.github.io//post-images/1561715535206.png" alt=""></li>
</ul>
<h4 id="diff-缺点">diff 缺点</h4>
<p>虽然这两个节点不一样但是他们的<strong>子节点一样怎么办</strong>？别忘了，diff可是逐层比较的，如果第一层不一样那么就不会继续深入比较第二层了。（我在想这算是一个缺点吗？<strong>相同子节点不能重复利用了</strong>...）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Vue ---  computed vs watch]]></title>
        <id>https://alexwjj.github.io//post/tan-jiu-vue-ji-suan-shu-xing-computed-he-zhen-ting-shu-xing-watch</id>
        <link href="https://alexwjj.github.io//post/tan-jiu-vue-ji-suan-shu-xing-computed-he-zhen-ting-shu-xing-watch">
        </link>
        <updated>2019-06-28T01:46:26.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>初学 vue 的时候就分不清computed和 watch 的区别</p>
<p>在写了一段时间的业务逻辑后，对两者有了一些认识。</p>
<p>结合各位大佬的分析，自己总结了一下。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>初学 vue 的时候就分不清computed和 watch 的区别</p>
<p>在写了一段时间的业务逻辑后，对两者有了一些认识。</p>
<p>结合各位大佬的分析，自己总结了一下。</p>
</blockquote>
<!-- more -->
<h1 id="计算属性-computed">计算属性 computed</h1>
<h2 id="1computed">1.computed</h2>
<p>计算属性是自动监听<strong>依赖值</strong>的变化，从而动态返回内容，监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些事情。它有以下几个特点：</p>
<ul>
<li>数据可以进行逻辑处理，<strong>减少模板中计算逻辑</strong>。</li>
<li>对计算属性中的数据进行监视</li>
<li>依赖固定的数据类型（响应式数据）</li>
</ul>
<p>计算属性由两部分组成：get和set，分别用来获取计算属性和设置计算属性。<strong>默认只有get</strong>，如果需要set，要自己添加。另外set设置属性，并不是直接修改计算属性，而是修改它的依赖。</p>
<pre><code>computed: {
  fullName: {
    // getter
    get: function () {
      return this.nickName + '-' + this.trueName
    },
    // setter
    set: function (newValue) {
      //this.fullName = newValue 这种写法会报错
      var names = newValue.split('-')
      this.nickName = names[0]//对它的依赖进行赋值
      this.trueName = names[names.length - 1]
    }
  }
}
</code></pre>
<p>现在再运行 vm.fullName = 'alex wjj' 时，setter 会被调用，vm.nickName 和 vm.trueName 也会相应地被更新。</p>
<h2 id="2computed-vs-methods">2.computed   vs  methods</h2>
<p>两者最主要的区别：computed 是可以<strong>缓存的</strong>，methods 不能缓存；</p>
<p>只要<strong>相关依赖</strong>没有改变，多次访问计算属性得到的值是之前缓存的计算结果，不会多次执行。</p>
<p>网上有种说法就是方法可以传参，而计算属性不能，其实并不准确，<strong>计算属性可以通过闭包来实现传参</strong>：</p>
<pre><code>:data=&quot;closure(item, itemName, blablaParams)&quot;
computed: {
 closure () {
   return function (a, b, c) {
        /** do something */
        return data
    }
 }
}

</code></pre>
<h1 id="侦听属性-watch">侦听属性 watch</h1>
<h2 id="1watch">1.watch</h2>
<p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性watch</p>
<h2 id="2使用-watch-的深度遍历deep和立即调用功能immediate">2.使用 watch 的深度遍历deep和立即调用功能immediate</h2>
<p>使用 watch 来监听数据变化的时候除了常用到 <strong>handler 回调</strong>，其实其还有两个参数，便是：</p>
<ul>
<li>deep 设置为 true 用于监听对象内部值的变化</li>
<li>immediate 设置为 true 将立即以表达式的当前值触发回调</li>
</ul>
<pre><code>&lt;template&gt;
    &lt;button @click=&quot;obj.a = 2&quot;&gt;修改&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    data() {
        return {
            obj: {
                a: 1,
            }
        }
    },
    watch: {
        obj: {
            handler: function(newVal, oldVal) {
                console.log(newVal); 
            },
            deep: true,
            immediate: true 
        }
    }
}
&lt;/script&gt;

</code></pre>
<p>以上代码修改了 obj 对象中 a 属性的值，可以触发其 watch 中的 handler 回调输出新的对象，而如果不加 deep: true，我们只能监听 obj 的改变，并不会触发回调。同时我们也添加了 immediate: true 配置，其会立即以 obj 的当前值触发回调。</p>
<pre><code>watch: {
    searchInputValue:{
        handler: 'fetchPostList',
        immediate: true
    }
}
// 声明immediate:true表示创建组件时立马执行一次。
</code></pre>
<h1 id="computed-vs-watch">computed vs watch</h1>
<p><img src="https://alexwjj.github.io//post-images/1561690381163.png" alt=""></p>
<p>流程图中，我们可以看出它们之间的区别：</p>
<ul>
<li>watch：监测的是<strong>属性值</strong>， 只要属性值发生变化，其都会触发执行回调函数来执行一系列操作。</li>
<li>computed：监测的是<strong>依赖值</strong>，依赖值不变的情况下其会直接读取缓存进行复用，变化的情况下才会重新计算。</li>
</ul>
<p>除此之外，有点很重要的区别是：计算属性不能执行异步任务，计算属性必须同步执行。也就是说计算属性不能向服务器请求或者执行异步任务。如果遇到异步任务，就交给侦听属性。watch也可以检测computed属性。</p>
<h1 id="小结">小结</h1>
<p>计算属性适合用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。</p>
<ul>
<li>computed能做的，watch都能做，反之则不行</li>
<li>能用computed的尽量用computed</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[var _this = this  的含义]]></title>
        <id>https://alexwjj.github.io//post/wei-sha-yao-var-_this-this</id>
        <link href="https://alexwjj.github.io//post/wei-sha-yao-var-_this-this">
        </link>
        <updated>2019-06-24T09:19:42.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>开发过程中，看到项目中会在顶层写一个这样的表达式</p>
<p>const  _this=this</p>
<p>下面来解释一下</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>开发过程中，看到项目中会在顶层写一个这样的表达式</p>
<p>const  _this=this</p>
<p>下面来解释一下</p>
</blockquote>
<!-- more -->
<h3 id="jquery-一个典型的列子">jquery 一个典型的列子</h3>
<pre><code>$(&quot;#btn&quot;).click(function(){
    var _this = this;//这里this和_this都代表了&quot;#btn&quot;这个对象
    $(&quot;.tr&quot;).each(function(){
          this;//在这里this代表的是每个遍历到的&quot;.tr&quot;对象
          _this;//仍代表&quot;#btn&quot;对象
    })
})
</code></pre>
<p>在一个代码片段里this有可能代表不同的对象,而编码者希望_this代表<strong>最初的对象</strong>。JS可以嵌套多层代码，可能下面还可以再嵌一个方法，引用this就会变成<strong>子方法控制的对象</strong>。如果需要<strong>上级的对象</strong>，在没有参数的情况下，前提做了一个临时变量_this，可以保存<strong>上级对象</strong>，子方<br>
法中就可以用_this来调用了，这才是目的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[v-for :key 的使用]]></title>
        <id>https://alexwjj.github.io//post/v-for-key-de-shi-yong</id>
        <link href="https://alexwjj.github.io//post/v-for-key-de-shi-yong">
        </link>
        <updated>2019-06-20T13:29:42.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>在 vue 项目中，大量使用了v-for 来遍历我们的数组。</p>
<p>:key 是vue 必须要求的，也是 vue 虚拟 DOM的 Diff 算法的依赖</p>
<p>最近在项目中遇到数据篡改的问题，记录下</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>在 vue 项目中，大量使用了v-for 来遍历我们的数组。</p>
<p>:key 是vue 必须要求的，也是 vue 虚拟 DOM的 Diff 算法的依赖</p>
<p>最近在项目中遇到数据篡改的问题，记录下</p>
</blockquote>
<!-- more -->
<h2 id="v-for">v-for</h2>
<p>使用<strong>v-for</strong>更新已渲染的元素列表时,默认用<strong>就地复用</strong>策略;列表数据修改的时候,vue会根据key值去<br>
判断某个值是否修改,如果修改,则重新渲染这一项,否则复用之前的元素;我们在使用的使用经常会使用index(即数组的下标)来作为key,但是我们要谨慎在项目中使用 index 来作为 key。</p>
<h2 id="key">:key</h2>
<p>最好的办法是使用数组中互不相同的一个属性作为key值,对应到项目中,即每条数据都有一个<strong>唯一的id</strong>,来标识这条数据的唯一性;使用id作为key值,旧值就不会重新渲染。同理在react中使用map渲染列表时,也是必须加key,且推荐做法也是使用id。</p>
<h2 id="virtual-dom-diff">Virtual DOM --- diff</h2>
<p>vue和react的虚拟DOM的Diff算法大致相同，其核心是基于两个简单的假设：</p>
<ul>
<li>两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构。</li>
<li></li>
<li>同一层级的一组节点，他们可以通过唯一的id进行区分。基于以上这两点假设，使得虚拟DOM的Diff算法<br>
的复杂度从O(n^3)降到了O(n)。</li>
</ul>
<p><strong>key的作用主要是为了高效的更新虚拟DOM</strong></p>
<h2 id="问题描述">问题描述</h2>
<p>项目中使用了 element-ui 的 time-picker 组件，绑定了数据之后，通过修改 time-picker 来修改时间。开发过程中，没有充分测试，并没有发现问题。测试提交过来，发现重新生成的时间，聚焦的时候会自动修改为上一次加载的值。</p>
<p>问题很奇怪，各种定位问题，因为页面是一年以前，一个离职的同事写的。多层数组循环嵌套，由于我们使用的 vue 版本是2.X，object.defineProperty无法监测通过数组下标访问的数据。这也导致我找问题一直在这方面寻找。</p>
<p>找了快一周了，项目要上线了。硬着头皮去找我组长了，大佬就是大佬，排查问题的方式以及思考的路子都是我要学习的地方。找了一晚上，也没注意到 key的问题。但是大佬和我不同的是，他们定位不到问题的时候会去想办法重写一个 demo，重现问题。而我的缺点是会一直卡在一个问题上，懒或者没有勇气去重写一个例子。</p>
<h2 id="后续">后续</h2>
<ol>
<li>遇到问题解决不了及时问大佬</li>
<li>学会重现问题根本原因，学会定位问题</li>
<li>谨慎使用 index 作为 key 值</li>
<li>去研究 vue api的实现原理，关注其优缺点。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Object.defineProperty   对比  Proxy]]></title>
        <id>https://alexwjj.github.io//post/objectdefineproperty-dui-bi-proxy</id>
        <link href="https://alexwjj.github.io//post/objectdefineproperty-dui-bi-proxy">
        </link>
        <updated>2019-06-14T02:40:29.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>使用 vue2.x的版本项目,双向绑定原理还是Object.defineProperty</p>
<p>导致在实际的开发过程中，有些属性的修改，双向绑定不会生效</p>
<p>所以，来好好探究下Object.defineProperty   和 vue3.0中的 Proxy</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>使用 vue2.x的版本项目,双向绑定原理还是Object.defineProperty</p>
<p>导致在实际的开发过程中，有些属性的修改，双向绑定不会生效</p>
<p>所以，来好好探究下Object.defineProperty   和 vue3.0中的 Proxy</p>
</blockquote>
<!-- more -->
<h2 id="objectdefineproperty">Object.defineProperty()</h2>
<p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p>
<p>Object.defineProperty(obj, prop, descriptor)</p>
<pre><code>* obj
* 要在其上定义属性的对象。
* prop
* 要定义或修改的属性的名称。
* descriptor
* 将被定义或修改的属性描述符。
</code></pre>
<p>具体形象生动的解释可参考这篇文章<a href="https://www.jianshu.com/p/6519575e055f">Object.defineProperty() 不详解</a></p>
<h2 id="注意-get-set">注意 get 、set</h2>
<p>在项目中遇到的问题就是，使用 vue 的双向数据绑定，在表单新增页面没问题，但是在修改的时候，v-model 绑定的属性没法被 set 赋值过来，很奇怪。想了大概两三天，没想明白，后来大佬来看了一下我v-mode 的数据类型，多层数组嵌套，通过下标的形式进行访问修改。vue2.x 使用Object.defineProperty 的存在很多限制：<strong>无法监听 属性的添加和删除、数组索引和长度的变更</strong>，直接通过数组的下标给数组设置值，不能实时响应，是因为Object.defineProperty()无法监控到数组下标的变化，后来使用了 JSON.parse(JSON.stringify())进行了一次深拷贝才解决，也可以使用 lodash 的 cloneDeep。</p>
<h2 id="使用-objectdefineproperty手动实现一个双向绑定">使用 object.defineProperty手动实现一个双向绑定</h2>
<p>主要是监听input change 事件或者键盘 keyup 事件，通过 object.defineProperty 设置 set 属性进行对象属性的 修改。</p>
<p>参考博客（这老哥的博客很生动）：<a href="https://www.jianshu.com/p/251235dd04c8">用Object.defineProperty手写一个简单的双向绑定</a></p>
<h2 id="proxy">Proxy</h2>
<p>Proxy可以理解成，在目标对象之前架设一层 &quot;拦截&quot;，当外界对该对象访问的时候，都必须经过这层拦截，而Proxy就充当了这种机制，类似于代理的含义，它可以对外界访问对象之前进行过滤和改写该对象。</p>
<p>Proxy基本语法 :const obj = new Proxy(target, handler);</p>
<p>参数说明如下：</p>
<pre><code>* target: 被代理对象。
* handler: 是一个对象，声明了代理target的一些操作。
* obj: 是被代理完成之后返回的对象。
</code></pre>
<p>但是当外界每次对obj进行操作时，就会执行handler对象上的一些方法。handler中常用的对象方法如下：</p>
<pre><code>1. get(target, propKey, receiver)
2. set(target, propKey, value, receiver)
3. has(target, propKey)
4. construct(target, args):
5. apply(target, object, args)
</code></pre>
<p><a href="https://segmentfault.com/a/1190000018574665">proxy 和 object.defineProperty实现双向绑定对比</a></p>
]]></content>
    </entry>
</feed>