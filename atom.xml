<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://alexwjj.github.io/</id>
    <title>俊劫、的前端博客</title>
    <updated>2019-07-16T11:22:23.495Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://alexwjj.github.io/"/>
    <link rel="self" href="https://alexwjj.github.io//atom.xml"/>
    <subtitle>讲个笑话，你可别哭。</subtitle>
    <logo>https://alexwjj.github.io//images/avatar.png</logo>
    <icon>https://alexwjj.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 俊劫、的前端博客</rights>
    <entry>
        <title type="html"><![CDATA[JavaScript 高级程序设计 笔记]]></title>
        <id>https://alexwjj.github.io//post/javascript-gao-ji-cheng-xu-she-ji-bi-ji</id>
        <link href="https://alexwjj.github.io//post/javascript-gao-ji-cheng-xu-she-ji-bi-ji">
        </link>
        <updated>2019-07-05T08:33:48.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>利用工作空闲之余，阅读 这本红宝书</p>
<p>收获很多，前端必读</p>
<p>记录一下自己觉得比较重要的点</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>利用工作空闲之余，阅读 这本红宝书</p>
<p>收获很多，前端必读</p>
<p>记录一下自己觉得比较重要的点</p>
</blockquote>
<!-- more -->
<h2 id="1注意点">1.注意点</h2>
<ol>
<li>创造一个<code>&lt;noscript&gt;</code>元素，用以在浏览器不支持 JavaScript 的浏览器显示替代的内容。比如：浏览器不支持，脚本功能被禁用。</li>
<li>省略 var 操作符，相当于声明了一个全局变量。  a = [1,2]</li>
<li>null 表示一个空对象指针。null === undefined // false  == // true 双等号会进行强制类型转换</li>
<li>0.1 + 0.2 === 0.3 // false IEEE754数值浮点计算通病</li>
<li>通过 addEventListener() 添加的事件只能用 removeEventListener清除</li>
<li>JSON 数据格式中对象属性 必须 加双引号</li>
</ol>
<h2 id="2基本知识点">2.基本知识点</h2>
<ol>
<li>保存浮点数需要的内存空间是整数的两倍</li>
<li>e 表示法：数值等于 e 前面的数值乘以10的指数次幂，eg：3.125e7 = 31250000。 负值：0.003 = 3e - 3</li>
<li>任何数值乘以 0 会返回 NaN.  NaN == NaN // false   isNaN() 函数</li>
<li><code>Number()</code>接受任何参数，转换规则：0false1true ,null &gt; 0, undefined &gt; NaN, '011' &gt; 11, 0xf &gt; 15 , '' &gt; 0</li>
<li>parseInt() 挨个解析，遇到非数字返回 '123blue' &gt; 123;  22.5 &gt; 22 ; '' &gt; NaN; '070' &gt; 56(八进制）；parseInt 第二个参数表示转换的基数，默认十进制；<br>
<code>[12,3].map(i =&gt; parseInt(i)) [1,NaN,NaN]</code></li>
<li>toString(n) n 表示输出数值的基数</li>
<li>逻辑与（&amp;&amp;） 进行的是短路操作。第一个为 false，后面的不会执行</li>
<li>arguments一种类数组对象 代表函数的参数，可以通过 arguments[0]访问函数第一个参数，没有则是 undefined；通过判断传入参数的类型和数量，模仿方法的重载。</li>
<li>作用域链本质上是一个指向变量对象的指针列表</li>
<li>单例（singleton） 指的是只有一个实例的对象</li>
<li>addHandler（element, event, function)   添加事件</li>
<li>postMessage（发送的消息，接收方域名）</li>
<li>JSON.stringify(obj, 过滤器、函数、数组， 是否保留缩进）</li>
<li></li>
</ol>
<h2 id="3函数">3.函数</h2>
<ol>
<li>arguments.callee 该属性是一个指针，指向拥有这个 arguments 对象的函数，可以理解为 arguments.callee 代表当前函数。一般用于递归调用</li>
<li>arguments.callee.caller 保存着当前函数的引用</li>
<li>apply(obj, []) call(obj , x,y,z...)</li>
<li>charAt() 返回指定位置的字符</li>
<li>encodeURIComponent 对 uri 进行编码，浏览器可以识别。 / =&gt; % encodeURI 解码</li>
</ol>
<h2 id="4程序设计">4.程序设计</h2>
<h3 id="1数据属性">1.数据属性</h3>
<p>object.defineProperty() 默认情况下,configurable,enumerable,writable 都为 false<br>
<img src="https://alexwjj.github.io//post-images/1563267201804.png" alt=""></p>
<p><img src="https://alexwjj.github.io//post-images/1563267283128.png" alt=""></p>
<h3 id="2访问器属性">2.访问器属性</h3>
<p><img src="https://alexwjj.github.io//post-images/1563267475597.png" alt=""></p>
<h3 id="3实例-原型-构造函数">3.实例、原型、构造函数</h3>
<p><img src="https://alexwjj.github.io//post-images/1563267661253.png" alt=""></p>
<h3 id="4继承">4.继承</h3>
<p>JavaScript 主要通过原型链实现继承，原型链的构建是讲一个类型的实例赋值给另一个构造函数的原型实现的，寄生组合继承是最理想的方式</p>
<h3 id="5settimeout">5.setTimeOut</h3>
<p><img src="https://alexwjj.github.io//post-images/1563268663074.png" alt=""></p>
<h3 id="6location">6.location</h3>
<p><img src="https://alexwjj.github.io//post-images/1563268758666.png" alt=""></p>
<h3 id="7dom">7.DOM</h3>
<h4 id="1node">1.node</h4>
<p><img src="https://alexwjj.github.io//post-images/1563268989021.png" alt=""></p>
<h4 id="2偏移量">2.偏移量</h4>
<p><img src="https://alexwjj.github.io//post-images/1563269342635.png" alt=""><br>
<img src="https://alexwjj.github.io//post-images/1563269418415.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue Cli 2.0/3.0 环境变量配置]]></title>
        <id>https://alexwjj.github.io//post/vue-cli-2030-huan-jing-bian-liang-pei-zhi</id>
        <link href="https://alexwjj.github.io//post/vue-cli-2030-huan-jing-bian-liang-pei-zhi">
        </link>
        <updated>2019-07-04T02:15:17.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>在公司负责维护两个系统，一个使用的2.0，一个是3.0</p>
<p>在需要根据运行环境判断时，需要对项目做不同的配置</p>
<p>hashaki~ 面对疾风吧！</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>在公司负责维护两个系统，一个使用的2.0，一个是3.0</p>
<p>在需要根据运行环境判断时，需要对项目做不同的配置</p>
<p>hashaki~ 面对疾风吧！</p>
</blockquote>
<!-- more -->
<h1 id="vue-cli-20">Vue Cli 2.0</h1>
<h2 id="配置">配置</h2>
<p><strong>config</strong>目录下的*.env.js可以配置环境变量，编译过程中会自动载入对应模式下的环境变量。<br>
dev.env.js  test.env.js  prod.env.js</p>
<pre><code>// 开发环境,其他类比
var merge = require('webpack-merge');
var prodEnv = require('./prod.env');

module.exports = merge(prodEnv, {
  NODE_ENV: '&quot;development&quot;',
  API_LOCATION: '&quot;/api&quot;',
});
</code></pre>
<h2 id="使用">使用</h2>
<ul>
<li>在js文件或者在vue文件中<strong>process.env.{环境变量名}</strong>，比如上文定义的API_LOCATION，使用process.env.API_LOCATION即可获取环境变量的值。</li>
<li>在html文件中使用环境变量，采用模板引用指令&lt;%= .process.env.{环境变量名} %&gt;，比如</li>
</ul>
<pre><code>&lt;script src=&quot;&lt;%= process.env.API_LOCATION %&gt;&quot;/&gt;
</code></pre>
<h1 id="vue-cli-30">Vue Cli 3.0</h1>
<h2 id="配置与使用">配置与使用</h2>
<p>参考官方文档：<a href="https://cli.vuejs.org/zh/guide/mode-and-env.html#%E6%A8%A1%E5%BC%8F">3.0环境配置</a></p>
<h2 id="目录">目录</h2>
<p><img src="https://alexwjj.github.io//post-images/1562207612677.png" alt=""></p>
<h2 id="配置-2">配置</h2>
<pre><code>NODE_ENV = development
VUE_APP_CURRENTMODE = development
VUE_APP_API_LOCATION = /api
</code></pre>
<h2 id="使用-2">使用</h2>
<pre><code>// 模板文件
process.env.VUE_APP_API_LOCATION

// index.html
&lt;script src=&quot;&lt;%= VUE_APP_API_LOCATION %&gt;&quot;&gt;&lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[去除dispaly：inline-block造成的间距]]></title>
        <id>https://alexwjj.github.io//post/qu-chu-dispalyinline-block-zao-cheng-de-jian-ju</id>
        <link href="https://alexwjj.github.io//post/qu-chu-dispalyinline-block-zao-cheng-de-jian-ju">
        </link>
        <updated>2019-07-03T11:28:50.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>做管理系统，样式很多都是组件统一的</p>
<p>最近写组件的时候，遇到莫名其妙的间距问题</p>
<p>不懂就问，一问就会，哈哈哈。下面总结几种去除 inline-block造成的间距的几种方法</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>做管理系统，样式很多都是组件统一的</p>
<p>最近写组件的时候，遇到莫名其妙的间距问题</p>
<p>不懂就问，一问就会，哈哈哈。下面总结几种去除 inline-block造成的间距的几种方法</p>
</blockquote>
<!-- more -->
<h2 id="问题源泉">问题源泉</h2>
<p><img src="https://alexwjj.github.io//post-images/1562154263184.png" alt=""></p>
<p>一个小小的间距，用 chrome 检查元素发现不了问题，困扰了几天( 遇到的问题，不是很紧急的，我不会立刻去问大佬，先带着问题做其他的事情，没事多思考，想到解决方案就试试，没办法的时候找机会问大佬。这样可能会浪费点时间，但是我觉得可以提升自己思考问题及提出解决方案的能力，自己通过这种方式也确实解决了很多问题，逐渐成为一个 dalao，尽量少的依赖别人去解决问题。）</p>
<h2 id="间距现象">间距现象</h2>
<pre><code>&lt;style&gt;
  p {
    display: inline-block;
  }
&lt;/style&gt;
&lt;body&gt;
    &lt;div&gt;
        &lt;p&gt;间距测试前&lt;/p&gt;
        &lt;p&gt;间距测试后&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p><img src="https://alexwjj.github.io//post-images/1562155907938.png" alt=""></p>
<h2 id="1最简单的解决方案">1.最简单的解决方案</h2>
<p>这种现象，实际上是因为有一个换行符导致</p>
<pre><code>    &lt;div&gt;
        &lt;p&gt;间距测试前&lt;/p&gt;&lt;p&gt;间距测试后&lt;/p&gt;
    &lt;/div&gt;
</code></pre>
<p><img src="https://alexwjj.github.io//post-images/1562154864755.png" alt=""></p>
<h2 id="2去除闭合标签">2.去除闭合标签</h2>
<pre><code>    &lt;div&gt;
        &lt;p&gt;间距测试前
        &lt;p&gt;间距测试后
    &lt;/div&gt;
</code></pre>
<h2 id="3font-size0">3.font-size:0</h2>
<pre><code>&lt;style&gt;
  p {
    display: inline-block;
    font-size: 16px;
  }
&lt;/style&gt;
&lt;body&gt;
    &lt;div style=&quot;font-size: 0&quot;&gt;
        &lt;p&gt;间距测试前&lt;/p&gt;
        &lt;p&gt;间距测试后&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<h2 id="4letter-spacing-0-word-spacing0">4.letter-spacing: 0 ，word-spacing：0</h2>
<p>不准确，不推荐使用</p>
<pre><code>&lt;style&gt;
  p {
    display: inline-block;
    letter-spacing: 0;
  }
&lt;/style&gt;
&lt;body&gt;
    &lt;div style=&quot;letter-spacing: -5px&quot;&gt;
        &lt;p&gt;间距测试前&lt;/p&gt;
        &lt;p&gt;间距测试后&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<h2 id="小结">小结</h2>
<p>调整代码不换行是<strong>最简单的方式</strong>，其次是设置 **font-size：0  **</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue --- provide/inject]]></title>
        <id>https://alexwjj.github.io//post/vue-provideinject</id>
        <link href="https://alexwjj.github.io//post/vue-provideinject">
        </link>
        <updated>2019-06-28T10:27:16.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>vue2.2新增api，用于跨组件通信</p>
<p>目前还没写过，但是看项目里面几个大佬在用。学习学习</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>vue2.2新增api，用于跨组件通信</p>
<p>目前还没写过，但是看项目里面几个大佬在用。学习学习</p>
</blockquote>
<!-- more -->
<h2 id="1定义">1.定义</h2>
<p>Vue2.2.0新增API,provide和inject需要一起使用，以允许一个<strong>祖先组件</strong>向其所有<strong>子孙后代</strong>注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里<strong>始终生效</strong>。一言而蔽之：祖先组件中通过<strong>provider来提供变量</strong>，然后在<strong>子孙组件中通过inject来注入变量</strong>。</p>
<p>provide / inject API 主要解决了<strong>跨级组件间的通信问题</strong>，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p>
<h2 id="2demo">2.demo</h2>
<p>A.vue 和 B.vue，B 是 A 的子组件</p>
<pre><code>// A.vue
export default {
  provide: {
    name: '俊劫'
  }
}
</code></pre>
<pre><code>// B.vue
export default {
  inject: ['name'],
  mounted () {
    console.log(this.name);  // 俊劫
  }
}
</code></pre>
<p>provide 和 inject 绑定<strong>并不是可响应的</strong>。这是刻意为之的。但是，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。所以，上面 A.vue 的 name 如果改变了，B.vue 的 this.name 是不会改变的。</p>
<h2 id="ref-组件通信">ref 组件通信</h2>
<p>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</p>
<p>$parent / $children：访问父 / 子实例</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue --- Virtual Dom]]></title>
        <id>https://alexwjj.github.io//post/vue-virtual-dom</id>
        <link href="https://alexwjj.github.io//post/vue-virtual-dom">
        </link>
        <updated>2019-06-28T09:17:12.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>Virtual Dom是什么，这个问题在面试中会经常问到</p>
<p>但是实际开发中并不会直接去接触到Virtual Dom</p>
<p>之前对于Virtual Dom的理解都是背的，这次来深层探究下。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>Virtual Dom是什么，这个问题在面试中会经常问到</p>
<p>但是实际开发中并不会直接去接触到Virtual Dom</p>
<p>之前对于Virtual Dom的理解都是背的，这次来深层探究下。</p>
</blockquote>
<!-- more -->
<h2 id="vue模板转换成视图的过程">vue模板转换成视图的过程</h2>
<ul>
<li>Vue.js通过编译将<strong>template 模板</strong>转换成渲染函数(render ) ，执行渲染函数就可以得到一个虚拟节点树</li>
<li>在对 Model 进行操作的时候，会触发对应 Dep 中的 Watcher 对象。Watcher 对象会调用对应的 update 来修改视图。这个过程主要是将<strong>新旧虚拟节点</strong>进行<strong>差异对比</strong>，然后根据对比结果进行DOM操作来更新视图。<br>
<img src="https://alexwjj.github.io//post-images/1561713907738.png" alt=""><br>
<img src="https://alexwjj.github.io//post-images/1561715602464.png" alt=""></li>
</ul>
<h2 id="virtual-dom">Virtual DOM</h2>
<h3 id="1定义">1.定义</h3>
<p>Virtual DOM 其实就是一棵以 JavaScript 对象( VNode 节点)作为基础的树，用<strong>对象属性来描述节点</strong>，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。</p>
<p>简单来说，可以把Virtual DOM 理解为一个<strong>简单的JS对象</strong>，并且最少包含标签名( tag)、属性(attrs)和子元素对象( children)三个属性。</p>
<h3 id="模板-渲染函数-虚拟dom树-真实dom">模板 → 渲染函数 → 虚拟DOM树 → 真实DOM</h3>
<p><img src="https://alexwjj.github.io//post-images/1561714145195.png" alt=""></p>
<h3 id="2作用">2.作用</h3>
<p>虚拟DOM的最终目标是将<strong>虚拟节点渲染到视图上</strong>。但是如果直接使用虚拟节点覆盖旧节点的话，会有很多不必要的DOM操作。例如，一个ul标签下很多个li标签，其中只有一个li有变化，这种情况下如果使用新的ul去替代旧的ul,因为这些不必要的DOM操作而造成了性能上的浪费。</p>
<p>为了避免不必要的DOM操作，虚拟DOM在虚拟节点映射到视图的过程中，将虚拟节点与上一次渲染视图所使用的旧虚拟节点（oldVnode）做对比，找出<strong>真正需要更新的节点</strong>来进行DOM操作，从而避免操作其他无需改动的DOM。</p>
<ul>
<li>提供与真实DOM节点所对应的<strong>虚拟节点vnode</strong></li>
<li>将虚拟节点vnode和旧虚拟节点<strong>oldVnode</strong>进行对比，然后更新视图</li>
<li>运用<strong>patching算法</strong>来计算出真正需要更新的节点</li>
<li>类比 CPU、硬盘中加入内存条</li>
</ul>
<h3 id="3diff算法">3.diff算法</h3>
<p>Vue的diff算法是基于snabbdom改造过来的，仅在<strong>同级的vnode间做diff</strong>，<strong>递归</strong>地进行同级vnode的diff，最终实现整个DOM树的更新。因为跨层级的操作是非常少的，忽略不计，这样时间复杂度就从<strong>O(n3)变成O(n)</strong>。</p>
<h4 id="diff-算法包括几个步骤">diff 算法包括几个步骤：</h4>
<ul>
<li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中</li>
<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li>
<li>把<strong>所记录的差异</strong>应用到所构建的真正的DOM树上，视图就更新了<br>
<img src="https://alexwjj.github.io//post-images/1561715188395.png" alt=""></li>
</ul>
<p>diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁：</p>
<ul>
<li>patch(container,vnode)  :初次渲染的时候，将Virtual Dom渲染成真正的DOM然后插入到容器里面。</li>
<li>patch(vnode,newVnode):再次渲染的时候，将新的vnode和旧的vnode相对比，然后之间差异应用到所构建的真正的DOM树上。</li>
<li>如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。两个children的比较是使用双向链表，<strong>边patch边操作dom</strong>。<br>
<img src="https://alexwjj.github.io//post-images/1561715535206.png" alt=""></li>
</ul>
<h4 id="diff-缺点">diff 缺点</h4>
<p>虽然这两个节点不一样但是他们的<strong>子节点一样怎么办</strong>？别忘了，diff可是逐层比较的，如果第一层不一样那么就不会继续深入比较第二层了。（我在想这算是一个缺点吗？<strong>相同子节点不能重复利用了</strong>...）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Vue ---  computed vs watch]]></title>
        <id>https://alexwjj.github.io//post/tan-jiu-vue-ji-suan-shu-xing-computed-he-zhen-ting-shu-xing-watch</id>
        <link href="https://alexwjj.github.io//post/tan-jiu-vue-ji-suan-shu-xing-computed-he-zhen-ting-shu-xing-watch">
        </link>
        <updated>2019-06-28T01:46:26.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>初学 vue 的时候就分不清computed和 watch 的区别</p>
<p>在写了一段时间的业务逻辑后，对两者有了一些认识。</p>
<p>结合各位大佬的分析，自己总结了一下。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>初学 vue 的时候就分不清computed和 watch 的区别</p>
<p>在写了一段时间的业务逻辑后，对两者有了一些认识。</p>
<p>结合各位大佬的分析，自己总结了一下。</p>
</blockquote>
<!-- more -->
<h1 id="计算属性-computed">计算属性 computed</h1>
<h2 id="1computed">1.computed</h2>
<p>计算属性是自动监听<strong>依赖值</strong>的变化，从而动态返回内容，监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些事情。它有以下几个特点：</p>
<ul>
<li>数据可以进行逻辑处理，<strong>减少模板中计算逻辑</strong>。</li>
<li>对计算属性中的数据进行监视</li>
<li>依赖固定的数据类型（响应式数据）</li>
</ul>
<p>计算属性由两部分组成：get和set，分别用来获取计算属性和设置计算属性。<strong>默认只有get</strong>，如果需要set，要自己添加。另外set设置属性，并不是直接修改计算属性，而是修改它的依赖。</p>
<pre><code>computed: {
  fullName: {
    // getter
    get: function () {
      return this.nickName + '-' + this.trueName
    },
    // setter
    set: function (newValue) {
      //this.fullName = newValue 这种写法会报错
      var names = newValue.split('-')
      this.nickName = names[0]//对它的依赖进行赋值
      this.trueName = names[names.length - 1]
    }
  }
}
</code></pre>
<p>现在再运行 vm.fullName = 'alex wjj' 时，setter 会被调用，vm.nickName 和 vm.trueName 也会相应地被更新。</p>
<h2 id="2computed-vs-methods">2.computed   vs  methods</h2>
<p>两者最主要的区别：computed 是可以<strong>缓存的</strong>，methods 不能缓存；</p>
<p>只要<strong>相关依赖</strong>没有改变，多次访问计算属性得到的值是之前缓存的计算结果，不会多次执行。</p>
<p>网上有种说法就是方法可以传参，而计算属性不能，其实并不准确，<strong>计算属性可以通过闭包来实现传参</strong>：</p>
<pre><code>:data=&quot;closure(item, itemName, blablaParams)&quot;
computed: {
 closure () {
   return function (a, b, c) {
        /** do something */
        return data
    }
 }
}

</code></pre>
<h1 id="侦听属性-watch">侦听属性 watch</h1>
<h2 id="1watch">1.watch</h2>
<p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性watch</p>
<h2 id="2使用-watch-的深度遍历deep和立即调用功能immediate">2.使用 watch 的深度遍历deep和立即调用功能immediate</h2>
<p>使用 watch 来监听数据变化的时候除了常用到 <strong>handler 回调</strong>，其实其还有两个参数，便是：</p>
<ul>
<li>deep 设置为 true 用于监听对象内部值的变化</li>
<li>immediate 设置为 true 将立即以表达式的当前值触发回调</li>
</ul>
<pre><code>&lt;template&gt;
    &lt;button @click=&quot;obj.a = 2&quot;&gt;修改&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    data() {
        return {
            obj: {
                a: 1,
            }
        }
    },
    watch: {
        obj: {
            handler: function(newVal, oldVal) {
                console.log(newVal); 
            },
            deep: true,
            immediate: true 
        }
    }
}
&lt;/script&gt;

</code></pre>
<p>以上代码修改了 obj 对象中 a 属性的值，可以触发其 watch 中的 handler 回调输出新的对象，而如果不加 deep: true，我们只能监听 obj 的改变，并不会触发回调。同时我们也添加了 immediate: true 配置，其会立即以 obj 的当前值触发回调。</p>
<pre><code>watch: {
    searchInputValue:{
        handler: 'fetchPostList',
        immediate: true
    }
}
// 声明immediate:true表示创建组件时立马执行一次。
</code></pre>
<h1 id="computed-vs-watch">computed vs watch</h1>
<p><img src="https://alexwjj.github.io//post-images/1561690381163.png" alt=""></p>
<p>流程图中，我们可以看出它们之间的区别：</p>
<ul>
<li>watch：监测的是<strong>属性值</strong>， 只要属性值发生变化，其都会触发执行回调函数来执行一系列操作。</li>
<li>computed：监测的是<strong>依赖值</strong>，依赖值不变的情况下其会直接读取缓存进行复用，变化的情况下才会重新计算。</li>
</ul>
<p>除此之外，有点很重要的区别是：计算属性不能执行异步任务，计算属性必须同步执行。也就是说计算属性不能向服务器请求或者执行异步任务。如果遇到异步任务，就交给侦听属性。watch也可以检测computed属性。</p>
<h1 id="小结">小结</h1>
<p>计算属性适合用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。</p>
<ul>
<li>computed能做的，watch都能做，反之则不行</li>
<li>能用computed的尽量用computed</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[var _this = this  的含义]]></title>
        <id>https://alexwjj.github.io//post/wei-sha-yao-var-_this-this</id>
        <link href="https://alexwjj.github.io//post/wei-sha-yao-var-_this-this">
        </link>
        <updated>2019-06-24T09:19:42.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>开发过程中，看到项目中会在顶层写一个这样的表达式</p>
<p>const  _this=this</p>
<p>下面来解释一下</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>开发过程中，看到项目中会在顶层写一个这样的表达式</p>
<p>const  _this=this</p>
<p>下面来解释一下</p>
</blockquote>
<!-- more -->
<h3 id="jquery-一个典型的列子">jquery 一个典型的列子</h3>
<pre><code>$(&quot;#btn&quot;).click(function(){
    var _this = this;//这里this和_this都代表了&quot;#btn&quot;这个对象
    $(&quot;.tr&quot;).each(function(){
          this;//在这里this代表的是每个遍历到的&quot;.tr&quot;对象
          _this;//仍代表&quot;#btn&quot;对象
    })
})
</code></pre>
<p>在一个代码片段里this有可能代表不同的对象,而编码者希望_this代表<strong>最初的对象</strong>。JS可以嵌套多层代码，可能下面还可以再嵌一个方法，引用this就会变成<strong>子方法控制的对象</strong>。如果需要<strong>上级的对象</strong>，在没有参数的情况下，前提做了一个临时变量_this，可以保存<strong>上级对象</strong>，子方<br>
法中就可以用_this来调用了，这才是目的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[v-for :key 的使用]]></title>
        <id>https://alexwjj.github.io//post/v-for-key-de-shi-yong</id>
        <link href="https://alexwjj.github.io//post/v-for-key-de-shi-yong">
        </link>
        <updated>2019-06-20T13:29:42.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>在 vue 项目中，大量使用了v-for 来遍历我们的数组。</p>
<p>:key 是vue 必须要求的，也是 vue 虚拟 DOM的 Diff 算法的依赖</p>
<p>最近在项目中遇到数据篡改的问题，记录下</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>在 vue 项目中，大量使用了v-for 来遍历我们的数组。</p>
<p>:key 是vue 必须要求的，也是 vue 虚拟 DOM的 Diff 算法的依赖</p>
<p>最近在项目中遇到数据篡改的问题，记录下</p>
</blockquote>
<!-- more -->
<h2 id="v-for">v-for</h2>
<p>使用<strong>v-for</strong>更新已渲染的元素列表时,默认用<strong>就地复用</strong>策略;列表数据修改的时候,vue会根据key值去<br>
判断某个值是否修改,如果修改,则重新渲染这一项,否则复用之前的元素;我们在使用的使用经常会使用index(即数组的下标)来作为key,但是我们要谨慎在项目中使用 index 来作为 key。</p>
<h2 id="key">:key</h2>
<p>最好的办法是使用数组中互不相同的一个属性作为key值,对应到项目中,即每条数据都有一个<strong>唯一的id</strong>,来标识这条数据的唯一性;使用id作为key值,旧值就不会重新渲染。同理在react中使用map渲染列表时,也是必须加key,且推荐做法也是使用id。</p>
<h2 id="virtual-dom-diff">Virtual DOM --- diff</h2>
<p>vue和react的虚拟DOM的Diff算法大致相同，其核心是基于两个简单的假设：</p>
<ul>
<li>两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构。</li>
<li></li>
<li>同一层级的一组节点，他们可以通过唯一的id进行区分。基于以上这两点假设，使得虚拟DOM的Diff算法<br>
的复杂度从O(n^3)降到了O(n)。</li>
</ul>
<p><strong>key的作用主要是为了高效的更新虚拟DOM</strong></p>
<h2 id="问题描述">问题描述</h2>
<p>项目中使用了 element-ui 的 time-picker 组件，绑定了数据之后，通过修改 time-picker 来修改时间。开发过程中，没有充分测试，并没有发现问题。测试提交过来，发现重新生成的时间，聚焦的时候会自动修改为上一次加载的值。</p>
<p>问题很奇怪，各种定位问题，因为页面是一年以前，一个离职的同事写的。多层数组循环嵌套，由于我们使用的 vue 版本是2.X，object.defineProperty无法监测通过数组下标访问的数据。这也导致我找问题一直在这方面寻找。</p>
<p>找了快一周了，项目要上线了。硬着头皮去找我组长了，大佬就是大佬，排查问题的方式以及思考的路子都是我要学习的地方。找了一晚上，也没注意到 key的问题。但是大佬和我不同的是，他们定位不到问题的时候会去想办法重写一个 demo，重现问题。而我的缺点是会一直卡在一个问题上，懒或者没有勇气去重写一个例子。</p>
<h2 id="后续">后续</h2>
<ol>
<li>遇到问题解决不了及时问大佬</li>
<li>学会重现问题根本原因，学会定位问题</li>
<li>谨慎使用 index 作为 key 值</li>
<li>去研究 vue api的实现原理，关注其优缺点。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Object.defineProperty   对比  Proxy]]></title>
        <id>https://alexwjj.github.io//post/objectdefineproperty-dui-bi-proxy</id>
        <link href="https://alexwjj.github.io//post/objectdefineproperty-dui-bi-proxy">
        </link>
        <updated>2019-06-14T02:40:29.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>使用 vue2.x的版本项目,双向绑定原理还是Object.defineProperty</p>
<p>导致在实际的开发过程中，有些属性的修改，双向绑定不会生效</p>
<p>所以，来好好探究下Object.defineProperty   和 vue3.0中的 Proxy</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>使用 vue2.x的版本项目,双向绑定原理还是Object.defineProperty</p>
<p>导致在实际的开发过程中，有些属性的修改，双向绑定不会生效</p>
<p>所以，来好好探究下Object.defineProperty   和 vue3.0中的 Proxy</p>
</blockquote>
<!-- more -->
<h2 id="objectdefineproperty">Object.defineProperty()</h2>
<p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p>
<p>Object.defineProperty(obj, prop, descriptor)</p>
<pre><code>* obj
* 要在其上定义属性的对象。
* prop
* 要定义或修改的属性的名称。
* descriptor
* 将被定义或修改的属性描述符。
</code></pre>
<p>具体形象生动的解释可参考这篇文章<a href="https://www.jianshu.com/p/6519575e055f">Object.defineProperty() 不详解</a></p>
<h2 id="注意-get-set">注意 get 、set</h2>
<p>在项目中遇到的问题就是，使用 vue 的双向数据绑定，在表单新增页面没问题，但是在修改的时候，v-model 绑定的属性没法被 set 赋值过来，很奇怪。想了大概两三天，没想明白，后来大佬来看了一下我v-mode 的数据类型，多层数组嵌套，通过下标的形式进行访问修改。vue2.x 使用Object.defineProperty 的存在很多限制：<strong>无法监听 属性的添加和删除、数组索引和长度的变更</strong>，直接通过数组的下标给数组设置值，不能实时响应，是因为Object.defineProperty()无法监控到数组下标的变化，后来使用了 JSON.parse(JSON.stringify())进行了一次深拷贝才解决，也可以使用 lodash 的 cloneDeep。</p>
<h2 id="使用-objectdefineproperty手动实现一个双向绑定">使用 object.defineProperty手动实现一个双向绑定</h2>
<p>主要是监听input change 事件或者键盘 keyup 事件，通过 object.defineProperty 设置 set 属性进行对象属性的 修改。</p>
<p>参考博客（这老哥的博客很生动）：<a href="https://www.jianshu.com/p/251235dd04c8">用Object.defineProperty手写一个简单的双向绑定</a></p>
<h2 id="proxy">Proxy</h2>
<p>Proxy可以理解成，在目标对象之前架设一层 &quot;拦截&quot;，当外界对该对象访问的时候，都必须经过这层拦截，而Proxy就充当了这种机制，类似于代理的含义，它可以对外界访问对象之前进行过滤和改写该对象。</p>
<p>Proxy基本语法 :const obj = new Proxy(target, handler);</p>
<p>参数说明如下：</p>
<pre><code>* target: 被代理对象。
* handler: 是一个对象，声明了代理target的一些操作。
* obj: 是被代理完成之后返回的对象。
</code></pre>
<p>但是当外界每次对obj进行操作时，就会执行handler对象上的一些方法。handler中常用的对象方法如下：</p>
<pre><code>1. get(target, propKey, receiver)
2. set(target, propKey, value, receiver)
3. has(target, propKey)
4. construct(target, args):
5. apply(target, object, args)
</code></pre>
<p><a href="https://segmentfault.com/a/1190000018574665">proxy 和 object.defineProperty实现双向绑定对比</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[webpack性能优化 --- dll]]></title>
        <id>https://alexwjj.github.io//post/webpack-xing-neng-you-hua-dll</id>
        <link href="https://alexwjj.github.io//post/webpack-xing-neng-you-hua-dll">
        </link>
        <updated>2019-06-12T07:34:23.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>公司项目中大佬做的优化</p>
<p>大大提高了打包速度</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>公司项目中大佬做的优化</p>
<p>大大提高了打包速度</p>
</blockquote>
<!-- more -->
<h2 id="背景">背景</h2>
<p>作为国内互联网医疗的扛把子，我们医院平台的 HIS 系统经过几年的 <strong>‘积累’</strong>，开发环境，测试环境的<br>
打包速度慢的令人发指。热更新要30 ~ 40S，这谁顶得住啊。公司大佬就对整个项目进行了重构，使用<br>
Vue Cli3 ，升级 webpack4等等。现在热更新也只需要3s，打包由6min降到1min，体验还是相当好的，<br>
所以自己要学习大佬们的优化方法。</p>
<h2 id="两种方案">两种方案</h2>
<p>在用 Webpack 打包的时候，对于一些不经常更新的第三方库，比如 vuex，lodash，charts，axios我们希<br>
望能和自己的代码分离开，Webpack 社区有两种方案</p>
<ul>
<li>CommonsChunkPlugin</li>
<li>DLLPlugin</li>
</ul>
<p>对于 <strong>CommonsChunkPlugin</strong>（之前的方式），webpack 每次打包实际还是需要去处理这些第三方<br>
库，只是打包完之后，能把第三方库和我们自己的代码分开。</p>
<p>而<strong>DLLPlugin</strong>（现在的方式）则是能把第三方代码完全分离开，即每次只打包项目自身的代码。</p>
<h2 id="用法">用法</h2>
<p>要使用 DLLPlugin，需要额外新建一个配置文件。所以对于用这种方式打包的项目，一般会有下面两个配置文件</p>
<pre><code>webpack.config.js
webpack.dll.config.js
</code></pre>
<p>先来看下 webpack.dll.config.js</p>
<pre><code>const webpack = require('webpack')
const library = '[name]_lib'
const path = require('path')

module.exports = {
  entry: {
    vendors: ['vue', 'lodash']
  },

  output: {
    filename: '[name].dll.js',
    path: 'dist/',
    library
  },

  plugins: [
    new webpack.DllPlugin({
      path: path.join(__dirname, 'dist/[name]-manifest.json'),
      // This must match the output.library option above
      name: library
    }),
  ],
}
</code></pre>
<p>再改下 webpack.config.js 文件</p>
<pre><code>const webpack = require('webpack')

module.exports = {
  entry: {
    app: './src/index'
  },
  output: {
    filename: 'app.bundle.js',
    path: 'dist/',
  },
  plugins: [
    new webpack.DllReferencePlugin({
      context: __dirname,
      manifest: require('./dist/vendors-manifest.json')
    })
  ]
}
manifest: require('./dist/vendors-manifest.json') 这里的路径
要和 webpack.dll.config.js 里面的对应。
</code></pre>
]]></content>
    </entry>
</feed>