<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://alexwjj.github.io/</id>
    <title>俊劫、的前端博客</title>
    <updated>2019-06-28T10:41:36.654Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://alexwjj.github.io/"/>
    <link rel="self" href="https://alexwjj.github.io//atom.xml"/>
    <subtitle>讲个笑话，你可别哭。</subtitle>
    <logo>https://alexwjj.github.io//images/avatar.png</logo>
    <icon>https://alexwjj.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 俊劫、的前端博客</rights>
    <entry>
        <title type="html"><![CDATA[Vue --- provide/inject]]></title>
        <id>https://alexwjj.github.io//post/vue-provideinject</id>
        <link href="https://alexwjj.github.io//post/vue-provideinject">
        </link>
        <updated>2019-06-28T10:27:16.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>vue2.2新增api，用于跨组件通信</p>
<p>目前还没写过，但是看项目里面几个大佬在用。学习学习</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>vue2.2新增api，用于跨组件通信</p>
<p>目前还没写过，但是看项目里面几个大佬在用。学习学习</p>
</blockquote>
<!-- more -->
<h2 id="1定义">1.定义</h2>
<p>Vue2.2.0新增API,provide和inject需要一起使用，以允许一个<strong>祖先组件</strong>向其所有<strong>子孙后代</strong>注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里<strong>始终生效</strong>。一言而蔽之：祖先组件中通过<strong>provider来提供变量</strong>，然后在<strong>子孙组件中通过inject来注入变量</strong>。</p>
<p>provide / inject API 主要解决了<strong>跨级组件间的通信问题</strong>，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p>
<h2 id="2demo">2.demo</h2>
<p>A.vue 和 B.vue，B 是 A 的子组件</p>
<pre><code>// A.vue
export default {
  provide: {
    name: '俊劫'
  }
}
</code></pre>
<pre><code>// B.vue
export default {
  inject: ['name'],
  mounted () {
    console.log(this.name);  // 俊劫
  }
}
</code></pre>
<p>provide 和 inject 绑定<strong>并不是可响应的</strong>。这是刻意为之的。但是，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。所以，上面 A.vue 的 name 如果改变了，B.vue 的 this.name 是不会改变的。</p>
<h2 id="ref-组件通信">ref 组件通信</h2>
<p>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</p>
<p>$parent / $children：访问父 / 子实例</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue --- Virtual Dom]]></title>
        <id>https://alexwjj.github.io//post/vue-virtual-dom</id>
        <link href="https://alexwjj.github.io//post/vue-virtual-dom">
        </link>
        <updated>2019-06-28T09:17:12.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>Virtual Dom是什么，这个问题在面试中会经常问到</p>
<p>但是实际开发中并不会直接去接触到Virtual Dom</p>
<p>之前对于Virtual Dom的理解都是背的，这次来深层探究下。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>Virtual Dom是什么，这个问题在面试中会经常问到</p>
<p>但是实际开发中并不会直接去接触到Virtual Dom</p>
<p>之前对于Virtual Dom的理解都是背的，这次来深层探究下。</p>
</blockquote>
<!-- more -->
<h2 id="vue模板转换成视图的过程">vue模板转换成视图的过程</h2>
<ul>
<li>Vue.js通过编译将<strong>template 模板</strong>转换成渲染函数(render ) ，执行渲染函数就可以得到一个虚拟节点树</li>
<li>在对 Model 进行操作的时候，会触发对应 Dep 中的 Watcher 对象。Watcher 对象会调用对应的 update 来修改视图。这个过程主要是将<strong>新旧虚拟节点</strong>进行<strong>差异对比</strong>，然后根据对比结果进行DOM操作来更新视图。
<img src="https://alexwjj.github.io//post-images/1561713907738.png" alt="">
<img src="https://alexwjj.github.io//post-images/1561715602464.png" alt=""></li>
</ul>
<h2 id="virtual-dom">Virtual DOM</h2>
<h3 id="1定义">1.定义</h3>
<p>Virtual DOM 其实就是一棵以 JavaScript 对象( VNode 节点)作为基础的树，用<strong>对象属性来描述节点</strong>，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。</p>
<p>简单来说，可以把Virtual DOM 理解为一个<strong>简单的JS对象</strong>，并且最少包含标签名( tag)、属性(attrs)和子元素对象( children)三个属性。</p>
<h3 id="模板-渲染函数-虚拟dom树-真实dom">模板 → 渲染函数 → 虚拟DOM树 → 真实DOM</h3>
<p><img src="https://alexwjj.github.io//post-images/1561714145195.png" alt=""></p>
<h3 id="2作用">2.作用</h3>
<p>虚拟DOM的最终目标是将<strong>虚拟节点渲染到视图上</strong>。但是如果直接使用虚拟节点覆盖旧节点的话，会有很多不必要的DOM操作。例如，一个ul标签下很多个li标签，其中只有一个li有变化，这种情况下如果使用新的ul去替代旧的ul,因为这些不必要的DOM操作而造成了性能上的浪费。</p>
<p>为了避免不必要的DOM操作，虚拟DOM在虚拟节点映射到视图的过程中，将虚拟节点与上一次渲染视图所使用的旧虚拟节点（oldVnode）做对比，找出<strong>真正需要更新的节点</strong>来进行DOM操作，从而避免操作其他无需改动的DOM。</p>
<ul>
<li>提供与真实DOM节点所对应的<strong>虚拟节点vnode</strong></li>
<li>将虚拟节点vnode和旧虚拟节点<strong>oldVnode</strong>进行对比，然后更新视图</li>
<li>运用<strong>patching算法</strong>来计算出真正需要更新的节点</li>
<li>类比 CPU、硬盘中加入内存条</li>
</ul>
<h3 id="3diff算法">3.diff算法</h3>
<p>Vue的diff算法是基于snabbdom改造过来的，仅在<strong>同级的vnode间做diff</strong>，<strong>递归</strong>地进行同级vnode的diff，最终实现整个DOM树的更新。因为跨层级的操作是非常少的，忽略不计，这样时间复杂度就从<strong>O(n3)变成O(n)</strong>。</p>
<h4 id="diff-算法包括几个步骤">diff 算法包括几个步骤：</h4>
<ul>
<li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中</li>
<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li>
<li>把<strong>所记录的差异</strong>应用到所构建的真正的DOM树上，视图就更新了
<img src="https://alexwjj.github.io//post-images/1561715188395.png" alt=""></li>
</ul>
<p>diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁：</p>
<ul>
<li>patch(container,vnode)  :初次渲染的时候，将Virtual Dom渲染成真正的DOM然后插入到容器里面。</li>
<li>patch(vnode,newVnode):再次渲染的时候，将新的vnode和旧的vnode相对比，然后之间差异应用到所构建的真正的DOM树上。</li>
<li>如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。两个children的比较是使用双向链表，<strong>边patch边操作dom</strong>。
<img src="https://alexwjj.github.io//post-images/1561715535206.png" alt=""></li>
</ul>
<h4 id="diff-缺点">diff 缺点</h4>
<p>虽然这两个节点不一样但是他们的<strong>子节点一样怎么办</strong>？别忘了，diff可是逐层比较的，如果第一层不一样那么就不会继续深入比较第二层了。（我在想这算是一个缺点吗？<strong>相同子节点不能重复利用了</strong>...）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Vue ---  computed vs watch]]></title>
        <id>https://alexwjj.github.io//post/tan-jiu-vue-ji-suan-shu-xing-computed-he-zhen-ting-shu-xing-watch</id>
        <link href="https://alexwjj.github.io//post/tan-jiu-vue-ji-suan-shu-xing-computed-he-zhen-ting-shu-xing-watch">
        </link>
        <updated>2019-06-28T01:46:26.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>初学 vue 的时候就分不清computed和 watch 的区别</p>
<p>在写了一段时间的业务逻辑后，对两者有了一些认识。</p>
<p>结合各位大佬的分析，自己总结了一下。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>初学 vue 的时候就分不清computed和 watch 的区别</p>
<p>在写了一段时间的业务逻辑后，对两者有了一些认识。</p>
<p>结合各位大佬的分析，自己总结了一下。</p>
</blockquote>
<!-- more -->
<h1 id="计算属性-computed">计算属性 computed</h1>
<h2 id="1computed">1.computed</h2>
<p>计算属性是自动监听<strong>依赖值</strong>的变化，从而动态返回内容，监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些事情。它有以下几个特点：</p>
<ul>
<li>数据可以进行逻辑处理，<strong>减少模板中计算逻辑</strong>。</li>
<li>对计算属性中的数据进行监视</li>
<li>依赖固定的数据类型（响应式数据）</li>
</ul>
<p>计算属性由两部分组成：get和set，分别用来获取计算属性和设置计算属性。<strong>默认只有get</strong>，如果需要set，要自己添加。另外set设置属性，并不是直接修改计算属性，而是修改它的依赖。</p>
<pre><code>computed: {
  fullName: {
    // getter
    get: function () {
      return this.nickName + '-' + this.trueName
    },
    // setter
    set: function (newValue) {
      //this.fullName = newValue 这种写法会报错
      var names = newValue.split('-')
      this.nickName = names[0]//对它的依赖进行赋值
      this.trueName = names[names.length - 1]
    }
  }
}
</code></pre>
<p>现在再运行 vm.fullName = 'alex wjj' 时，setter 会被调用，vm.nickName 和 vm.trueName 也会相应地被更新。</p>
<h2 id="2computed-vs-methods">2.computed   vs  methods</h2>
<p>两者最主要的区别：computed 是可以<strong>缓存的</strong>，methods 不能缓存；</p>
<p>只要<strong>相关依赖</strong>没有改变，多次访问计算属性得到的值是之前缓存的计算结果，不会多次执行。</p>
<p>网上有种说法就是方法可以传参，而计算属性不能，其实并不准确，<strong>计算属性可以通过闭包来实现传参</strong>：</p>
<pre><code>:data=&quot;closure(item, itemName, blablaParams)&quot;
computed: {
 closure () {
   return function (a, b, c) {
        /** do something */
        return data
    }
 }
}

</code></pre>
<h1 id="侦听属性-watch">侦听属性 watch</h1>
<h2 id="1watch">1.watch</h2>
<p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性watch</p>
<h2 id="2使用-watch-的深度遍历deep和立即调用功能immediate">2.使用 watch 的深度遍历deep和立即调用功能immediate</h2>
<p>使用 watch 来监听数据变化的时候除了常用到 <strong>handler 回调</strong>，其实其还有两个参数，便是：</p>
<ul>
<li>deep 设置为 true 用于监听对象内部值的变化</li>
<li>immediate 设置为 true 将立即以表达式的当前值触发回调</li>
</ul>
<pre><code>&lt;template&gt;
    &lt;button @click=&quot;obj.a = 2&quot;&gt;修改&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    data() {
        return {
            obj: {
                a: 1,
            }
        }
    },
    watch: {
        obj: {
            handler: function(newVal, oldVal) {
                console.log(newVal); 
            },
            deep: true,
            immediate: true 
        }
    }
}
&lt;/script&gt;

</code></pre>
<p>以上代码修改了 obj 对象中 a 属性的值，可以触发其 watch 中的 handler 回调输出新的对象，而如果不加 deep: true，我们只能监听 obj 的改变，并不会触发回调。同时我们也添加了 immediate: true 配置，其会立即以 obj 的当前值触发回调。</p>
<pre><code>watch: {
    searchInputValue:{
        handler: 'fetchPostList',
        immediate: true
    }
}
// 声明immediate:true表示创建组件时立马执行一次。
</code></pre>
<h1 id="computed-vs-watch">computed vs watch</h1>
<p><img src="https://alexwjj.github.io//post-images/1561690381163.png" alt=""></p>
<p>流程图中，我们可以看出它们之间的区别：</p>
<ul>
<li>watch：监测的是<strong>属性值</strong>， 只要属性值发生变化，其都会触发执行回调函数来执行一系列操作。</li>
<li>computed：监测的是<strong>依赖值</strong>，依赖值不变的情况下其会直接读取缓存进行复用，变化的情况下才会重新计算。</li>
</ul>
<p>除此之外，有点很重要的区别是：计算属性不能执行异步任务，计算属性必须同步执行。也就是说计算属性不能向服务器请求或者执行异步任务。如果遇到异步任务，就交给侦听属性。watch也可以检测computed属性。</p>
<h1 id="小结">小结</h1>
<p>计算属性适合用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。</p>
<ul>
<li>computed能做的，watch都能做，反之则不行</li>
<li>能用computed的尽量用computed</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[var _this = this  的含义]]></title>
        <id>https://alexwjj.github.io//post/wei-sha-yao-var-_this-this</id>
        <link href="https://alexwjj.github.io//post/wei-sha-yao-var-_this-this">
        </link>
        <updated>2019-06-24T09:19:42.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>开发过程中，看到项目中会在顶层写一个这样的表达式</p>
<p>const  _this=this</p>
<p>下面来解释一下</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>开发过程中，看到项目中会在顶层写一个这样的表达式</p>
<p>const  _this=this</p>
<p>下面来解释一下</p>
</blockquote>
<!-- more -->
<h3 id="jquery-一个典型的列子">jquery 一个典型的列子</h3>
<pre><code>$(&quot;#btn&quot;).click(function(){
    var _this = this;//这里this和_this都代表了&quot;#btn&quot;这个对象
    $(&quot;.tr&quot;).each(function(){
          this;//在这里this代表的是每个遍历到的&quot;.tr&quot;对象
          _this;//仍代表&quot;#btn&quot;对象
    })
})
</code></pre>
<p>在一个代码片段里this有可能代表不同的对象,而编码者希望_this代表<strong>最初的对象</strong>。JS可以嵌套多层代码，可能下面还可以再嵌一个方法，引用this就会变成<strong>子方法控制的对象</strong>。如果需要<strong>上级的对象</strong>，在没有参数的情况下，前提做了一个临时变量_this，可以保存<strong>上级对象</strong>，子方
法中就可以用_this来调用了，这才是目的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[v-for :key 的使用]]></title>
        <id>https://alexwjj.github.io//post/v-for-key-de-shi-yong</id>
        <link href="https://alexwjj.github.io//post/v-for-key-de-shi-yong">
        </link>
        <updated>2019-06-20T13:29:42.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>在 vue 项目中，大量使用了v-for 来遍历我们的数组。</p>
<p>:key 是vue 必须要求的，也是 vue 虚拟 DOM的 Diff 算法的依赖</p>
<p>最近在项目中遇到数据篡改的问题，记录下</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>在 vue 项目中，大量使用了v-for 来遍历我们的数组。</p>
<p>:key 是vue 必须要求的，也是 vue 虚拟 DOM的 Diff 算法的依赖</p>
<p>最近在项目中遇到数据篡改的问题，记录下</p>
</blockquote>
<!-- more -->
<h2 id="v-for">v-for</h2>
<p>使用<strong>v-for</strong>更新已渲染的元素列表时,默认用<strong>就地复用</strong>策略;列表数据修改的时候,vue会根据key值去
判断某个值是否修改,如果修改,则重新渲染这一项,否则复用之前的元素;我们在使用的使用经常会使用index(即数组的下标)来作为key,但是我们要谨慎在项目中使用 index 来作为 key。</p>
<h2 id="key">:key</h2>
<p>最好的办法是使用数组中互不相同的一个属性作为key值,对应到项目中,即每条数据都有一个<strong>唯一的id</strong>,来标识这条数据的唯一性;使用id作为key值,旧值就不会重新渲染。同理在react中使用map渲染列表时,也是必须加key,且推荐做法也是使用id。</p>
<h2 id="virtual-dom-diff">Virtual DOM --- diff</h2>
<p>vue和react的虚拟DOM的Diff算法大致相同，其核心是基于两个简单的假设：</p>
<ul>
<li>两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构。</li>
<li></li>
<li>同一层级的一组节点，他们可以通过唯一的id进行区分。基于以上这两点假设，使得虚拟DOM的Diff算法
的复杂度从O(n^3)降到了O(n)。</li>
</ul>
<p><strong>key的作用主要是为了高效的更新虚拟DOM</strong></p>
<h2 id="问题描述">问题描述</h2>
<p>项目中使用了 element-ui 的 time-picker 组件，绑定了数据之后，通过修改 time-picker 来修改时间。开发过程中，没有充分测试，并没有发现问题。测试提交过来，发现重新生成的时间，聚焦的时候会自动修改为上一次加载的值。</p>
<p>问题很奇怪，各种定位问题，因为页面是一年以前，一个离职的同事写的。多层数组循环嵌套，由于我们使用的 vue 版本是2.X，object.defineProperty无法监测通过数组下标访问的数据。这也导致我找问题一直在这方面寻找。</p>
<p>找了快一周了，项目要上线了。硬着头皮去找我组长了，大佬就是大佬，排查问题的方式以及思考的路子都是我要学习的地方。找了一晚上，也没注意到 key的问题。但是大佬和我不同的是，他们定位不到问题的时候会去想办法重写一个 demo，重现问题。而我的缺点是会一直卡在一个问题上，懒或者没有勇气去重写一个例子。</p>
<h2 id="后续">后续</h2>
<ol>
<li>遇到问题解决不了及时问大佬</li>
<li>学会重现问题根本原因，学会定位问题</li>
<li>谨慎使用 index 作为 key 值</li>
<li>去研究 vue api的实现原理，关注其优缺点。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Object.defineProperty   对比  Proxy]]></title>
        <id>https://alexwjj.github.io//post/objectdefineproperty-dui-bi-proxy</id>
        <link href="https://alexwjj.github.io//post/objectdefineproperty-dui-bi-proxy">
        </link>
        <updated>2019-06-14T02:40:29.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>使用 vue2.x的版本项目,双向绑定原理还是Object.defineProperty</p>
<p>导致在实际的开发过程中，有些属性的修改，双向绑定不会生效</p>
<p>所以，来好好探究下Object.defineProperty   和 vue3.0中的 Proxy</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>使用 vue2.x的版本项目,双向绑定原理还是Object.defineProperty</p>
<p>导致在实际的开发过程中，有些属性的修改，双向绑定不会生效</p>
<p>所以，来好好探究下Object.defineProperty   和 vue3.0中的 Proxy</p>
</blockquote>
<!-- more -->
<h2 id="objectdefineproperty">Object.defineProperty()</h2>
<p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p>
<p>Object.defineProperty(obj, prop, descriptor)</p>
<pre><code>* obj
* 要在其上定义属性的对象。
* prop
* 要定义或修改的属性的名称。
* descriptor
* 将被定义或修改的属性描述符。
</code></pre>
<p>具体形象生动的解释可参考这篇文章<a href="https://www.jianshu.com/p/6519575e055f">Object.defineProperty() 不详解</a></p>
<h2 id="注意-get-set">注意 get 、set</h2>
<p>在项目中遇到的问题就是，使用 vue 的双向数据绑定，在表单新增页面没问题，但是在修改的时候，v-model 绑定的属性没法被 set 赋值过来，很奇怪。想了大概两三天，没想明白，后来大佬来看了一下我v-mode 的数据类型，多层数组嵌套，通过下标的形式进行访问修改。vue2.x 使用Object.defineProperty 的存在很多限制：<strong>无法监听 属性的添加和删除、数组索引和长度的变更</strong>，直接通过数组的下标给数组设置值，不能实时响应，是因为Object.defineProperty()无法监控到数组下标的变化，后来使用了 JSON.parse(JSON.stringify())进行了一次深拷贝才解决，也可以使用 lodash 的 cloneDeep。</p>
<h2 id="使用-objectdefineproperty手动实现一个双向绑定">使用 object.defineProperty手动实现一个双向绑定</h2>
<p>主要是监听input change 事件或者键盘 keyup 事件，通过 object.defineProperty 设置 set 属性进行对象属性的 修改。</p>
<p>参考博客（这老哥的博客很生动）：<a href="https://www.jianshu.com/p/251235dd04c8">用Object.defineProperty手写一个简单的双向绑定</a></p>
<h2 id="proxy">Proxy</h2>
<p>Proxy可以理解成，在目标对象之前架设一层 &quot;拦截&quot;，当外界对该对象访问的时候，都必须经过这层拦截，而Proxy就充当了这种机制，类似于代理的含义，它可以对外界访问对象之前进行过滤和改写该对象。</p>
<p>Proxy基本语法 :const obj = new Proxy(target, handler);</p>
<p>参数说明如下：</p>
<pre><code>* target: 被代理对象。
* handler: 是一个对象，声明了代理target的一些操作。
* obj: 是被代理完成之后返回的对象。
</code></pre>
<p>但是当外界每次对obj进行操作时，就会执行handler对象上的一些方法。handler中常用的对象方法如下：</p>
<pre><code>1. get(target, propKey, receiver)
2. set(target, propKey, value, receiver)
3. has(target, propKey)
4. construct(target, args):
5. apply(target, object, args)
</code></pre>
<p><a href="https://segmentfault.com/a/1190000018574665">proxy 和 object.defineProperty实现双向绑定对比</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[webpack性能优化 --- dll]]></title>
        <id>https://alexwjj.github.io//post/webpack-xing-neng-you-hua-dll</id>
        <link href="https://alexwjj.github.io//post/webpack-xing-neng-you-hua-dll">
        </link>
        <updated>2019-06-12T07:34:23.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>公司项目中大佬做的优化</p>
<p>大大提高了打包速度</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>公司项目中大佬做的优化</p>
<p>大大提高了打包速度</p>
</blockquote>
<!-- more -->
<h2 id="背景">背景</h2>
<p>作为国内互联网医疗的扛把子，我们医院平台的 HIS 系统经过几年的 <strong>‘积累’</strong>，开发环境，测试环境的
打包速度慢的令人发指。热更新要30 ~ 40S，这谁顶得住啊。公司大佬就对整个项目进行了重构，使用
Vue Cli3 ，升级 webpack4等等。现在热更新也只需要3s，打包由6min降到1min，体验还是相当好的，
所以自己要学习大佬们的优化方法。</p>
<h2 id="两种方案">两种方案</h2>
<p>在用 Webpack 打包的时候，对于一些不经常更新的第三方库，比如 vuex，lodash，charts，axios我们希
望能和自己的代码分离开，Webpack 社区有两种方案</p>
<ul>
<li>CommonsChunkPlugin</li>
<li>DLLPlugin</li>
</ul>
<p>对于 <strong>CommonsChunkPlugin</strong>（之前的方式），webpack 每次打包实际还是需要去处理这些第三方
库，只是打包完之后，能把第三方库和我们自己的代码分开。</p>
<p>而<strong>DLLPlugin</strong>（现在的方式）则是能把第三方代码完全分离开，即每次只打包项目自身的代码。</p>
<h2 id="用法">用法</h2>
<p>要使用 DLLPlugin，需要额外新建一个配置文件。所以对于用这种方式打包的项目，一般会有下面两个配置文件</p>
<pre><code>webpack.config.js
webpack.dll.config.js
</code></pre>
<p>先来看下 webpack.dll.config.js</p>
<pre><code>const webpack = require('webpack')
const library = '[name]_lib'
const path = require('path')

module.exports = {
  entry: {
    vendors: ['vue', 'lodash']
  },

  output: {
    filename: '[name].dll.js',
    path: 'dist/',
    library
  },

  plugins: [
    new webpack.DllPlugin({
      path: path.join(__dirname, 'dist/[name]-manifest.json'),
      // This must match the output.library option above
      name: library
    }),
  ],
}
</code></pre>
<p>再改下 webpack.config.js 文件</p>
<pre><code>const webpack = require('webpack')

module.exports = {
  entry: {
    app: './src/index'
  },
  output: {
    filename: 'app.bundle.js',
    path: 'dist/',
  },
  plugins: [
    new webpack.DllReferencePlugin({
      context: __dirname,
      manifest: require('./dist/vendors-manifest.json')
    })
  ]
}
manifest: require('./dist/vendors-manifest.json') 这里的路径
要和 webpack.dll.config.js 里面的对应。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[文本溢出显示省略号]]></title>
        <id>https://alexwjj.github.io//post/wen-ben-yi-chu-xian-shi-sheng-lue-hao</id>
        <link href="https://alexwjj.github.io//post/wen-ben-yi-chu-xian-shi-sheng-lue-hao">
        </link>
        <updated>2019-06-11T07:03:07.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>单行比较好实现
多行文本显示省略号注意下</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>单行比较好实现
多行文本显示省略号注意下</p>
</blockquote>
<!-- more -->
<h2 id="1单行文本">1.单行文本</h2>
<pre><code>text-overflow: ellipsis;
white-space: nowrap;
overflow:hidden;
</code></pre>
<h2 id="2多行文本">2.多行文本</h2>
<pre><code>display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: 2;
// 用来限制在一个块元素显示的文本的行数,2表示最多显示2行。 为了实现该效果，它需要组合其他的WebKit属性
overflow: hidden;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序技术选型]]></title>
        <id>https://alexwjj.github.io//post/wei-xin-xiao-cheng-xu-ji-zhu-xuan-xing</id>
        <link href="https://alexwjj.github.io//post/wei-xin-xiao-cheng-xu-ji-zhu-xuan-xing">
        </link>
        <updated>2019-06-06T09:17:55.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>微信小程序开发方案 框架选型：Wepy、Mpvue、Taro
由于博客采用了 vue 的构建方式，部分代码会导致 github.io构建失败
所以文章在简书上。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>微信小程序开发方案 框架选型：Wepy、Mpvue、Taro
由于博客采用了 vue 的构建方式，部分代码会导致 github.io构建失败
所以文章在简书上。</p>
</blockquote>
<!-- more -->
<p><a href="https://www.jianshu.com/p/f21d99ab5da4">https://www.jianshu.com/p/f21d99ab5da4</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 入门]]></title>
        <id>https://alexwjj.github.io//post/react</id>
        <link href="https://alexwjj.github.io//post/react">
        </link>
        <updated>2019-06-06T08:36:37.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>react 入门知识点</p>
</blockquote>
<blockquote>
<p>对比着 Vue来看的</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>react 入门知识点</p>
</blockquote>
<blockquote>
<p>对比着 Vue来看的</p>
</blockquote>
<!-- more -->
<h2 id="入门">入门</h2>
<pre><code>* 使用jsx语法， script的属性 type = 'text / babel'
* 组件类的第一个字母必须大写，否则会报错，比如HelloMessage不能写成helloMessage。另外，组件类只能包含一个顶层标签，否则也会报错。
* 添加组件属性，有一个地方需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。
* this.props.children 的值有三种可能：如果当前组件没有子节点，它就是 undefined ;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array 。所以，处理 this.props.children 的时候要小心。
* React 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。
* 组件类的PropTypes属性，就是用来验证组件实例的属性是否符合要求，getDefaultProps 方法可以用来设置组件属性的默认值。
* 由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。
* 文本输入框的值，不能用 this.props.value 读取，而要定义一个 onChange 事件的回调函数，通过 event.target.value 读取用户输入的值。textarea 元素、select元素、radio元素都属于这种情况
* 组件生命周期三种状态：Mounting，Updating（正在重新被渲染），Unmounting。React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。componentWillMount() componentDidMount()
* 组件样式：style={、、{opacity: this.state.opacity}、、}，因为 React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样
</code></pre>
<h2 id="注意点">注意点</h2>
<pre><code>* getInitialState  初始化数据
* bind(this) 防止this指向错误 ，不写的话可以使用属性初始化和箭头函数（组件会重新渲染，不建议使用）。官方建议使用bind和属性初始化
* &quot; 字符串 &quot;     { 表达式 }
* onClick={activateLasers} 事件。在 React 中你不能使用返回 false 的方式阻止默认行为。你必须明确的使用 preventDefault
* 在 JavaScript 中，true &amp;&amp; expression 总是返回 expression，而 false &amp;&amp; expression 总是返回 false。如下条件判断
* {unreadMessages.length &gt; 0 &amp;&amp;
*         &lt;h2&gt;
*           You have {unreadMessages.length} unread messages.
*         &lt;/h2&gt;
*       }
* 防止组件渲染 return null
* 如果你选择不指定显式的键值，那么React将默认使用索引用（index）作为列表项目的键值。元素位于map()方法内时需要设置键属性
* 在HTML当中，像&lt;input&gt;,&lt;textarea&gt;, 和 &lt;select&gt;这类表单元素会维持自身状态，并根据用户输入进行更新。他们都通过传入一个value属性来实现对组件的控制。
*   组件嵌套{ props.children }          {props.left}  left = { &lt;assembly/&gt;}   
* 如果你不初始化状态，也不绑定方法，那么你就不需要为React组件实现构造函数。不需要constructor 
* 如果子类加入了 constructor 构造函数，则一定要手动调用父类的构造函数 super
</code></pre>
<h2 id="react生命周期">React生命周期</h2>
<pre><code>mount
1.constructor
初始化state和绑定事件处理程序
2.static getDerivedStateFromProps()
可以更新state的状态，派生状态。小心使用
3.render
不渲染任何内容，返回布尔值或者null
4.componentDidMount()
render之后，挂载完成，调用该方法。一般写发送请求的

update
1.static getDerivedStateFromProps()
2.shouldComponentUpdate()  性能优化点
在调用 static getDerivedStateFromProps 方法之后，接下来会调用 nextComponentUpdate 方法。

通过调用shouldComponentUpdate来控制是否要重新渲染组件
3.reder()
4.getSnapshotBeforeUpdate()
5.componentDidUpdate()

unMount
1.componentWillUnmount()
资源清理

error
1.static getDerivedStateFromError()
2.componentDidCatch()
</code></pre>
]]></content>
    </entry>
</feed>