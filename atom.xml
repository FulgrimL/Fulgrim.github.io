<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://alexwjj.github.io/</id>
    <title>俊劫、的前端博客</title>
    <updated>2019-06-21T05:42:03.329Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://alexwjj.github.io/"/>
    <link rel="self" href="https://alexwjj.github.io//atom.xml"/>
    <subtitle>讲个笑话，你可别哭。</subtitle>
    <logo>https://alexwjj.github.io//images/avatar.png</logo>
    <icon>https://alexwjj.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 俊劫、的前端博客</rights>
    <entry>
        <title type="html"><![CDATA[v-for :key 的使用]]></title>
        <id>https://alexwjj.github.io//post/v-for-key-de-shi-yong</id>
        <link href="https://alexwjj.github.io//post/v-for-key-de-shi-yong">
        </link>
        <updated>2019-06-20T13:29:42.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>在 vue 项目中，大量使用了v-for 来遍历我们的数组。</p>
<p>:key 是vue 必须要求的，也是 vue 虚拟 DOM的 Diff 算法的依赖</p>
<p>最近在项目中遇到数据篡改的问题</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>在 vue 项目中，大量使用了v-for 来遍历我们的数组。</p>
<p>:key 是vue 必须要求的，也是 vue 虚拟 DOM的 Diff 算法的依赖</p>
<p>最近在项目中遇到数据篡改的问题</p>
</blockquote>
<!-- more -->
<h2 id="v-for">v-for</h2>
<p>使用<strong>v-for</strong>更新已渲染的元素列表时,默认用<strong>就地复用</strong>策略;列表数据修改的时候,vue会根据key值去
判断某个值是否修改,如果修改,则重新渲染这一项,否则复用之前的元素;我们在使用的使用经常会使用index(即数组的下标)来作为key,但是我们要谨慎在项目中使用 index 来作为 key。</p>
<h2 id="key">:key</h2>
<p>最好的办法是使用数组中互不相同的一个属性作为key值,对应到项目中,即每条数据都有一个<strong>唯一的id</strong>,来标识这条数据的唯一性;使用id作为key值,旧值就不会重新渲染。同理在react中使用map渲染列表时,也是必须加key,且推荐做法也是使用id。</p>
<h2 id="virtual-dom-diff">Virtual DOM --- diff</h2>
<p>vue和react的虚拟DOM的Diff算法大致相同，其核心是基于两个简单的假设：</p>
<ul>
<li>两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构。</li>
<li></li>
<li>同一层级的一组节点，他们可以通过唯一的id进行区分。基于以上这两点假设，使得虚拟DOM的Diff算法
的复杂度从O(n^3)降到了O(n)。</li>
</ul>
<p><strong>key的作用主要是为了高效的更新虚拟DOM</strong></p>
<h2 id="问题描述">问题描述</h2>
<p>项目中使用了 element-ui 的 time-picker 组件，绑定了数据之后，通过修改 time-picker 来修改时间。开发过程中，没有充分测试，并没有发现问题。测试提交过来，发现重新生成的时间，聚焦的时候会自动修改为上一次加载的值。</p>
<p>问题很奇怪，各种定位问题，因为页面是一年以前，一个离职的同事写的。多层数组循环嵌套，由于我们使用的 vue 版本是2.X，object.defineProperty无法监测通过数组下标访问的数据。这也导致我找问题一直在这方面寻找。</p>
<p>找了快一周了，项目要上线了。硬着头皮去找我组长了，大佬就是大佬，排查问题的方式以及思考的路子都是我要学习的地方。找了一晚上，也没注意到 key的问题。但是大佬和我不同的是，他们定位不到问题的时候会去想办法重写一个 demo，重现问题。而我的缺点是会一直卡在一个问题上，懒或者没有勇气去重写一个例子。</p>
<h2 id="后续">后续</h2>
<ol>
<li>遇到问题解决不了及时问大佬</li>
<li>学会重现问题根本原因，学会定位问题</li>
<li>谨慎使用 index 作为 key 值</li>
<li>去研究 vue api的实现原理，关注其优缺点。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Object.defineProperty   对比  Proxy]]></title>
        <id>https://alexwjj.github.io//post/objectdefineproperty-dui-bi-proxy</id>
        <link href="https://alexwjj.github.io//post/objectdefineproperty-dui-bi-proxy">
        </link>
        <updated>2019-06-14T02:40:29.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>使用 vue2.x的版本项目,双向绑定原理还是Object.defineProperty</p>
<p>导致在实际的开发过程中，有些属性的修改，双向绑定不会生效</p>
<p>所以，来好好探究下Object.defineProperty   和 vue3.0中的 Proxy</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>使用 vue2.x的版本项目,双向绑定原理还是Object.defineProperty</p>
<p>导致在实际的开发过程中，有些属性的修改，双向绑定不会生效</p>
<p>所以，来好好探究下Object.defineProperty   和 vue3.0中的 Proxy</p>
</blockquote>
<!-- more -->
<h2 id="objectdefineproperty">Object.defineProperty()</h2>
<p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p>
<p>Object.defineProperty(obj, prop, descriptor)</p>
<pre><code>* obj
* 要在其上定义属性的对象。
* prop
* 要定义或修改的属性的名称。
* descriptor
* 将被定义或修改的属性描述符。
</code></pre>
<p>具体形象生动的解释可参考这篇文章<a href="https://www.jianshu.com/p/6519575e055f">Object.defineProperty() 不详解</a></p>
<h2 id="注意-get-set">注意 get 、set</h2>
<p>在项目中遇到的问题就是，使用 vue 的双向数据绑定，在表单新增页面没问题，但是在修改的时候，v-model 绑定的属性没法被 set 赋值过来，很奇怪。想了大概两三天，没想明白，后来大佬来看了一下我v-mode 的数据类型，多层数组嵌套，通过下标的形式进行访问修改。vue2.x 使用Object.defineProperty 的存在很多限制：<strong>无法监听 属性的添加和删除、数组索引和长度的变更</strong>，直接通过数组的下标给数组设置值，不能实时响应，是因为Object.defineProperty()无法监控到数组下标的变化，后来使用了 JSON.parse(JSON.stringify())进行了一次深拷贝才解决，也可以使用 lodash 的 cloneDeep。</p>
<h2 id="使用-objectdefineproperty手动实现一个双向绑定">使用 object.defineProperty手动实现一个双向绑定</h2>
<p>主要是监听input change 事件或者键盘 keyup 事件，通过 object.defineProperty 设置 set 属性进行对象属性的 修改。</p>
<p>参考博客（这老哥的博客很生动）：<a href="https://www.jianshu.com/p/251235dd04c8">用Object.defineProperty手写一个简单的双向绑定</a></p>
<h2 id="proxy">Proxy</h2>
<p>Proxy可以理解成，在目标对象之前架设一层 &quot;拦截&quot;，当外界对该对象访问的时候，都必须经过这层拦截，而Proxy就充当了这种机制，类似于代理的含义，它可以对外界访问对象之前进行过滤和改写该对象。</p>
<p>Proxy基本语法 :const obj = new Proxy(target, handler);</p>
<p>参数说明如下：</p>
<pre><code>* target: 被代理对象。
* handler: 是一个对象，声明了代理target的一些操作。
* obj: 是被代理完成之后返回的对象。
</code></pre>
<p>但是当外界每次对obj进行操作时，就会执行handler对象上的一些方法。handler中常用的对象方法如下：</p>
<pre><code>1. get(target, propKey, receiver)
2. set(target, propKey, value, receiver)
3. has(target, propKey)
4. construct(target, args):
5. apply(target, object, args)
</code></pre>
<p><a href="https://segmentfault.com/a/1190000018574665">proxy 和 object.defineProperty实现双向绑定对比</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[webpack性能优化 --- dll]]></title>
        <id>https://alexwjj.github.io//post/webpack-xing-neng-you-hua-dll</id>
        <link href="https://alexwjj.github.io//post/webpack-xing-neng-you-hua-dll">
        </link>
        <updated>2019-06-12T07:34:23.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>公司项目中大佬做的优化</p>
<p>大大提高了打包速度</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>公司项目中大佬做的优化</p>
<p>大大提高了打包速度</p>
</blockquote>
<!-- more -->
<h2 id="背景">背景</h2>
<p>作为国内互联网医疗的扛把子，我们医院平台的 HIS 系统经过几年的 <strong>‘积累’</strong>，开发环境，测试环境的
打包速度慢的令人发指。热更新要30 ~ 40S，这谁顶得住啊。公司大佬就对整个项目进行了重构，使用
Vue Cli3 ，升级 webpack4等等。现在热更新也只需要3s，打包由6min降到1min，体验还是相当好的，
所以自己要学习大佬们的优化方法。</p>
<h2 id="两种方案">两种方案</h2>
<p>在用 Webpack 打包的时候，对于一些不经常更新的第三方库，比如 vuex，lodash，charts，axios我们希
望能和自己的代码分离开，Webpack 社区有两种方案</p>
<ul>
<li>CommonsChunkPlugin</li>
<li>DLLPlugin</li>
</ul>
<p>对于 <strong>CommonsChunkPlugin</strong>（之前的方式），webpack 每次打包实际还是需要去处理这些第三方
库，只是打包完之后，能把第三方库和我们自己的代码分开。</p>
<p>而<strong>DLLPlugin</strong>（现在的方式）则是能把第三方代码完全分离开，即每次只打包项目自身的代码。</p>
<h2 id="用法">用法</h2>
<p>要使用 DLLPlugin，需要额外新建一个配置文件。所以对于用这种方式打包的项目，一般会有下面两个配置文件</p>
<pre><code>webpack.config.js
webpack.dll.config.js
</code></pre>
<p>先来看下 webpack.dll.config.js</p>
<pre><code>const webpack = require('webpack')
const library = '[name]_lib'
const path = require('path')

module.exports = {
  entry: {
    vendors: ['vue', 'lodash']
  },

  output: {
    filename: '[name].dll.js',
    path: 'dist/',
    library
  },

  plugins: [
    new webpack.DllPlugin({
      path: path.join(__dirname, 'dist/[name]-manifest.json'),
      // This must match the output.library option above
      name: library
    }),
  ],
}
</code></pre>
<p>再改下 webpack.config.js 文件</p>
<pre><code>const webpack = require('webpack')

module.exports = {
  entry: {
    app: './src/index'
  },
  output: {
    filename: 'app.bundle.js',
    path: 'dist/',
  },
  plugins: [
    new webpack.DllReferencePlugin({
      context: __dirname,
      manifest: require('./dist/vendors-manifest.json')
    })
  ]
}
manifest: require('./dist/vendors-manifest.json') 这里的路径
要和 webpack.dll.config.js 里面的对应。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[文本溢出显示省略号]]></title>
        <id>https://alexwjj.github.io//post/wen-ben-yi-chu-xian-shi-sheng-lue-hao</id>
        <link href="https://alexwjj.github.io//post/wen-ben-yi-chu-xian-shi-sheng-lue-hao">
        </link>
        <updated>2019-06-11T07:03:07.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>单行比较好实现
多行文本显示省略号注意下</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>单行比较好实现
多行文本显示省略号注意下</p>
</blockquote>
<!-- more -->
<h2 id="1单行文本">1.单行文本</h2>
<pre><code>text-overflow: ellipsis;
white-space: nowrap;
overflow:hidden;
</code></pre>
<h2 id="2多行文本">2.多行文本</h2>
<pre><code>display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: 2;
// 用来限制在一个块元素显示的文本的行数,2表示最多显示2行。 为了实现该效果，它需要组合其他的WebKit属性
overflow: hidden;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序技术选型]]></title>
        <id>https://alexwjj.github.io//post/wei-xin-xiao-cheng-xu-ji-zhu-xuan-xing</id>
        <link href="https://alexwjj.github.io//post/wei-xin-xiao-cheng-xu-ji-zhu-xuan-xing">
        </link>
        <updated>2019-06-06T09:17:55.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>微信小程序开发方案 框架选型：Wepy、Mpvue、Taro
由于博客采用了 vue 的构建方式，部分代码会导致 github.io构建失败
所以文章在简书上。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>微信小程序开发方案 框架选型：Wepy、Mpvue、Taro
由于博客采用了 vue 的构建方式，部分代码会导致 github.io构建失败
所以文章在简书上。</p>
</blockquote>
<!-- more -->
<p><a href="https://www.jianshu.com/p/f21d99ab5da4">https://www.jianshu.com/p/f21d99ab5da4</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React 入门]]></title>
        <id>https://alexwjj.github.io//post/react</id>
        <link href="https://alexwjj.github.io//post/react">
        </link>
        <updated>2019-06-06T08:36:37.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>react 入门知识点</p>
</blockquote>
<blockquote>
<p>对比着 Vue来看的</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>react 入门知识点</p>
</blockquote>
<blockquote>
<p>对比着 Vue来看的</p>
</blockquote>
<!-- more -->
<h2 id="入门">入门</h2>
<pre><code>* 使用jsx语法， script的属性 type = 'text / babel'
* 组件类的第一个字母必须大写，否则会报错，比如HelloMessage不能写成helloMessage。另外，组件类只能包含一个顶层标签，否则也会报错。
* 添加组件属性，有一个地方需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。
* this.props.children 的值有三种可能：如果当前组件没有子节点，它就是 undefined ;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array 。所以，处理 this.props.children 的时候要小心。
* React 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。
* 组件类的PropTypes属性，就是用来验证组件实例的属性是否符合要求，getDefaultProps 方法可以用来设置组件属性的默认值。
* 由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。
* 文本输入框的值，不能用 this.props.value 读取，而要定义一个 onChange 事件的回调函数，通过 event.target.value 读取用户输入的值。textarea 元素、select元素、radio元素都属于这种情况
* 组件生命周期三种状态：Mounting，Updating（正在重新被渲染），Unmounting。React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。componentWillMount() componentDidMount()
* 组件样式：style={、、{opacity: this.state.opacity}、、}，因为 React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样
</code></pre>
<h2 id="注意点">注意点</h2>
<pre><code>* getInitialState  初始化数据
* bind(this) 防止this指向错误 ，不写的话可以使用属性初始化和箭头函数（组件会重新渲染，不建议使用）。官方建议使用bind和属性初始化
* &quot; 字符串 &quot;     { 表达式 }
* onClick={activateLasers} 事件。在 React 中你不能使用返回 false 的方式阻止默认行为。你必须明确的使用 preventDefault
* 在 JavaScript 中，true &amp;&amp; expression 总是返回 expression，而 false &amp;&amp; expression 总是返回 false。如下条件判断
* {unreadMessages.length &gt; 0 &amp;&amp;
*         &lt;h2&gt;
*           You have {unreadMessages.length} unread messages.
*         &lt;/h2&gt;
*       }
* 防止组件渲染 return null
* 如果你选择不指定显式的键值，那么React将默认使用索引用（index）作为列表项目的键值。元素位于map()方法内时需要设置键属性
* 在HTML当中，像&lt;input&gt;,&lt;textarea&gt;, 和 &lt;select&gt;这类表单元素会维持自身状态，并根据用户输入进行更新。他们都通过传入一个value属性来实现对组件的控制。
*   组件嵌套{ props.children }          {props.left}  left = { &lt;assembly/&gt;}   
* 如果你不初始化状态，也不绑定方法，那么你就不需要为React组件实现构造函数。不需要constructor 
* 如果子类加入了 constructor 构造函数，则一定要手动调用父类的构造函数 super
</code></pre>
<h2 id="react生命周期">React生命周期</h2>
<pre><code>mount
1.constructor
初始化state和绑定事件处理程序
2.static getDerivedStateFromProps()
可以更新state的状态，派生状态。小心使用
3.render
不渲染任何内容，返回布尔值或者null
4.componentDidMount()
render之后，挂载完成，调用该方法。一般写发送请求的

update
1.static getDerivedStateFromProps()
2.shouldComponentUpdate()  性能优化点
在调用 static getDerivedStateFromProps 方法之后，接下来会调用 nextComponentUpdate 方法。

通过调用shouldComponentUpdate来控制是否要重新渲染组件
3.reder()
4.getSnapshotBeforeUpdate()
5.componentDidUpdate()

unMount
1.componentWillUnmount()
资源清理

error
1.static getDerivedStateFromError()
2.componentDidCatch()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node 入门]]></title>
        <id>https://alexwjj.github.io//post/node-ru-men</id>
        <link href="https://alexwjj.github.io//post/node-ru-men">
        </link>
        <updated>2019-06-05T11:32:58.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>跟着《七天学会 nodejs》文档走了一遍</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>跟着《七天学会 nodejs》文档走了一遍</p>
</blockquote>
<!-- more -->
<h2 id="1基础概念">1.基础概念</h2>
<pre><code>* 创建node应用：1.require（） 2.创建服务器  3.接受请求和响应请求
* REPL 交互式解释器 ： 读取，执行，打印，循环 Read–eval–print loop 可以直接运行各种JavaScript命令  _ + 1   下划线表示上一个命令的结果
* node事件驱动模型：当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。高并发
* node内置事件：events
* Buffer 缓冲区   node类  该类用来创建一个专门存放二进制数据的缓存区。
* 如果想要拷贝一份Buffer，得首先创建一个新的Buffer，并通过.copy方法把原Buffer中的数据复制过去。
* Buffer与字符串有一个重要区别。字符串是只读的，并且对字符串的任何修改得到的都是一个新字符串，原字符串保持不变。至于Buffer,可以用[index]方式直接修改某个位置的字节
* Node约定，如果某个函数需要回调函数作为参数，则回调函数是最后一个参数。另外，回调函数本身的第一个参数，约定为上一步传入的错误对象。callback = function （error，value） {}
* require命令用于指定加载模块，加载时可以省略脚本文件的后缀名
* PM2是Node.js应用程序的进程管理器
* NodeJS允许通过NODE_PATH环境变量来指定额外的模块搜索路径。
* stream 当内存中无法一次装下需要处理的数据时，或者一边读取一边处理更加高效时，我们就需要用到数据流。
</code></pre>
<h2 id="3node全局对象-全局函数-全局变量">3.Node全局对象 &amp;&amp; 全局函数 &amp;&amp; 全局变量</h2>
<pre><code>* global：表示Node所在的全局环境，类似于浏览器的window对象
* process：该对象表示Node所处的当前进程，允许开发者与该进程互动。
* console：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。
* setTimeout()：用于在指定毫秒之后，运行回调函数。
* clearTimeout()：用于终止一个setTimeout方法新建的定时器。
* setInterval()：用于每隔一定毫秒调用回调函数。
* clearInterval()：终止一个用setInterval方法新建的定时器。
* require()：用于加载模块。
* Buffer()：用于操作二进制数据。
* __filename：指向当前运行的脚本文件名。
* __dirname：指向当前运行的脚本所在的目录。
</code></pre>
<h2 id="4node核心模块">4.Node核心模块</h2>
<pre><code>* 核心模块总是最优先加载的
* http：提供HTTP服务器功能。
* url：解析URL。
* fs：与文件系统交互。
* querystring：解析URL的查询字符串。
* child_process：新建子进程。
* util：提供一系列实用小工具。
* path：处理文件路径。
* crypto：提供加密和解密功能，基本上是对OpenSSL的包装。
</code></pre>
<h2 id="5模块使用的简单例子">5.模块使用的简单例子</h2>
<pre><code>foo.js module.exports = function( x ) { console.log( x) }
index.js  var m = require( './foo.js' )   m('面对疾风吧')
node index.js   面对疾风吧!
</code></pre>
<h2 id="6node-异常处理">6.Node 异常处理</h2>
<pre><code>* Node是单线程运行环境，一旦抛出的异常没有被捕获，就会引起整个进程的崩溃。一般处理错误有下面三种方法：
* 使用throw语句抛出一个错误对象，即抛出异常。
* 将错误对象传递给回调函数，由回调函数负责发出错误。
* 通过EventEmitter接口，发出一个error事件。
* eg：fs.readFile('/foo.txt', function(err, data) {
*   if (err !== null) throw err;
*   console.log(data);
* });
* 当一个异常未被捕获，就会触发uncaughtException事件，可以对这个事件注册回调函数，从而捕获异常。
* iojs有一个unhandledRejection事件，用来监听没有捕获的Promise对象的rejected状态。
</code></pre>
<h2 id="7版本号">7.版本号</h2>
<p>语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。</p>
<pre><code>+ 如果只是修复bug，需要更新Z位。
+ 如果是新增了功能，但是向下兼容，需要更新Y位。
+ 如果有大变动，向下不兼容，需要更新X位。
</code></pre>
<h2 id="8文件操作">8.文件操作</h2>
<h3 id="fs文件系统">fs文件系统</h3>
<pre><code>* 文件属性读写。fs.stat、fs.chmod、fs.chown等等
* 文件内容读写。fs.readFile、fs.readdir、fs.writeFile、fs.mkdir等等
* 底层文件操作。fs.open、fs.read、fs.write、fs.close等等
* 小文件拷贝：fs.readFileSync     fs.writeFileSync
* 大文件拷贝：fs.createReadStream     fs.createWriteStream
* ipe方法把两个数据流连接了起来。
</code></pre>
<h3 id="path">path</h3>
<pre><code>path.normalize 将传入的路径转换为标准路径，具体讲的话，除了解析路径中的.与..外，还能去掉多余的斜杠。
**坑出没注意**： 标准化之后的路径里的斜杠在Windows系统下是\，而在Linux系统下是/。如果想保证任何系统下都使用/作为路径分隔符的话，需要用.replace(/\\/g, '/')再替换一下标准路径。
path.join 将传入的多个路径拼接为标准路径。
path.extname 当我们需要根据不同文件扩展名做不同操作时
</code></pre>
<h3 id="遍历">遍历</h3>
<pre><code>遍历算法： 深度优先 + 先序遍历
同步遍历
异步遍历
</code></pre>
<h3 id="文本编码">文本编码</h3>
<pre><code>我们常用的文本编码有UTF8和GBK两种，并且UTF8文件还可能带有BOM。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的UTF8编码字符串后才能正常处理。
BOM移除：通过文本文件的头几个字符判断是否存在BOM，存在则移除
GBK转UTF8 ：node不支持GBK，可以通过npm包iconv-lite来转换
单字节编码：当我们需要处理的字符在ASCII 0-128时，使用单字节编码。不需要考虑GBK或者UTF8
</code></pre>
<h3 id="网络操作">网络操作</h3>
<p>创建一个HTTP的web服务器</p>
<pre><code>var http = require('http');
http.createServer(function (request, response) {
    response.writeHead(200, { 'Content-Type': 'text-plain' });
    response.end('Hello World\n');
}).listen(8124);
创建一个HTTPS的web服务器
var options = {
        key: fs.readFileSync('./ssl/default.key'),
        cert: fs.readFileSync('./ssl/default.cer')
    };
var server = https.createServer(options, function (request, response) {
        // ...
    });
</code></pre>
<h3 id="http-https">HTTP &amp; HTTPS</h3>
<pre><code>* HTTP请求本质上是一个数据流，由请求头（headers）和请求体（body）组成。
* HTTP请求在发送给服务器时，可以认为是按照从头到尾的顺序一个字节一个字节地以数据流方式发送的。而http模块创建的HTTP服务器在接收到完整的请求头后，就会调用回调函数。
* https模块与http模块极为类似，区别在于https模块需要额外处理SSL证书。
* 目标服务器使用的SSL证书是自制的，https模块会拒绝连接，在options里加入rejectUnauthorized: false字段可以禁用对证书有效性的检查
</code></pre>
<h3 id="url">URL</h3>
<pre><code>一个url的基本组成
 http: // user:pass @ host.com : 8080 /p/a/t/h ?query=string #hash
 -----        ---------         --------       ----    --------    -------------      -----
protocol     auth        hostname   port   pathname search       hash
我们可以使用.parse方法来将一个URL字符串转换为URL对象 键值对形式
.parse方法还支持第二个和第三个布尔类型可选参数。第二个参数等于true时，该方法返回的URL对象中，query字段不再是一个字符串，而是一个经过querystring模块转换后的参数对象。第三个参数等于true时，该方法可以正确解析不带协议头的URL
format方法允许将一个URL对象转换为URL字符串
.resolve方法可以用于拼接URL，url.resolve('http://www.example.com/foo/bar', '../baz');
querystring模块用于实现URL参数字符串与参数对象的互相转换
querystring.parse         querystring.stringify
</code></pre>
<h3 id="zlib">Zlib</h3>
<p>zlib模块提供了数据压缩和解压的功能。当我们处理HTTP请求和响应时，可能需要用到这个模块。</p>
<h3 id="net">Net</h3>
<p>net模块可用于创建Socket服务器或Socket客户端。</p>
<h2 id="9进程管理">9.进程管理</h2>
<h3 id="1process">1.process</h3>
<p>process一个全局对象，在任何地方都可以直接使用。</p>
<h3 id="2child-process">2.child process</h3>
<p>使用child_process模块可以创建和控制子进程。该模块提供的API中最核心的是.spawn，其余API都是针对特定使用场景对它的进一步封装，算是一种语法糖。</p>
<h3 id="3cluter">3.cluter</h3>
<p>cluster模块是对child_process模块的进一步封装，专用于解决单进程NodeJS Web服务器无法充分利用多核CPU的问题</p>
<h3 id="4应用场景">4.应用场景</h3>
<pre><code>* process.argv 获取命令行参数 ，第一个命令行参数从argv[2] 开始。可以自己处理
* process.exit(1) 退出程序
* NodeJS程序的标准输入流（stdin）、一个标准输出流（stdout）、一个标准错误流（stderr）分别对应process.stdin、process.stdout和process.stderr
* 降权: Linux 使用root权限才能监听1024以下端口，完成端口监听安全考虑要把权限降下来，process.setgid(gid)   process.setuid(uid) 降权时必须先降GID再降UID
</code></pre>
<h3 id="5创建子进程">5.创建子进程</h3>
<p><code>var child = child_process.spawn('node', [ 'xxx.js' ]);</code>
<code>.spawn(exec, args, options)</code>方法，第一个参数是执行文件路径，第二个参数中，数组中的每个成员都按顺序对应一个命令行参数。第三个参数可选，用于配置子进程的执行环境与行为。</p>
<h3 id="6进程之间的通讯">6.进程之间的通讯</h3>
<p>父进程通过.kill方法向子进程发送SIGTERM信号，子进程监听process对象的SIGTERM事件响应信号
如果父子进程都是NodeJS进程，就可以通过IPC（进程间通讯）双向传递数据。</p>
<h3 id="7守护子进程">7.守护子进程</h3>
<p>守护进程一般用于监控工作进程的运行状态，在工作进程不正常退出时重启工作进程，保障工作进程不间断运行。</p>
<pre><code>worker.on('exit', function (code) {
        if (code !== 0) {
            spawn(mainModule);
        }
    });
</code></pre>
<p>工作进程非正常退出时，守护进程立即重启工作进程。</p>
<h2 id="10异步编程">10.异步编程</h2>
<h3 id="1回调">1.回调</h3>
<p>JS本身是单线程的，无法异步执行</p>
<p>setTimeout这类JS规范之外的由运行环境提供的特殊函数做的事情是创建一个平行线程后立即返回，让JS主进程可以接着执行后续代码，并在收到平行进程的通知后再执行回调函数。除了setTimeout、
setInterval这些常见的，这类函数还包括NodeJS提供的诸如fs.readFile之类的异步API。</p>
<p>JS自身提供的异常捕获和处理机制——try..catch..，只能用于同步执行的代码。</p>
<h3 id="2域domain">2.域（Domain）</h3>
<p>NodeJS提供了domain模块，可以简化异步代码的异常处理。简单的讲，一个域就是一个JS运行环境，在一个运行环境中，如果一个异常没有被捕获，将作为一个全局异常被抛出。NodeJS通过process对象提供了捕获全局异常的方法</p>
<pre><code>var d = domain.create();
d.on
d.run
</code></pre>
<p>无论是通过process对象的uncaughtException事件捕获到全局异常，还是通过子域对象的error事件捕获到了子域异常，在NodeJS官方文档里都强烈建议处理完异常后立即重启程序，发生异常后的程序处于一个不确定的运行状态，如果不立即退出的话，程序可能会发生严重内存泄漏，也可能表现得很奇怪。</p>
<h2 id="11socket">11.Socket</h2>
<h3 id="1tcp-ip">1.TCP / IP</h3>
<p>TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议</p>
<p>TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中</p>
<pre><code>* 应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等
* 传输层：TCP，UDP
* 网络层：IP，ICMP，OSPF，EIGRP，IGMP
* 数据链路层：SLIP，CSLIP，PPP，MTU
</code></pre>
<h3 id="2socket">2.socket</h3>
<p>socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用以实现进程在网络中通信。</p>
<p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，ip地址＋协议＋端口号唯一标示网络中的一个进程。   三端socket是一种&quot;打开—读/写—关闭&quot;模式的实现。服务器socket与客户端socket建立连接的部分其实就是大名鼎鼎的三次握手
<code>Scoket api ： scoket ， bind ， listen， connect， accept， read ，write，close</code></p>
<h3 id="3websocket">3.websocket</h3>
<pre><code>WebSocket是一种在单个TCP连接上进行全双工通信的协议。
HTTP 协议做不到服务器主动向客户端推送信息。
默认端口80 和 443
没有同源限制，客户端可以与任意服务器通信
协议标识符：ws ， wss（加密的） 
创建：var ws = new WebSocket('ws://localhost:8080');
webSocket.readyState()
readyState属性返回实例对象的当前状态，共有四种：
CONNECTING：值为0，表示正在连接。
OPEN：值为1，表示连接成功，可以通信了。
CLOSING：值为2，表示连接正在关闭。
CLOSED：值为3，表示连接已经关闭，或者打开连接失败
 webSocket.onopen()
实例对象的onopen属性，用于指定连接成功后的回调函数。
如果要指定多个回调函数，可以使用addEventListener方法。
webSocket.onclose()
实例对象的onclose属性，用于指定连接关闭后的回调函数。
webSocket.onmessage()
实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。
 webSocket.send()
实例对象的send()方法用于向服务器发送数据。
webSocket.bufferedAmount()
实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。
webSocket.onerror()
实例对象的onerror属性，用于指定报错时的回调函数
webscoket数据传递
数据分片传输，根据FIN的值来判断，FIN=1表示当前数据帧为最后一个数据帧，FIN=0，还需要继续监听其他数据帧
</code></pre>
<p><img src="https://alexwjj.github.io//post-images/1559734484836.jpeg" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redux]]></title>
        <id>https://alexwjj.github.io//post/redux</id>
        <link href="https://alexwjj.github.io//post/redux">
        </link>
        <updated>2019-06-05T11:31:18.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>对比 VueX 总结 Redux 的简单使用方法</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>对比 VueX 总结 Redux 的简单使用方法</p>
</blockquote>
<!-- more -->
<h2 id="1方式">1.方式</h2>
<p>应用中所有的 state 都以一个对象树的形式储存在一个单一的 store 中。 惟一改变 state 的办法是触发 action，一个描述发生什么的对象。 为了描述 action 如何改变 state 树，你需要编写 reducers。</p>
<h2 id="2三大原则">2.三大原则</h2>
<p>1.单一数据源</p>
<p>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</p>
<p>2.State 是只读的</p>
<p>唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</p>
<p>3.使用纯函数来执行修改</p>
<p>为了描述 action 如何改变 state tree ，你需要编写 reducers；Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state。</p>
<h2 id="3基础">3.基础</h2>
<h3 id="action">Action</h3>
<p>Action 是把数据从应用传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。</p>
<p>action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action。</p>
<p><code>import { ADD_TODO, REMOVE_TODO } from '../actionTypes'</code></p>
<p>最后，再添加一个 action type 来表示当前的任务展示选项。</p>
<pre><code>{
  type: SET_VISIBILITY_FILTER,
  filter: SHOW_COMPLETED
}
</code></pre>
<p>store 里能直接通过 store.dispatch() 调用 dispatch() 方法，但是多数情况下你会使用 react-redux提供的 connect() 帮助器来调用。bindActionCreators() 可以自动把多个 action 创建函数 绑定到 dispatch() 方法上。</p>
<h3 id="reducer">Reducer</h3>
<h3 id="定义">定义</h3>
<p>Reducers 指定了应用状态的变化如何响应 actions 并发送到 store 的，记住 actions 只是描述了有事情发生了这一事实，并没有描述应用如何更新 state。</p>
<p>之所以将这样的函数称之为reducer，是因为这种函数与被传入 Array.prototype.reduce(reducer, ?initialValue) 里的回调函数属于相同的类型。</p>
<h3 id="注意">注意</h3>
<p>1.不要修改 state。 使用 Object.assign() 新建了一个副本。不能这样使用 Object.assign(state, { visibilityFilter: action.filter })，因为它会改变第一个参数的值。你必须把第一个参数设置为空对象。这样写return Object.assign({}, state,{visibilityFilter: action.filter})</p>
<p>2.在 default 情况下返回旧的 state。遇到未知的 action 时，一定要返回旧的 state。</p>
<h3 id="reducer分类">Reducer分类</h3>
<p>每个 reducer 只负责管理全局 state 中它负责的一部分。每个 reducer 的 state 参数都不同，分别对应它管理的那部分 state 数据。</p>
<pre><code>function todoApp(state = {}, action) {
  return {
    visibilityFilter: visibilityFilter(state.visibilityFilter, action),
    todos: todos(state.todos, action)
  }
}
</code></pre>
<p>Redux 提供了 combineReducers() 工具类来做上面 todoApp 做的事情，这样就能消灭一些样板代码了。有了它，可以这样重构 todoApp</p>
<pre><code>const todoApp = combineReducers({
  visibilityFilter,
  todos
})
</code></pre>
<h3 id="store">Store</h3>
<p>Store 就是把它们联系到一起的对象。Store 有以下职责：</p>
<pre><code>* 维持应用的 state；
* 提供 getState() 方法获取 state；
* 提供 dispatch(action) 方法更新 state；
* 通过 subscribe(listener) 注册监听器;
* 通过 subscribe(listener) 返回的函数注销监听器。
* createStore() 的第二个参数是可选的, 用于设置 state 初始状态。
</code></pre>
<h3 id="单向数据流">单向数据流</h3>
<p>Redux 应用中数据的生命周期遵循下面 4 个步骤：</p>
<p>1.调用 store.dispatch(action)。</p>
<p>2.Redux store 调用传入的 reducer 函数。Store 会把两个参数传入 reducer： 当前的 state 树和 action。</p>
<p>3.根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。Redux 原生提供combineReducers()辅助函数，来把根 reducer 拆分成多个函数，用于分别处理 state 树的一个分支。</p>
<p>4.Redux store 保存了根 reducer 返回的完整 state 树。</p>
<h3 id="react-redux">React + Redux</h3>
<h3 id="容器组件">容器组件</h3>
<p>容器组件就是使用 store.subscribe() 从 Redux state 树中读取部分数据，并通过 props 来把这些数据提供给要渲染的组件</p>
<p>建议使用 React Redux 库的 connect() 方法来生成，这个方法做了性能优化来避免很多不必要的重复渲染。</p>
<p>使用 connect() 前，需要先定义 mapStateToProps 这个函数来指定如何把当前 Redux store state 映射到展示组件的 props 中</p>
<h3 id="传入store">传入store</h3>
<p>所有容器组件都可以访问 Redux store，所以可以手动监听它。一种方式是把它以 props 的形式传入到所有容器组件中。</p>
<p>建议的方式是使用指定的 React Redux 组件 <Provider> 来 魔法般的 让所有容器组件都可以访问 store，而不必显示地传递它。只需要在渲染根组件时使用即可。</p>
<pre><code>render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  document.getElementById('root')
)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React router]]></title>
        <id>https://alexwjj.github.io//post/react-router</id>
        <link href="https://alexwjj.github.io//post/react-router">
        </link>
        <updated>2019-06-05T11:29:13.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>对比 vue router 看react router官方文档总结</p>
</blockquote>
<blockquote>
<p>比较基础</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>对比 vue router 看react router官方文档总结</p>
</blockquote>
<blockquote>
<p>比较基础</p>
</blockquote>
<!-- more -->
<h2 id="1使用时路由器router就是react的一个组件">1.使用时，路由器Router就是React的一个组件。</h2>
<pre><code>React.render((
  &lt;Router&gt;
    &lt;Route path=&quot;/&quot; component={App}&gt;
      &lt;Route path=&quot;about&quot; component={About} /&gt;
      &lt;Route path=&quot;inbox&quot; component={Inbox}&gt;
        &lt;Route path=&quot;messages/:id&quot; component={Message} /&gt;
      &lt;/Route&gt;
    &lt;/Route&gt;
  &lt;/Router&gt;
), document.body)
</code></pre>
<p>IndexRoute解决App组件中this.porps.children为undefined时的问题，显式指定Home是根路由的子组件，即指定默认情况下加载的子组件。你可以把IndexRoute想象成某个路径的index.html。</p>
<pre><code>&lt;Router&gt;
  &lt;Route path=&quot;/&quot; component={App}&gt;
    &lt;IndexRoute component={Home}/&gt;
    &lt;Route path=&quot;accounts&quot; component={Accounts}/&gt;
    &lt;Route path=&quot;statements&quot; component={Statements}/&gt;
  &lt;/Route&gt;
&lt;/Router&gt;
</code></pre>
<p>渲染：访问 /</p>
<pre><code>&lt;App&gt;
  &lt;Home/&gt;
&lt;/App&gt;
</code></pre>
<p>如果我们可以将 /inbox 从 /inbox/messages/:id 中去除，并且还能够让 Message 嵌套在 App -&gt;Inbox 中渲染</p>
<pre><code>* 绝对路径{/* 使用 /messages/:id 替换 messages/:id */}
* &lt;Route path=&quot;/messages/:id&quot; component={Message} /&gt;
* 路由跳转{/* 跳转 /inbox/messages/:id 到 /messages/:id */}
* &lt;Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt;
</code></pre>
<p>2.Route 可以定义 onEnter 和 onLeave 两个 hook ，这些hook会在页面跳转确认时触发一次</p>
<p>onLeave （内到外）从最下层的子路由开始直到最外层父路由结束。然后onEnter（外到内）会从最外层的父路由开始直到最下层子路由结束。</p>
<p>3.路由路径是匹配一个（或一部分）URL 的 一个字符串模式。大部分的路由路径都可以直接按照字面量理解，除了以下几个特殊的符号：</p>
<p>:paramName – 匹配一段位于 /、? 或 # 之后的 URL。 命中的部分将被作为一个参数
() – 在它内部的内容被认为是可选的</p>
<ul>
<li>– 匹配任意字符（非贪婪的）直到命中下一个字符或者整个 URL 的末尾，并创建一个 splat 参数</li>
</ul>
<pre><code>&lt;Route path=&quot;/hello/:name&quot;&gt;         
// 匹配 /hello/michael 和 /hello/ryan
&lt;Route path=&quot;/hello(/:name)&quot;&gt;     
// 匹配 /hello, /hello/michael 和 /hello/ryan
&lt;Route path=&quot;/files/*.*&quot;&gt;          
// 匹配 /files/hello.jpg 和 /files/path/to/hello.jpg
</code></pre>
<p>使用绝对路径可以使路由匹配行为忽略嵌套关系</p>
<p>路由匹配规则是从上到下执行，一旦发现匹配，就不再其余的规则了。（同名路由只执行第一个）带参数的路径一般要写在路由规则的底部。</p>
<h2 id="4history">4.History</h2>
<p>React Router 是建立在 history 之上的。 简而言之，一个 history 知道如何去监听浏览器地址栏的变化， 并解析这个 URL 转化为 location 对象， 然后 router 使用它匹配到路由，最后正确地渲染对应的组件。</p>
<p>常用的 history 有三种形式， 但是你也可以使用 React Router 实现自定义的 history。</p>
<ol>
<li>browserHistory使用浏览器中的 History API 用于处理 URL，创建一个像example.com/some/path这样真实的 URL 。</li>
<li>hashHistory</li>
<li>createMemoryHistory</li>
</ol>
<h2 id="5重定向">5.重定向</h2>
<pre><code>&lt;Redirect&gt;组件用于路由的跳转，即用户访问一个路由，会自动跳转到另一个路由。
＜Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt;
现在访问/inbox/messages/5，会自动跳转到/messages/5。
IndexRedirect （2.x）IndexRoute（4.x）
组件用于访问根路由的时候，将用户重定向到某个子组件。
</code></pre>
<p>Link组件用于取代<a>元素，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是<a>元素的React 版本，可以接收Router的状态。</p>
<p>如果链接到根路由/，不要使用Link组件，而要使用IndexLink组件。</p>
<pre><code>&lt;IndexLink to=&quot;/&quot; activeClassName=&quot;active&quot;&gt;
  Home
&lt;/IndexLink&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue 零碎知识点]]></title>
        <id>https://alexwjj.github.io//post/vue-ling-sui-zhi-shi-dian</id>
        <link href="https://alexwjj.github.io//post/vue-ling-sui-zhi-shi-dian">
        </link>
        <updated>2019-06-05T11:20:35.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>vue 的一些零碎知识点整理</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>vue 的一些零碎知识点整理</p>
</blockquote>
<!-- more -->
<h2 id="1vue30">1.vue3.0</h2>
<pre><code>* 重写虚拟dom   编译运行时间更短
* 优化插槽生成 ： 3之前父组件重新渲染，子组件也会渲染。  vue3可以单独渲染某个组件
* 静态树提升：将静态组件提升，降低渲染成本
* 静态属性提升：跳过不会改变节点的补丁过程
* 基于proxy的观察者机制：Vue 的反应系统是使用 Object.defineProperty 的 getter 和 setter，Vue 3 将使用 ES2015 Proxy 作为其观察者机制。 这消除了以前存在的警告，使速度加倍，并节省了一半的内存开销。
* 更小：20kb&gt;10kb 
* 更具维护性： typescript
* 多平台使用，更易于开发
* 发布至少要到2019下半年了。
</code></pre>
<h2 id="2vue-mixins">2.vue mixins</h2>
<pre><code>* 用来更高效的实现组件内容的复用
* 可以在mixin对象里定义组件的任何属性，在组件使用mixin时，mixin中的属性会添加到组件属性中mixins: [myMixin],
* Vue混合策略 （可自定义）
* 1. vue 是安装 全局mixin——组件内mixin——组件options的顺序来合并组件实例的options。优先调用mixins和extends继承的父类，extends触发的优先级更高
* 2. 对于钩子函数（created() {} 和mounted() {}），会添加到一个函数数组里，执行顺序从前到后
* 3. 对于组件的对象属性（methods等）, 后面的会覆盖前面的
* mixins接收对象数组（可理解为多继承），extends接收的是对象或函数（可理解为单继承）
* 数据对象在内部会进行浅合并 (一层属性深度)，在和组件的数据发生冲突时以组件数据优先。
* 全局混入mixin  Vue.use( )
* extends触发的优先级更高 ,最先被调用
* 关于mixins和extend你可以理解为mvc的c(controller)，这一层。可见通用的成员变量（包括属性和方法）抽象成为一个父类，提供给子类继承，这样可以让子类拥有一些通用成员变量，然而子类也可以重写父类的成员变量。这样的整个编程思想就很面向对象，也就是继承性。
</code></pre>
<h2 id="3google搜索">3.Google搜索</h2>
<pre><code>* &quot; keywords &quot;，通过给关键字加双引号的方法，得到的搜索结果就是完全按照关键字的顺序来搜。
* keywords -GPS ， 搜索后的结果都没GPS关键字。
* 使用*进行模糊匹配
* 关键字 site:网址  指定网站中搜索
* 关键字 filetype:文件类型  搜索指定文件类型
</code></pre>
<h2 id="4vuedirective自定义指令">4.vue.directive自定义指令</h2>
<pre><code>* Vue.directive('xxx', function(el, bind, vNode){})
* 钩子函数： bind， inserted ，update ， componentUpdated ，unbind
* 钩子函数的参数 (包括 el，binding，vnode，oldVnode) 。
* 文档： http://doc.vue-js.com/v2/guide/custom-directive.html#search-query-sidebar
* v-pre   vue会跳过这个元素和它的子元素的编译过程。
</code></pre>
<h2 id="5vue-风格指南">5.vue 风格指南</h2>
<pre><code>* 组件名为多个单词   export组件时  TodoItem   注册时 todo-item
* 组件中的porp定义尽量详细，  eg： form: { type: Array  , required: true, default }  
* porp命名  props: {  greetingText: String}  &lt;WelcomeMessage greeting-text=&quot;hi&quot;/&gt;
* v-for 指定键值，v-for = ' (item, index) in todos'  :key = 'index'
* 避免v-for 和 v-if 一起使用 （v-for的优先级比v-if高，如果需要这种场景可以再computed中写filter）
* 组件样式设置作用域： 推荐使用BEM（c-Button--close  块-元素--功能），不推荐scoped
* 私有属性名： $_命名空间_类名
* 单文件组件文件大小写  MyComponent  my-component
* 组件名单词顺序：一般描述开头  描述修饰词结尾  SearchButtonClear.vue
* 组件名尽量都用完整的单词，表明功能性
* JS遵循  camelCase 驼峰法  HTML 遵循 kebab-case 短横线
* 组件中多个特性分行书写，便于维护
* 简单的计算放在{{ }}  复杂的放在计算属性中
* scoped原理vue为元素选择器添加一个独一无二的特性data-v-xxx，缺点是大量使用这种比较慢，没有使用类好
</code></pre>
<h2 id="6vue指令">6.vue指令</h2>
<pre><code>* v-pre   跳过这个元素和它的子元素的编译过程。可以用来显示原始 {{ }}标签。跳过大量没有指令的节点会加快编译。
* v-cloak 用法：这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕，否则在渲染页面时，有可能用户会先看到Mustache标签，然后看到编译后的数据
* v-once 只渲染元素和组件一次。随后的重新渲染,元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。
</code></pre>
<h2 id="7vue-provide-inject">7.vue provide / inject</h2>
<pre><code>* provide/inject：简单的来说就是在父组件中通过provide来提供变量，然后在子组件中通过inject来注入变量。主要为高阶插件/组件库提供用例
* provide 选项是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性
* inject 选项一个字符串数组，或一个对象
* provide 和 inject 绑定并不是可响应的  inject可以用解构来接受
* 场景：替代嵌套过深的props，以及祖先和后代的元素的通信中的vuex-bus的一个东西。
* 可以理解为一个bus，但只做祖先通知后代的单向传递的一个属性
* watch
* watch是一个对象，键是需要观察的表达式，值是对应回调函数
* 默认加载的时候先computed再watch，不执行methods；等触发某一事件后，则是：先methods再watch。
* watch可以直接监听computed里面的数据
</code></pre>
<h2 id="8nexttick">8.$nextTick</h2>
<pre><code>* nextTick 下一刻 
* nextTick 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。
* Vue.nextTick用于延迟执行一段代码，它接受2个参数（回调函数和执行回调函数的上下文环境），如果没有提供回调函数，那么将返回promise对象。
* 官方：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
* vue是异步执行DOM更新的：简单说：Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。
* 通过 Vue.nextTick 获取到改变后的 DOM 。 setTimeout(fn, 0) 也可以获取到。
* 应用场景：需要在视图更新之后，基于新的视图进行操作。
</code></pre>
<p><img src="https://alexwjj.github.io//post-images/1559733742027.jpeg" alt=""></p>
<h2 id="9数据劫持">9.数据劫持</h2>
<pre><code>* Vue （2.x）内部使用了 Object.defineProperty() 来实现双向绑定，通过这个函数可以监听到 set和 get 的事件。
* Proxy 与 Object.defineProperty 对比
* Object.defineProperty 虽然已经能够实现双向绑定了，但是他还是有缺陷的。
* 只能对属性进行数据劫持，所以需要深度遍历整个对象
* 对于数组不能监听到数据的变化
</code></pre>
<h2 id="10mvvm-由以下三个内容组成">10.MVVM 由以下三个内容组成</h2>
<pre><code>* View：界面
* Model：数据模型
* ViewModel：作为桥梁负责沟通 View 和 Model
在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持。
</code></pre>
<h2 id="11vue-router">11.vue-router</h2>
<pre><code>* history模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。
* 
* beforeEach主要有3个参数to，from，next：
* to：route即将进入的目标路由对象，
* from：route当前导航正要离开的路由
* next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。
</code></pre>
<h2 id="12vuex">12.vuex</h2>
<pre><code>* actions主要是来同时提交多个mutations
* mutation处理函数中所做的事情是改变state，而action处理函数中所做的事情则是commit mutation。
* 在触发方法上：
* action的触发是dispatch
* mutation的触发是commit；
* vue component—-dispatch—-&gt;actions—-commit—-&gt;mutations—-mutate—-&gt;state—-render—-&gt;vue component。
* 
* 在命名空间模块内访问全局内容（Global Assets）
* 如果你希望使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。
* someGetter (state, getters, rootState, rootGetters) {
*         getters.someOtherGetter // -&gt; 'foo/someOtherGetter'
*         rootGetters.someOtherGetter // -&gt; 'someOtherGetter'
*       },
* 
* 若需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给dispatch 或 commit即可
* dispatch('layout/setModuleName', 'organizationModule', { root: true });
* 
* vue如何监听键盘事件中的按键 @keyup.enter
</code></pre>
<h2 id="13vue组件中的data必须是函数">13.vue组件中的data必须是函数</h2>
<p>类比引用数据类型
Object是引用数据类型,如果不用function 返回,每个组件的data 都是内存的同一个地址,一个数据改变了其他也改变了;</p>
<p>javascipt只有函数构成作用域(注意理解作用域,只有函数的{}构成作用域,对象的{}以及 if(){}都不构成作用域)，data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立,不会相互影响</p>
<h2 id="14vue-mixin">14.vue mixin</h2>
<h2 id="15axios">15.axios</h2>
<pre><code>// 添加请求拦截器
axios.interceptors.request.use(function (config) {
    // 在发送请求之前做些什么
    return config;
  }, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
  });
// 添加响应拦截器
axios.interceptors.response.use(function (response) {
    // 对响应数据做点什么
    return response;
  }, function (error) {
    // 对响应错误做点什么
    return Promise.reject(error);
  });
</code></pre>
]]></content>
    </entry>
</feed>