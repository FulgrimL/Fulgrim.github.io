<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://alexwjj.github.io/</id>
    <title>俊劫、的前端博客</title>
    <updated>2019-06-06T08:38:14.711Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://alexwjj.github.io/"/>
    <link rel="self" href="https://alexwjj.github.io//atom.xml"/>
    <subtitle>讲个笑话，你可别哭。</subtitle>
    <logo>https://alexwjj.github.io//images/avatar.png</logo>
    <icon>https://alexwjj.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 俊劫、的前端博客</rights>
    <entry>
        <title type="html"><![CDATA[React]]></title>
        <id>https://alexwjj.github.io//post/react</id>
        <link href="https://alexwjj.github.io//post/react">
        </link>
        <updated>2019-06-06T08:36:37.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>react 入门知识点</p>
</blockquote>
<blockquote>
<p>对比着 Vue来看的</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>react 入门知识点</p>
</blockquote>
<blockquote>
<p>对比着 Vue来看的</p>
</blockquote>
<!-- more -->
<h2 id="入门">入门</h2>
<pre><code>* 使用jsx语法， script的属性 type = 'text / babel'
* 组件类的第一个字母必须大写，否则会报错，比如HelloMessage不能写成helloMessage。另外，组件类只能包含一个顶层标签，否则也会报错。
* 添加组件属性，有一个地方需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。
* this.props.children 的值有三种可能：如果当前组件没有子节点，它就是 undefined ;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array 。所以，处理 this.props.children 的时候要小心。
* React 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。
* 组件类的PropTypes属性，就是用来验证组件实例的属性是否符合要求，getDefaultProps 方法可以用来设置组件属性的默认值。
* 由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。
* 文本输入框的值，不能用 this.props.value 读取，而要定义一个 onChange 事件的回调函数，通过 event.target.value 读取用户输入的值。textarea 元素、select元素、radio元素都属于这种情况
* 组件生命周期三种状态：Mounting，Updating（正在重新被渲染），Unmounting。React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。componentWillMount() componentDidMount()
* 组件样式：style={{opacity: this.state.opacity}}，因为 React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样
</code></pre>
<h2 id="注意点">注意点</h2>
<pre><code>* getInitialState  初始化数据
* bind(this) 防止this指向错误 ，不写的话可以使用属性初始化和箭头函数（组件会重新渲染，不建议使用）。官方建议使用bind和属性初始化
* &quot; 字符串 &quot;     { 表达式 }
* onClick={activateLasers} 事件。在 React 中你不能使用返回 false 的方式阻止默认行为。你必须明确的使用 preventDefault
* 在 JavaScript 中，true &amp;&amp; expression 总是返回 expression，而 false &amp;&amp; expression 总是返回 false。如下条件判断
* {unreadMessages.length &gt; 0 &amp;&amp;
*         &lt;h2&gt;
*           You have {unreadMessages.length} unread messages.
*         &lt;/h2&gt;
*       }
* 防止组件渲染 return null
* 如果你选择不指定显式的键值，那么React将默认使用索引用（index）作为列表项目的键值。元素位于map()方法内时需要设置键属性
* 在HTML当中，像&lt;input&gt;,&lt;textarea&gt;, 和 &lt;select&gt;这类表单元素会维持自身状态，并根据用户输入进行更新。他们都通过传入一个value属性来实现对组件的控制。
*   组件嵌套{ props.children }          {props.left}  left = { &lt;assembly/&gt;}   
* 如果你不初始化状态，也不绑定方法，那么你就不需要为React组件实现构造函数。不需要constructor 
* 如果子类加入了 constructor 构造函数，则一定要手动调用父类的构造函数 super
</code></pre>
<h2 id="react生命周期">React生命周期</h2>
<pre><code>mount
1.constructor
初始化state和绑定事件处理程序
2.static getDerivedStateFromProps()
可以更新state的状态，派生状态。小心使用
3.render
不渲染任何内容，返回布尔值或者null
4.componentDidMount()
render之后，挂载完成，调用该方法。一般写发送请求的

update
1.static getDerivedStateFromProps()
2.shouldComponentUpdate()  性能优化点
在调用 static getDerivedStateFromProps 方法之后，接下来会调用 nextComponentUpdate 方法。通过调用shouldComponentUpdate来控制是否要重新渲染组件
3.reder()
4.getSnapshotBeforeUpdate()
5.componentDidUpdate()

unMount
1.componentWillUnmount()
资源清理

error
1.static getDerivedStateFromError()
2.componentDidCatch()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node 入门]]></title>
        <id>https://alexwjj.github.io//post/node-ru-men</id>
        <link href="https://alexwjj.github.io//post/node-ru-men">
        </link>
        <updated>2019-06-05T11:32:58.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>跟着《七天学会 nodejs》文档走了一遍</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>跟着《七天学会 nodejs》文档走了一遍</p>
</blockquote>
<!-- more -->
<h2 id="1基础概念">1.基础概念</h2>
<pre><code>* 创建node应用：1.require（） 2.创建服务器  3.接受请求和响应请求
* REPL 交互式解释器 ： 读取，执行，打印，循环 Read–eval–print loop 可以直接运行各种JavaScript命令  _ + 1   下划线表示上一个命令的结果
* node事件驱动模型：当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。高并发
* node内置事件：events
* Buffer 缓冲区   node类  该类用来创建一个专门存放二进制数据的缓存区。
* 如果想要拷贝一份Buffer，得首先创建一个新的Buffer，并通过.copy方法把原Buffer中的数据复制过去。
* Buffer与字符串有一个重要区别。字符串是只读的，并且对字符串的任何修改得到的都是一个新字符串，原字符串保持不变。至于Buffer,可以用[index]方式直接修改某个位置的字节
* Node约定，如果某个函数需要回调函数作为参数，则回调函数是最后一个参数。另外，回调函数本身的第一个参数，约定为上一步传入的错误对象。callback = function （error，value） {}
* require命令用于指定加载模块，加载时可以省略脚本文件的后缀名
* PM2是Node.js应用程序的进程管理器
* NodeJS允许通过NODE_PATH环境变量来指定额外的模块搜索路径。
* stream 当内存中无法一次装下需要处理的数据时，或者一边读取一边处理更加高效时，我们就需要用到数据流。
</code></pre>
<h2 id="3node全局对象-全局函数-全局变量">3.Node全局对象 &amp;&amp; 全局函数 &amp;&amp; 全局变量</h2>
<pre><code>* global：表示Node所在的全局环境，类似于浏览器的window对象
* process：该对象表示Node所处的当前进程，允许开发者与该进程互动。
* console：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。
* setTimeout()：用于在指定毫秒之后，运行回调函数。
* clearTimeout()：用于终止一个setTimeout方法新建的定时器。
* setInterval()：用于每隔一定毫秒调用回调函数。
* clearInterval()：终止一个用setInterval方法新建的定时器。
* require()：用于加载模块。
* Buffer()：用于操作二进制数据。
* __filename：指向当前运行的脚本文件名。
* __dirname：指向当前运行的脚本所在的目录。
</code></pre>
<h2 id="4node核心模块">4.Node核心模块</h2>
<pre><code>* 核心模块总是最优先加载的
* http：提供HTTP服务器功能。
* url：解析URL。
* fs：与文件系统交互。
* querystring：解析URL的查询字符串。
* child_process：新建子进程。
* util：提供一系列实用小工具。
* path：处理文件路径。
* crypto：提供加密和解密功能，基本上是对OpenSSL的包装。
</code></pre>
<h2 id="5模块使用的简单例子">5.模块使用的简单例子</h2>
<pre><code>foo.js module.exports = function( x ) { console.log( x) }
index.js  var m = require( './foo.js' )   m('面对疾风吧')
node index.js   面对疾风吧!
</code></pre>
<h2 id="6node-异常处理">6.Node 异常处理</h2>
<pre><code>* Node是单线程运行环境，一旦抛出的异常没有被捕获，就会引起整个进程的崩溃。一般处理错误有下面三种方法：
* 使用throw语句抛出一个错误对象，即抛出异常。
* 将错误对象传递给回调函数，由回调函数负责发出错误。
* 通过EventEmitter接口，发出一个error事件。
* eg：fs.readFile('/foo.txt', function(err, data) {
*   if (err !== null) throw err;
*   console.log(data);
* });
* 当一个异常未被捕获，就会触发uncaughtException事件，可以对这个事件注册回调函数，从而捕获异常。
* iojs有一个unhandledRejection事件，用来监听没有捕获的Promise对象的rejected状态。
</code></pre>
<h2 id="7版本号">7.版本号</h2>
<p>语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。</p>
<pre><code>+ 如果只是修复bug，需要更新Z位。
+ 如果是新增了功能，但是向下兼容，需要更新Y位。
+ 如果有大变动，向下不兼容，需要更新X位。
</code></pre>
<h2 id="8文件操作">8.文件操作</h2>
<h3 id="fs文件系统">fs文件系统</h3>
<pre><code>* 文件属性读写。fs.stat、fs.chmod、fs.chown等等
* 文件内容读写。fs.readFile、fs.readdir、fs.writeFile、fs.mkdir等等
* 底层文件操作。fs.open、fs.read、fs.write、fs.close等等
* 小文件拷贝：fs.readFileSync     fs.writeFileSync
* 大文件拷贝：fs.createReadStream     fs.createWriteStream
* ipe方法把两个数据流连接了起来。
</code></pre>
<h3 id="path">path</h3>
<pre><code>path.normalize 将传入的路径转换为标准路径，具体讲的话，除了解析路径中的.与..外，还能去掉多余的斜杠。
**坑出没注意**： 标准化之后的路径里的斜杠在Windows系统下是\，而在Linux系统下是/。如果想保证任何系统下都使用/作为路径分隔符的话，需要用.replace(/\\/g, '/')再替换一下标准路径。
path.join 将传入的多个路径拼接为标准路径。
path.extname 当我们需要根据不同文件扩展名做不同操作时
</code></pre>
<h3 id="遍历">遍历</h3>
<pre><code>遍历算法： 深度优先 + 先序遍历
同步遍历
异步遍历
</code></pre>
<h3 id="文本编码">文本编码</h3>
<pre><code>我们常用的文本编码有UTF8和GBK两种，并且UTF8文件还可能带有BOM。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的UTF8编码字符串后才能正常处理。
BOM移除：通过文本文件的头几个字符判断是否存在BOM，存在则移除
GBK转UTF8 ：node不支持GBK，可以通过npm包iconv-lite来转换
单字节编码：当我们需要处理的字符在ASCII 0-128时，使用单字节编码。不需要考虑GBK或者UTF8
</code></pre>
<h3 id="网络操作">网络操作</h3>
<p>创建一个HTTP的web服务器</p>
<pre><code>var http = require('http');
http.createServer(function (request, response) {
    response.writeHead(200, { 'Content-Type': 'text-plain' });
    response.end('Hello World\n');
}).listen(8124);
创建一个HTTPS的web服务器
var options = {
        key: fs.readFileSync('./ssl/default.key'),
        cert: fs.readFileSync('./ssl/default.cer')
    };
var server = https.createServer(options, function (request, response) {
        // ...
    });
</code></pre>
<h3 id="http-https">HTTP &amp; HTTPS</h3>
<pre><code>* HTTP请求本质上是一个数据流，由请求头（headers）和请求体（body）组成。
* HTTP请求在发送给服务器时，可以认为是按照从头到尾的顺序一个字节一个字节地以数据流方式发送的。而http模块创建的HTTP服务器在接收到完整的请求头后，就会调用回调函数。
* https模块与http模块极为类似，区别在于https模块需要额外处理SSL证书。
* 目标服务器使用的SSL证书是自制的，https模块会拒绝连接，在options里加入rejectUnauthorized: false字段可以禁用对证书有效性的检查
</code></pre>
<h3 id="url">URL</h3>
<pre><code>一个url的基本组成
 http: // user:pass @ host.com : 8080 /p/a/t/h ?query=string #hash
 -----        ---------         --------       ----    --------    -------------      -----
protocol     auth        hostname   port   pathname search       hash
我们可以使用.parse方法来将一个URL字符串转换为URL对象 键值对形式
.parse方法还支持第二个和第三个布尔类型可选参数。第二个参数等于true时，该方法返回的URL对象中，query字段不再是一个字符串，而是一个经过querystring模块转换后的参数对象。第三个参数等于true时，该方法可以正确解析不带协议头的URL
format方法允许将一个URL对象转换为URL字符串
.resolve方法可以用于拼接URL，url.resolve('http://www.example.com/foo/bar', '../baz');
querystring模块用于实现URL参数字符串与参数对象的互相转换
querystring.parse         querystring.stringify
</code></pre>
<h3 id="zlib">Zlib</h3>
<p>zlib模块提供了数据压缩和解压的功能。当我们处理HTTP请求和响应时，可能需要用到这个模块。</p>
<h3 id="net">Net</h3>
<p>net模块可用于创建Socket服务器或Socket客户端。</p>
<h2 id="9进程管理">9.进程管理</h2>
<h3 id="1process">1.process</h3>
<p>process一个全局对象，在任何地方都可以直接使用。</p>
<h3 id="2child-process">2.child process</h3>
<p>使用child_process模块可以创建和控制子进程。该模块提供的API中最核心的是.spawn，其余API都是针对特定使用场景对它的进一步封装，算是一种语法糖。</p>
<h3 id="3cluter">3.cluter</h3>
<p>cluster模块是对child_process模块的进一步封装，专用于解决单进程NodeJS Web服务器无法充分利用多核CPU的问题</p>
<h3 id="4应用场景">4.应用场景</h3>
<pre><code>* process.argv 获取命令行参数 ，第一个命令行参数从argv[2] 开始。可以自己处理
* process.exit(1) 退出程序
* NodeJS程序的标准输入流（stdin）、一个标准输出流（stdout）、一个标准错误流（stderr）分别对应process.stdin、process.stdout和process.stderr
* 降权: Linux 使用root权限才能监听1024以下端口，完成端口监听安全考虑要把权限降下来，process.setgid(gid)   process.setuid(uid) 降权时必须先降GID再降UID
</code></pre>
<h3 id="5创建子进程">5.创建子进程</h3>
<p><code>var child = child_process.spawn('node', [ 'xxx.js' ]);</code>
<code>.spawn(exec, args, options)</code>方法，第一个参数是执行文件路径，第二个参数中，数组中的每个成员都按顺序对应一个命令行参数。第三个参数可选，用于配置子进程的执行环境与行为。</p>
<h3 id="6进程之间的通讯">6.进程之间的通讯</h3>
<p>父进程通过.kill方法向子进程发送SIGTERM信号，子进程监听process对象的SIGTERM事件响应信号
如果父子进程都是NodeJS进程，就可以通过IPC（进程间通讯）双向传递数据。</p>
<h3 id="7守护子进程">7.守护子进程</h3>
<p>守护进程一般用于监控工作进程的运行状态，在工作进程不正常退出时重启工作进程，保障工作进程不间断运行。</p>
<pre><code>worker.on('exit', function (code) {
        if (code !== 0) {
            spawn(mainModule);
        }
    });
</code></pre>
<p>工作进程非正常退出时，守护进程立即重启工作进程。</p>
<h2 id="10异步编程">10.异步编程</h2>
<h3 id="1回调">1.回调</h3>
<p>JS本身是单线程的，无法异步执行</p>
<p>setTimeout这类JS规范之外的由运行环境提供的特殊函数做的事情是创建一个平行线程后立即返回，让JS主进程可以接着执行后续代码，并在收到平行进程的通知后再执行回调函数。除了setTimeout、
setInterval这些常见的，这类函数还包括NodeJS提供的诸如fs.readFile之类的异步API。</p>
<p>JS自身提供的异常捕获和处理机制——try..catch..，只能用于同步执行的代码。</p>
<h3 id="2域domain">2.域（Domain）</h3>
<p>NodeJS提供了domain模块，可以简化异步代码的异常处理。简单的讲，一个域就是一个JS运行环境，在一个运行环境中，如果一个异常没有被捕获，将作为一个全局异常被抛出。NodeJS通过process对象提供了捕获全局异常的方法</p>
<pre><code>var d = domain.create();
d.on
d.run
</code></pre>
<p>无论是通过process对象的uncaughtException事件捕获到全局异常，还是通过子域对象的error事件捕获到了子域异常，在NodeJS官方文档里都强烈建议处理完异常后立即重启程序，发生异常后的程序处于一个不确定的运行状态，如果不立即退出的话，程序可能会发生严重内存泄漏，也可能表现得很奇怪。</p>
<h2 id="11socket">11.Socket</h2>
<h3 id="1tcp-ip">1.TCP / IP</h3>
<p>TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议</p>
<p>TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中</p>
<pre><code>* 应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等
* 传输层：TCP，UDP
* 网络层：IP，ICMP，OSPF，EIGRP，IGMP
* 数据链路层：SLIP，CSLIP，PPP，MTU
</code></pre>
<h3 id="2socket">2.socket</h3>
<p>socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用以实现进程在网络中通信。</p>
<p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，ip地址＋协议＋端口号唯一标示网络中的一个进程。   三端socket是一种&quot;打开—读/写—关闭&quot;模式的实现。服务器socket与客户端socket建立连接的部分其实就是大名鼎鼎的三次握手
<code>Scoket api ： scoket ， bind ， listen， connect， accept， read ，write，close</code></p>
<h3 id="3websocket">3.websocket</h3>
<pre><code>WebSocket是一种在单个TCP连接上进行全双工通信的协议。
HTTP 协议做不到服务器主动向客户端推送信息。
默认端口80 和 443
没有同源限制，客户端可以与任意服务器通信
协议标识符：ws ， wss（加密的） 
创建：var ws = new WebSocket('ws://localhost:8080');
webSocket.readyState()
readyState属性返回实例对象的当前状态，共有四种：
CONNECTING：值为0，表示正在连接。
OPEN：值为1，表示连接成功，可以通信了。
CLOSING：值为2，表示连接正在关闭。
CLOSED：值为3，表示连接已经关闭，或者打开连接失败
 webSocket.onopen()
实例对象的onopen属性，用于指定连接成功后的回调函数。
如果要指定多个回调函数，可以使用addEventListener方法。
webSocket.onclose()
实例对象的onclose属性，用于指定连接关闭后的回调函数。
webSocket.onmessage()
实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。
 webSocket.send()
实例对象的send()方法用于向服务器发送数据。
webSocket.bufferedAmount()
实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。
webSocket.onerror()
实例对象的onerror属性，用于指定报错时的回调函数
webscoket数据传递
数据分片传输，根据FIN的值来判断，FIN=1表示当前数据帧为最后一个数据帧，FIN=0，还需要继续监听其他数据帧
</code></pre>
<p><img src="https://alexwjj.github.io//post-images/1559734484836.jpeg" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redux]]></title>
        <id>https://alexwjj.github.io//post/redux</id>
        <link href="https://alexwjj.github.io//post/redux">
        </link>
        <updated>2019-06-05T11:31:18.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>对比 VueX 总结 Redux 的简单使用方法</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>对比 VueX 总结 Redux 的简单使用方法</p>
</blockquote>
<!-- more -->
<h2 id="1方式">1.方式</h2>
<p>应用中所有的 state 都以一个对象树的形式储存在一个单一的 store 中。 惟一改变 state 的办法是触发 action，一个描述发生什么的对象。 为了描述 action 如何改变 state 树，你需要编写 reducers。</p>
<h2 id="2三大原则">2.三大原则</h2>
<p>1.单一数据源</p>
<p>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</p>
<p>2.State 是只读的</p>
<p>唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</p>
<p>3.使用纯函数来执行修改</p>
<p>为了描述 action 如何改变 state tree ，你需要编写 reducers；Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state。</p>
<h2 id="3基础">3.基础</h2>
<h3 id="action">Action</h3>
<p>Action 是把数据从应用传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。</p>
<p>action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action。</p>
<p><code>import { ADD_TODO, REMOVE_TODO } from '../actionTypes'</code></p>
<p>最后，再添加一个 action type 来表示当前的任务展示选项。</p>
<pre><code>{
  type: SET_VISIBILITY_FILTER,
  filter: SHOW_COMPLETED
}
</code></pre>
<p>store 里能直接通过 store.dispatch() 调用 dispatch() 方法，但是多数情况下你会使用 react-redux提供的 connect() 帮助器来调用。bindActionCreators() 可以自动把多个 action 创建函数 绑定到 dispatch() 方法上。</p>
<h3 id="reducer">Reducer</h3>
<h3 id="定义">定义</h3>
<p>Reducers 指定了应用状态的变化如何响应 actions 并发送到 store 的，记住 actions 只是描述了有事情发生了这一事实，并没有描述应用如何更新 state。</p>
<p>之所以将这样的函数称之为reducer，是因为这种函数与被传入 Array.prototype.reduce(reducer, ?initialValue) 里的回调函数属于相同的类型。</p>
<h3 id="注意">注意</h3>
<p>1.不要修改 state。 使用 Object.assign() 新建了一个副本。不能这样使用 Object.assign(state, { visibilityFilter: action.filter })，因为它会改变第一个参数的值。你必须把第一个参数设置为空对象。这样写return Object.assign({}, state,{visibilityFilter: action.filter})</p>
<p>2.在 default 情况下返回旧的 state。遇到未知的 action 时，一定要返回旧的 state。</p>
<h3 id="reducer分类">Reducer分类</h3>
<p>每个 reducer 只负责管理全局 state 中它负责的一部分。每个 reducer 的 state 参数都不同，分别对应它管理的那部分 state 数据。</p>
<pre><code>function todoApp(state = {}, action) {
  return {
    visibilityFilter: visibilityFilter(state.visibilityFilter, action),
    todos: todos(state.todos, action)
  }
}
</code></pre>
<p>Redux 提供了 combineReducers() 工具类来做上面 todoApp 做的事情，这样就能消灭一些样板代码了。有了它，可以这样重构 todoApp</p>
<pre><code>const todoApp = combineReducers({
  visibilityFilter,
  todos
})
</code></pre>
<h3 id="store">Store</h3>
<p>Store 就是把它们联系到一起的对象。Store 有以下职责：</p>
<pre><code>* 维持应用的 state；
* 提供 getState() 方法获取 state；
* 提供 dispatch(action) 方法更新 state；
* 通过 subscribe(listener) 注册监听器;
* 通过 subscribe(listener) 返回的函数注销监听器。
* createStore() 的第二个参数是可选的, 用于设置 state 初始状态。
</code></pre>
<h3 id="单向数据流">单向数据流</h3>
<p>Redux 应用中数据的生命周期遵循下面 4 个步骤：</p>
<p>1.调用 store.dispatch(action)。</p>
<p>2.Redux store 调用传入的 reducer 函数。Store 会把两个参数传入 reducer： 当前的 state 树和 action。</p>
<p>3.根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。Redux 原生提供combineReducers()辅助函数，来把根 reducer 拆分成多个函数，用于分别处理 state 树的一个分支。</p>
<p>4.Redux store 保存了根 reducer 返回的完整 state 树。</p>
<h3 id="react-redux">React + Redux</h3>
<h3 id="容器组件">容器组件</h3>
<p>容器组件就是使用 store.subscribe() 从 Redux state 树中读取部分数据，并通过 props 来把这些数据提供给要渲染的组件</p>
<p>建议使用 React Redux 库的 connect() 方法来生成，这个方法做了性能优化来避免很多不必要的重复渲染。</p>
<p>使用 connect() 前，需要先定义 mapStateToProps 这个函数来指定如何把当前 Redux store state 映射到展示组件的 props 中</p>
<h3 id="传入store">传入store</h3>
<p>所有容器组件都可以访问 Redux store，所以可以手动监听它。一种方式是把它以 props 的形式传入到所有容器组件中。</p>
<p>建议的方式是使用指定的 React Redux 组件 <Provider> 来 魔法般的 让所有容器组件都可以访问 store，而不必显示地传递它。只需要在渲染根组件时使用即可。</p>
<pre><code>render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  document.getElementById('root')
)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React router]]></title>
        <id>https://alexwjj.github.io//post/react-router</id>
        <link href="https://alexwjj.github.io//post/react-router">
        </link>
        <updated>2019-06-05T11:29:13.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>对比 vue router 看react router官方文档总结</p>
</blockquote>
<blockquote>
<p>比较基础</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>对比 vue router 看react router官方文档总结</p>
</blockquote>
<blockquote>
<p>比较基础</p>
</blockquote>
<!-- more -->
<h2 id="1使用时路由器router就是react的一个组件">1.使用时，路由器Router就是React的一个组件。</h2>
<pre><code>React.render((
  &lt;Router&gt;
    &lt;Route path=&quot;/&quot; component={App}&gt;
      &lt;Route path=&quot;about&quot; component={About} /&gt;
      &lt;Route path=&quot;inbox&quot; component={Inbox}&gt;
        &lt;Route path=&quot;messages/:id&quot; component={Message} /&gt;
      &lt;/Route&gt;
    &lt;/Route&gt;
  &lt;/Router&gt;
), document.body)
</code></pre>
<p>IndexRoute解决App组件中this.porps.children为undefined时的问题，显式指定Home是根路由的子组件，即指定默认情况下加载的子组件。你可以把IndexRoute想象成某个路径的index.html。</p>
<pre><code>&lt;Router&gt;
  &lt;Route path=&quot;/&quot; component={App}&gt;
    &lt;IndexRoute component={Home}/&gt;
    &lt;Route path=&quot;accounts&quot; component={Accounts}/&gt;
    &lt;Route path=&quot;statements&quot; component={Statements}/&gt;
  &lt;/Route&gt;
&lt;/Router&gt;
</code></pre>
<p>渲染：访问 /</p>
<pre><code>&lt;App&gt;
  &lt;Home/&gt;
&lt;/App&gt;
</code></pre>
<p>如果我们可以将 /inbox 从 /inbox/messages/:id 中去除，并且还能够让 Message 嵌套在 App -&gt;Inbox 中渲染</p>
<pre><code>* 绝对路径{/* 使用 /messages/:id 替换 messages/:id */}
* &lt;Route path=&quot;/messages/:id&quot; component={Message} /&gt;
* 路由跳转{/* 跳转 /inbox/messages/:id 到 /messages/:id */}
* &lt;Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt;
</code></pre>
<p>2.Route 可以定义 onEnter 和 onLeave 两个 hook ，这些hook会在页面跳转确认时触发一次</p>
<p>onLeave （内到外）从最下层的子路由开始直到最外层父路由结束。然后onEnter（外到内）会从最外层的父路由开始直到最下层子路由结束。</p>
<p>3.路由路径是匹配一个（或一部分）URL 的 一个字符串模式。大部分的路由路径都可以直接按照字面量理解，除了以下几个特殊的符号：</p>
<p>:paramName – 匹配一段位于 /、? 或 # 之后的 URL。 命中的部分将被作为一个参数
() – 在它内部的内容被认为是可选的</p>
<ul>
<li>– 匹配任意字符（非贪婪的）直到命中下一个字符或者整个 URL 的末尾，并创建一个 splat 参数</li>
</ul>
<pre><code>&lt;Route path=&quot;/hello/:name&quot;&gt;         
// 匹配 /hello/michael 和 /hello/ryan
&lt;Route path=&quot;/hello(/:name)&quot;&gt;     
// 匹配 /hello, /hello/michael 和 /hello/ryan
&lt;Route path=&quot;/files/*.*&quot;&gt;          
// 匹配 /files/hello.jpg 和 /files/path/to/hello.jpg
</code></pre>
<p>使用绝对路径可以使路由匹配行为忽略嵌套关系</p>
<p>路由匹配规则是从上到下执行，一旦发现匹配，就不再其余的规则了。（同名路由只执行第一个）带参数的路径一般要写在路由规则的底部。</p>
<h2 id="4history">4.History</h2>
<p>React Router 是建立在 history 之上的。 简而言之，一个 history 知道如何去监听浏览器地址栏的变化， 并解析这个 URL 转化为 location 对象， 然后 router 使用它匹配到路由，最后正确地渲染对应的组件。</p>
<p>常用的 history 有三种形式， 但是你也可以使用 React Router 实现自定义的 history。</p>
<ol>
<li>browserHistory使用浏览器中的 History API 用于处理 URL，创建一个像example.com/some/path这样真实的 URL 。</li>
<li>hashHistory</li>
<li>createMemoryHistory</li>
</ol>
<h2 id="5重定向">5.重定向</h2>
<pre><code>&lt;Redirect&gt;组件用于路由的跳转，即用户访问一个路由，会自动跳转到另一个路由。
＜Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt;
现在访问/inbox/messages/5，会自动跳转到/messages/5。
IndexRedirect （2.x）IndexRoute（4.x）
组件用于访问根路由的时候，将用户重定向到某个子组件。
</code></pre>
<p>Link组件用于取代<a>元素，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是<a>元素的React 版本，可以接收Router的状态。</p>
<p>如果链接到根路由/，不要使用Link组件，而要使用IndexLink组件。</p>
<pre><code>&lt;IndexLink to=&quot;/&quot; activeClassName=&quot;active&quot;&gt;
  Home
&lt;/IndexLink&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue 零碎知识点]]></title>
        <id>https://alexwjj.github.io//post/vue-ling-sui-zhi-shi-dian</id>
        <link href="https://alexwjj.github.io//post/vue-ling-sui-zhi-shi-dian">
        </link>
        <updated>2019-06-05T11:20:35.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>vue 的一些零碎知识点整理</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>vue 的一些零碎知识点整理</p>
</blockquote>
<!-- more -->
<h2 id="1vue30">1.vue3.0</h2>
<pre><code>* 重写虚拟dom   编译运行时间更短
* 优化插槽生成 ： 3之前父组件重新渲染，子组件也会渲染。  vue3可以单独渲染某个组件
* 静态树提升：将静态组件提升，降低渲染成本
* 静态属性提升：跳过不会改变节点的补丁过程
* 基于proxy的观察者机制：Vue 的反应系统是使用 Object.defineProperty 的 getter 和 setter，Vue 3 将使用 ES2015 Proxy 作为其观察者机制。 这消除了以前存在的警告，使速度加倍，并节省了一半的内存开销。
* 更小：20kb&gt;10kb 
* 更具维护性： typescript
* 多平台使用，更易于开发
* 发布至少要到2019下半年了。
</code></pre>
<h2 id="2vue-mixins">2.vue mixins</h2>
<pre><code>* 用来更高效的实现组件内容的复用
* 可以在mixin对象里定义组件的任何属性，在组件使用mixin时，mixin中的属性会添加到组件属性中mixins: [myMixin],
* Vue混合策略 （可自定义）
* 1. vue 是安装 全局mixin——组件内mixin——组件options的顺序来合并组件实例的options。优先调用mixins和extends继承的父类，extends触发的优先级更高
* 2. 对于钩子函数（created() {} 和mounted() {}），会添加到一个函数数组里，执行顺序从前到后
* 3. 对于组件的对象属性（methods等）, 后面的会覆盖前面的
* mixins接收对象数组（可理解为多继承），extends接收的是对象或函数（可理解为单继承）
* 数据对象在内部会进行浅合并 (一层属性深度)，在和组件的数据发生冲突时以组件数据优先。
* 全局混入mixin  Vue.use( )
* extends触发的优先级更高 ,最先被调用
* 关于mixins和extend你可以理解为mvc的c(controller)，这一层。可见通用的成员变量（包括属性和方法）抽象成为一个父类，提供给子类继承，这样可以让子类拥有一些通用成员变量，然而子类也可以重写父类的成员变量。这样的整个编程思想就很面向对象，也就是继承性。
</code></pre>
<h2 id="3google搜索">3.Google搜索</h2>
<pre><code>* &quot; keywords &quot;，通过给关键字加双引号的方法，得到的搜索结果就是完全按照关键字的顺序来搜。
* keywords -GPS ， 搜索后的结果都没GPS关键字。
* 使用*进行模糊匹配
* 关键字 site:网址  指定网站中搜索
* 关键字 filetype:文件类型  搜索指定文件类型
</code></pre>
<h2 id="4vuedirective自定义指令">4.vue.directive自定义指令</h2>
<pre><code>* Vue.directive('xxx', function(el, bind, vNode){})
* 钩子函数： bind， inserted ，update ， componentUpdated ，unbind
* 钩子函数的参数 (包括 el，binding，vnode，oldVnode) 。
* 文档： http://doc.vue-js.com/v2/guide/custom-directive.html#search-query-sidebar
* v-pre   vue会跳过这个元素和它的子元素的编译过程。
</code></pre>
<h2 id="5vue-风格指南">5.vue 风格指南</h2>
<pre><code>* 组件名为多个单词   export组件时  TodoItem   注册时 todo-item
* 组件中的porp定义尽量详细，  eg： form: { type: Array  , required: true, default }  
* porp命名  props: {  greetingText: String}  &lt;WelcomeMessage greeting-text=&quot;hi&quot;/&gt;
* v-for 指定键值，v-for = ' (item, index) in todos'  :key = 'index'
* 避免v-for 和 v-if 一起使用 （v-for的优先级比v-if高，如果需要这种场景可以再computed中写filter）
* 组件样式设置作用域： 推荐使用BEM（c-Button--close  块-元素--功能），不推荐scoped
* 私有属性名： $_命名空间_类名
* 单文件组件文件大小写  MyComponent  my-component
* 组件名单词顺序：一般描述开头  描述修饰词结尾  SearchButtonClear.vue
* 组件名尽量都用完整的单词，表明功能性
* JS遵循  camelCase 驼峰法  HTML 遵循 kebab-case 短横线
* 组件中多个特性分行书写，便于维护
* 简单的计算放在{{ }}  复杂的放在计算属性中
* scoped原理vue为元素选择器添加一个独一无二的特性data-v-xxx，缺点是大量使用这种比较慢，没有使用类好
</code></pre>
<h2 id="6vue指令">6.vue指令</h2>
<pre><code>* v-pre   跳过这个元素和它的子元素的编译过程。可以用来显示原始 {{ }}标签。跳过大量没有指令的节点会加快编译。
* v-cloak 用法：这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕，否则在渲染页面时，有可能用户会先看到Mustache标签，然后看到编译后的数据
* v-once 只渲染元素和组件一次。随后的重新渲染,元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。
</code></pre>
<h2 id="7vue-provide-inject">7.vue provide / inject</h2>
<pre><code>* provide/inject：简单的来说就是在父组件中通过provide来提供变量，然后在子组件中通过inject来注入变量。主要为高阶插件/组件库提供用例
* provide 选项是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性
* inject 选项一个字符串数组，或一个对象
* provide 和 inject 绑定并不是可响应的  inject可以用解构来接受
* 场景：替代嵌套过深的props，以及祖先和后代的元素的通信中的vuex-bus的一个东西。
* 可以理解为一个bus，但只做祖先通知后代的单向传递的一个属性
* watch
* watch是一个对象，键是需要观察的表达式，值是对应回调函数
* 默认加载的时候先computed再watch，不执行methods；等触发某一事件后，则是：先methods再watch。
* watch可以直接监听computed里面的数据
</code></pre>
<h2 id="8nexttick">8.$nextTick</h2>
<pre><code>* nextTick 下一刻 
* nextTick 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。
* Vue.nextTick用于延迟执行一段代码，它接受2个参数（回调函数和执行回调函数的上下文环境），如果没有提供回调函数，那么将返回promise对象。
* 官方：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
* vue是异步执行DOM更新的：简单说：Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。
* 通过 Vue.nextTick 获取到改变后的 DOM 。 setTimeout(fn, 0) 也可以获取到。
* 应用场景：需要在视图更新之后，基于新的视图进行操作。
</code></pre>
<p><img src="https://alexwjj.github.io//post-images/1559733742027.jpeg" alt=""></p>
<h2 id="9数据劫持">9.数据劫持</h2>
<pre><code>* Vue （2.x）内部使用了 Object.defineProperty() 来实现双向绑定，通过这个函数可以监听到 set和 get 的事件。
* Proxy 与 Object.defineProperty 对比
* Object.defineProperty 虽然已经能够实现双向绑定了，但是他还是有缺陷的。
* 只能对属性进行数据劫持，所以需要深度遍历整个对象
* 对于数组不能监听到数据的变化
</code></pre>
<h2 id="10mvvm-由以下三个内容组成">10.MVVM 由以下三个内容组成</h2>
<pre><code>* View：界面
* Model：数据模型
* ViewModel：作为桥梁负责沟通 View 和 Model
在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持。
</code></pre>
<h2 id="11vue-router">11.vue-router</h2>
<pre><code>* history模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。
* 
* beforeEach主要有3个参数to，from，next：
* to：route即将进入的目标路由对象，
* from：route当前导航正要离开的路由
* next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。
</code></pre>
<h2 id="12vuex">12.vuex</h2>
<pre><code>* actions主要是来同时提交多个mutations
* mutation处理函数中所做的事情是改变state，而action处理函数中所做的事情则是commit mutation。
* 在触发方法上：
* action的触发是dispatch
* mutation的触发是commit；
* vue component—-dispatch—-&gt;actions—-commit—-&gt;mutations—-mutate—-&gt;state—-render—-&gt;vue component。
* 
* 在命名空间模块内访问全局内容（Global Assets）
* 如果你希望使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。
* someGetter (state, getters, rootState, rootGetters) {
*         getters.someOtherGetter // -&gt; 'foo/someOtherGetter'
*         rootGetters.someOtherGetter // -&gt; 'someOtherGetter'
*       },
* 
* 若需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给dispatch 或 commit即可
* dispatch('layout/setModuleName', 'organizationModule', { root: true });
* 
* vue如何监听键盘事件中的按键 @keyup.enter
</code></pre>
<h2 id="13vue组件中的data必须是函数">13.vue组件中的data必须是函数</h2>
<p>类比引用数据类型
Object是引用数据类型,如果不用function 返回,每个组件的data 都是内存的同一个地址,一个数据改变了其他也改变了;</p>
<p>javascipt只有函数构成作用域(注意理解作用域,只有函数的{}构成作用域,对象的{}以及 if(){}都不构成作用域)，data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立,不会相互影响</p>
<h2 id="14vue-mixin">14.vue mixin</h2>
<h2 id="15axios">15.axios</h2>
<pre><code>// 添加请求拦截器
axios.interceptors.request.use(function (config) {
    // 在发送请求之前做些什么
    return config;
  }, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
  });
// 添加响应拦截器
axios.interceptors.response.use(function (response) {
    // 对响应数据做点什么
    return response;
  }, function (error) {
    // 对响应错误做点什么
    return Promise.reject(error);
  });
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES 6 基础]]></title>
        <id>https://alexwjj.github.io//post/es-6-ji-chu</id>
        <link href="https://alexwjj.github.io//post/es-6-ji-chu">
        </link>
        <updated>2019-06-05T10:50:32.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>自己对 ES6做的部分总结</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>自己对 ES6做的部分总结</p>
</blockquote>
<!-- more -->
<h2 id="1数组中迭代方法的使用">1.数组中迭代方法的使用</h2>
<pre><code>1、forEach()
var arr = [1,2,3,4];
arr.forEach((item,index,arr) =&gt; {
    console.log(item) //结果为1,2,3,4
})
//forEach遍历数组，无返回值，不改变原数组，仅仅只是遍历、常用于注册组件、指令等等。

2、map()
var arr = [1,2,3,4];
arr.map((item,index,arr) =&gt; {
    return item*10 //新数组为10,20,30,40
})
//map遍历数组，返回一个新数组，不改变原数组的值。

3、filter()
var arr = [1,2,3,4];
arr.filter((item,index,arr) =&gt; {
    return item &gt; 2 //新数组为[3,4]
})
//filter过滤掉数组中不满足条件的值，返回一个新数组，不改变原数组的值。

4、reduce()
var arr = [1,2,3,4];
arr.reduce((result,item,index,arr) =&gt; {
    console.log(result) // 1  3  6  result为上次一计算的结果
    console.log(item)  // 2  3  4
    console.log(index) // 1  2  3
    return result+item //最终结果为10
})
//reduce 让数组的前后两项进行某种计算。然后返回其值，并继续计算。不改变原数组，返回计算的最终结果，从数组的第二项开始遍历。

5、some()
var arr = [1,2,3,4];
arr.some((item,index,arr) =&gt; {
    return item &gt; 3 //结果为true
})
//遍历数组每一项，有一项返回true,则停止遍历，结果返回true。不改变原数组

6、every()
var arr = [1,2,3,4];
arr.every((item,index,arr) =&gt; {
    return item &gt; 1 //结果为false
})
//遍历数组每一项，每一项返回true,则最终结果为true。当任何一项返回false时，停止遍历，返回false。不改变原数组

7.find()
[1, 4, -5, 10].find((n) =&gt; n &lt; 0)  // -5
用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，

直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。

以上均不改变原数组。 
some、every返回true、false。 
map、filter返回一个新数组。 
reduce让数组的前后两项进行某种计算，返回最终操作的结果。 
forEach 无返回值。
</code></pre>
<h2 id="2-set">2. Set</h2>
<pre><code>set 去重 两者完全相等 === 才会被清除掉

Set数据格式Set(3) {1, 2, 3}

Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。

下面先介绍四个操作方法。
add(value)：添加某个值，返回 Set 结构本身。
delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
has(value)：返回一个布尔值，表示该值是否为Set的成员。
clear()：清除所有成员，没有返回值。
Array.from方法可以将 Set 结构转为数组。
</code></pre>
<h2 id="3map">3.Map</h2>
<p>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<pre><code>Map数据格式：  Map(3) {1 =&gt; &quot;one&quot;, 2 =&gt; &quot;two&quot;, 3 =&gt; &quot;three&quot;}
Map转化为数组结构
const map = new Map([
  [1, 'one'],
  [2, 'two'],
  [3, 'three'],
]);

[...map.keys()]
// [1, 2, 3]

[...map.values()]
// ['one', 'two', 'three']

[...map.entries()]
// [[1,'one'], [2, 'two'], [3, 'three']]

[...map]
// [[1,'one'], [2, 'two'], [3, 'three']]
</code></pre>
<h2 id="4for-in-for-of">4.for in &amp; for of</h2>
<p>for in循环设计之初，是给普通以字符串的值为key的对象使用的。而非数组。</p>
<p>for of循环不仅仅支持数组的遍历。同样适用于很多类似数组的对象,字符串得遍历也行</p>
<p>in key   of value 尽量使用of，避免其他问题带来得麻烦</p>
<h2 id="5json">5.JSON</h2>
<pre><code>JSON.stringify( {} , [ ] , &quot;&quot;)  // 转化为json字符串
//参数一 ：要序列化的数据（object）
//参数二 ：控制对象的键值，只想输出指定的属性，传入一个数组
//参数三 ：序列化后，打印输出的格式（一个Tab ，可以更直观查看json）
JSON.parse( json.DATA ) //传入json字符串 转化为json对象
JSON有两种格式 数组和对象    后端一般传过来的都是对象形式
</code></pre>
<h2 id="6解构赋值">6.解构赋值</h2>
<p>只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p>
<p>解构赋值允许指定默认值</p>
<pre><code>let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 
let [x = 1] = [null]; //x=null只有===undefined默认值才有用
</code></pre>
<p>对象和数组解构的区别： 数组按次序来，对象则要变量与属性同名</p>
<p>解构失败 ，变量的值就是undefined</p>
<p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<pre><code>const [a, b, c, d, e] = 'hello';
函数参数解构     [[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ]
ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。
</code></pre>
<h3 id="解构用途">解构用途</h3>
<pre><code>交换变量的值
[x, y] = [y, x];
从函数返回多个值  
function example() {return [1, 2, 3];}    let [a, b, c] = example();
函数参数的定义
function f({x, y, z}) { ... }        f({z: 3, y: 2, x: 1});
提取 JSON 数据                                                                                                                                                       
let jsonData = {
  id: 42,
  status: &quot;OK&quot;,
  data: [867, 5309]
};
let { id, status, data: number } = jsonData;
console.log(id, status, number);
// 42, &quot;OK&quot;, [867, 5309]

遍历 Map 结构      
for (let [key, value] of map) { console.log(key + &quot; is &quot; + value);}  
// 获取value ：for (let [,value] of map) { // ...}
输入模块的指定方法
const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);
</code></pre>
<h2 id="7es6-字符串扩展">7.es6 字符串扩展</h2>
<pre><code>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。

ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。

JavaScript 只有indexOf方法，ES6 includes()是否存在  startsWith() endsWith() 开头和结尾处是否存在

repeat方法返回一个新字符串，表示将原字符串重复n次。    'x'.repeat(3) // &quot;xxx&quot;  

ES2017 (ES8)引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。

padStart()用于头部补全，padEnd()用于尾部补全。 'x'.padStart(5, 'ab') // 'ababx'

模板字符串 `${ xxx }`   `foo ${fn()} bar` 可以调用函数，进行运算，嵌套。反引号中的空格也会被输出

模板编译 &lt;%   javascript %&gt;

</code></pre>
<h2 id="8generator">8.Generator</h2>
<p>调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，返回一个遍历器对象，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。</p>
<p>function* foo(x, y) { ··· }    写法带个 *
每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能</p>
<h2 id="9async">9.async</h2>
<p>async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</p>
<p>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<p>使用方式：</p>
<pre><code>// 函数声明 async function foo() {}
// 函数表达式 const foo = async function () {};
// 对象的方法 let obj = { async foo() {} };obj.foo().then(...)
 // 箭头函数  const foo = async () =&gt; {};
</code></pre>
<p>await命令后面是一个 Promise 对象。如果不是，就返回对应的值  await 123 等同于 123只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行。
await的第一个异步操作失败，Promise变为reject  。如果想不影响后面的操作：1.将第一个await卸载try{ await  }catch（）{} 中  2.await后面的Promise后面接上一个catch方法
同时触发多个await</p>
<pre><code>// 写法一   
let [foo, bar] = await Promise.all([getFoo(), getBar()]);
// 写法二
let fooPromise = getFoo();
let barPromise = getBar();
let foo = await fooPromise;
let bar = await barPromise;
</code></pre>
<p>async原理：将 Generator 函数和自动执行器，包装在一个函数里。</p>
<h2 id="10fetch">10.fetch</h2>
<p>Fetch API 提供了一个获取资源的接口（包括跨域）。XMLHttpRequest的一种替代方案，类似于ajax
fetch() 必须接受一个参数——资源的路径。无论请求成功与否，它都返回一个 promise 对象，resolve 对应请求的 Response。你也可以传一个可选的第二个参数init
新技术，兼容性不行</p>
<h2 id="11shtml-html">11.shtml &amp; html</h2>
<p>shtml 与html的区别 shtml不是html 而是一种服务器API,shtml是服务器动态产生的html</p>
<p>shtml用于SSI技术文件（服务器端包含指令/服务器端嵌入） 包含 SSI 指令的文件要求特殊处理，所以必须为所有 SSI 文件赋予 SSI 文件扩展名。默认扩展名是 .stm、.shtm 和 .shtml</p>
<h2 id="12es6-promise">12.es6 promise</h2>
<p>异步操作，统一API，状态不可改变resolve（已定型）</p>
<p>ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。</p>
<p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p>
<p>promise.resolve()  将现有的对象转换为promise对象 具有then方法,调用resolve或reject并不会终结Promise 的参数函数的执行。一般来说，为了结束直接return resolve（）；then里面返回的是一个新的promise，可以使用链式写法，catch运行时发生错误的回调函数，then里面的错误也会被捕捉到 。</p>
<p>不使用catch的话then报错后，后面的语句依旧会执行 。 Promise 会吃掉错误
catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。promise没有错误就会跳过catch</p>
<p>.finally (es9)不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。 finally方法的回调函数不接受任何参数，其实本质是是then的特例</p>
<p>事件循环 setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log('one')则是立即执行，因此最先输出。</p>
<p>promise 应用 图片加载</p>
<p>同步 立即执行  ；promise中的属于异步，会在本轮事件循环的末尾执行。</p>
<p>promise.resolve().then(f) 会将同步函数转换为异步。 可以结合async来解决这个问题</p>
<p>详情参考文档： http://es6.ruanyifeng.com/?search=**&amp;x=0&amp;y=0#docs/promise</p>
<h2 id="13es6-数值扩展">13.es6 数值扩展</h2>
<pre><code>Math.trunc方法用于去除一个数的小数部分，返回整数部分。 原理ceil和floor结合
Math.sign方法用来判断一个数到底是正数、负数、还是零
Math.cbrt方法用于计算一个数的立方根。x³=a 求x  根号a的3次
Math.hypot方法返回所有参数的平方和的平方根。 
ES2016 新增了一个指数运算符（**） x ^ y = x ** y 特点是右结合 2 ** 3 ** 2 = 2 ^ (3 ^ 2)
**= a **=2 等于 a * a   b **=3 等于 b * b * b
</code></pre>
<h2 id="14es6-函数扩展">14.es6 函数扩展</h2>
<pre><code>* ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。function fn(x = '1') {}
* 函数中使用解构 function fn( { } ) 函数调用的时候 fn( )按顺序传值
* 函数的length属性 在设置默认值之后，后面的包括设置默认值的都不在计算length 
* 作用域  在设置了默认值以后 会形成一个单独的context. 函数初始化结束，消失。先在f（）中寻找，再去全局找
* rest参数 （...变量名） function fn（...values） {}  调用传入任意数量的参数  fn( x, y, z ) 代替了argument，...变量名  搭配数组使用 values可以直接使用数组的方法，argument不行。rest 参数一般放在最后，后面继续跟参数就报错
* es6规定只要函数参数使用了默认值、解构赋值、或扩展运算符，那么函数内部就不能显式设定为严格模式，会报错。
* f.name 会返回当前函数名
* 箭头函数 f =&gt; (x) =&gt; y ；  f函数名 x 参数  y返回值  只有一个参数时可以省略（），只有一个表达式时可以省略{}
* 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。
* 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。在箭头函数中，它是固定的。箭头函数导致this总是指向函数定义生效时所在的对象or作用域
* this指向的固定化，原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。
* 由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。
* 需要动态this的时候，不应使用箭头函数。比如想让this指向按钮中的某一个元素
* 函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。
* 尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数，尾调用不一定出现在函数尾部，只要是最后一步操作即可
* 尾递归
</code></pre>
<h2 id="15objectassign">15.Object.assign()</h2>
<pre><code>* Object.assign是ES6新添加的接口，主要的用途是用来合并多个JavaScript的对象。
* Object.assign()接口可以接收多个参数，第一个参数是目标对象，后面的都是源对象，assign方法将多个原对象的属性和方法都合并到了目标对象上面，如果在这个过程中出现同名的属性（方法），后合并的属性（方法）会覆盖之前的同名属性（方法）。
* 第一个参数target决定了你的对象被拷贝到哪个目标对象上面，如果你不想对原始对象产生影响，就定义一个空对象{}作为target，
* Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。
* Object.assign进行的拷贝是浅拷贝
* 作用：为对象添加属性，为对象添加方法，克隆对象，为属性指定默认值
* https://blog.csdn.net/qs8lk88/article/details/79018481
* 
 枚举
* 事先考虑到某一变量可能取的值，尽量用自然语言中含义清楚的单词来表示它的每一个值，这种方法称为枚举方法，用这种方法定义的类型称枚举类型。enum
* 枚举是指对象中的属性是否可以遍历出来，再简单点说就是属性是否可以以列举出来。
* 16.Object.entries()
* Object.entries()方法返回一个给定对象自身可枚举属性的键值对 数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。
* Object.entries方法对于原型链上继承的非自有属性无能为力。
</code></pre>
<h2 id="17objectkeys">17.Object.keys()</h2>
<p>ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（ enumerable ）属性的键名。</p>
<p>ES7 Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（ enumerable ）属性的键值。</p>
<h2 id="18classextentssuper">18.class，extents，super</h2>
<pre><code>* 为了解决es5中原型，构造函数，继承写法复杂，理解困难的问题
* constructor 构造方法，在一个class中constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实力对象可以共享的。
* Class之间可以通过extends关键字实现继承，继承constructor外的属性及方法
* super关键字，它指代父类的实例（即父类的this对象），子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。
* ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Webpack  入门配置]]></title>
        <id>https://alexwjj.github.io//post/webpack-ru-men-pei-zhi</id>
        <link href="https://alexwjj.github.io//post/webpack-ru-men-pei-zhi">
        </link>
        <updated>2019-06-05T10:24:24.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>简单的介绍下 webpack 基本知识</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>简单的介绍下 webpack 基本知识</p>
</blockquote>
<!-- more -->
<h2 id="入口entry">入口(entry)</h2>
<p>webpack 应该使用哪个模块，来作为构建其内部依赖图的开始</p>
<h2 id="输出output">输出(output)</h2>
<p>告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。</p>
<h2 id="loader">loader</h2>
<p>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）
对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use。告诉webpack碰到test定义的文件时使用use的loader处理一下</p>
<h2 id="plugins">plugins</h2>
<p>插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。想要使用一个插件，你只需要require() 它，然后把它添加到 plugins 数组中</p>
<p>loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。</p>
<p>uglify是用来压缩js代码的</p>
<p>html-webpack-plugin能够创建index.html.open-browser-webpack-plugin 能在webpack加载的时候打开一个浏览器标签页</p>
<p>使用require.ensure 来定义一个拆分点,用来告诉webpack 这个./a.js应该从bundle.js 中拆分，并且生成一个单独的文件</p>
<p>使用externals来暴露全局变量</p>
<p>Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。</p>
<p>Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。</p>
<p>“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。</p>
<p>处理浏览器缓存：webpack可以把一个哈希值添加到打包的文件名中，使用方法如下,添加特殊的字符串混合体（[name], [id] and [hash]）到输出文件名前，添加了hash之后，会导致改变文件内容后重新打包时，文件名不同而内容越来越多，因此这里介绍另外一个很好用的插件clean-webpack-plugin</p>
<h2 id="webpack-dev-server">webpack-dev-server</h2>
<p>webpack-dev-server启动了一个使用express的Http服务器，这个服务器与客户端采用websocket通信协议，当原始文件发生改变，webpack-dev-server会实时编译。</p>
<p>这里注意两点:</p>
<p>1.webpack-dev-server伺服的是资源文件，不会对index.html的修改做出反应</p>
<p>2.webpack-dev-server生成的文件在内存中，因此不会呈现于目录中，生成路径由content-base指定，不会输出到output目录中。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git 常用操作]]></title>
        <id>https://alexwjj.github.io//post/markdown-ce-shi</id>
        <link href="https://alexwjj.github.io//post/markdown-ce-shi">
        </link>
        <updated>2019-06-05T06:28:00.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><strong>实际工作中 Git 的使用方法</strong></p>
<p><strong>持续更新</strong></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><strong>实际工作中 Git 的使用方法</strong></p>
<p><strong>持续更新</strong></p>
</blockquote>
<!-- more -->
<h2 id="1git环境配置">1.git环境配置</h2>
<p>git config --global user.email &quot;798595965@qq.com&quot;</p>
<p>git config --global user.name &quot;wjj&quot;</p>
<p>由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息：
使用以下命令生成SSH Key：
<code>ssh-keygen -t rsa -C &quot;798595965@qq.com&quot;</code></p>
<p>使用默认的一路回车就行。成功的话会在~/下生成.ssh文件夹，进去，打开 id_rsa.pub，复制里面的 key。
在github上的选择 SSH and GPG keys，然后点击 New SSH key 按钮,title 设置标题，可以随便填，粘贴在你电脑上生成的 key</p>
<h2 id="2git流程图">2.git流程图</h2>
<p><img src="https://alexwjj.github.io//post-images/1559721513118.png" alt=""></p>
<h2 id="3git的基本操作">3.Git的基本操作</h2>
<p>1.进入git的安装目录，使用git init newrepo创建新的仓库  cd newrepo开始操作</p>
<p>2.克隆仓库git clone newrepo/(git仓库) newrepo_clone（地址）</p>
<p>3.在仓库目录下，创建文件touch a /touch b  使用git add a将a添加到暂存区中</p>
<p>4.git commit -m &quot;Ininial commit&quot;将文件从暂存区提交到历史记录(&quot;&quot;说明修改的内容)</p>
<p>5.git reset HEAD 命令用于取消已缓存的内容。 git checkout a 将rm删除的a还原</p>
<p>6.git rm a 同时删除工作区和暂存区的文件，git rm --cache a只删除暂存区文件</p>
<p>7.git mv a c (a重命名为c)</p>
<p>8.git add -A将整个工作区添加到暂存区，在工作区目录下创建gitignore文件，通过通配符*[oa],*.pyc来忽略掉这些后缀的文件，通过!test.pyc处理需要的文件</p>
<p>9.git status -s 以精简的方式显示文件状态</p>
<p>A：新文件第一次被添加进版本管理</p>
<p>M:红色为修改过未被添加进暂存区的，绿色为已经添加进暂存区的**</p>
<h2 id="4git-查看提交历史log">4.Git 查看提交历史（log）</h2>
<p>1.git log查看历史提交项目</p>
<p>2.git log --online查看历史纪录的简洁版本</p>
<p>3.git log --online --graph查看历史中什么时候出现了出现了分支合并</p>
<p>4.git log --author=wjj 查看用户wjj提交的部分</p>
<h2 id="5git-标签tag">5.Git 标签（tag）</h2>
<ol>
<li>
<p>git tag -a v1.0 （-a 选项意为&quot;创建一个带注解的标签&quot;）</p>
<p>git tag -a v0.9 85fc7e7（忘了给某个提交打标签，又将它发布了，我们可以给它追加标签）</p>
</li>
</ol>
<p>2.指定标签信息命令：git tag -a <tagname> -m &quot;tag标签&quot;</p>
<p>3.删除标签：git tag -d v1.1</p>
<p>4.查看此版本所修改的内容：git show v1.0</p>
<h2 id="6git命令">6.Git命令</h2>
<p>切换分支：git checkout name</p>
<p>撤销修改：git checkout -- file</p>
<p>删除文件：git rm file</p>
<p>查看状态：git status</p>
<p>添加记录：git add file 或 git add .</p>
<p>添加描述：git commit -m &quot;miao shu nei rong&quot;</p>
<p>同步数据：git pull</p>
<p>提交数据：git push origin name</p>
<h3 id="分支操作">分支操作</h3>
<p>查看分支：git branch</p>
<p>创建分支：git branch name</p>
<p>切换分支：git checkout name</p>
<p>创建+切换分支：git checkout -b name</p>
<p>合并某分支到当前分支：git merge name</p>
<p>删除分支：git branch -d name</p>
<p>删除远程分支：git push origin :name</p>
<h3 id="存储操作">存储操作</h3>
<p>git stash经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是git stash命令</p>
<p>git stash pop 恢复最新进度到工作区。git默认会把工作区和暂存区的改动都恢复到工作区。</p>
<p>git stash apply 除了不删除恢复的进度之外，其余和git stash pop 命令一样。</p>
<p>git stash drop 删除一个存储的进度。如果不指定stash_id，则默认删除最新的存储进度。</p>
<p>git stash clear 删除所有存储的进度。</p>
<p>git 误删文件和恢复指令</p>
<p>git  fsck --lost -found :查看最近移除的文件</p>
<p>git show  '误删编号'：查看删除文件内容</p>
<p>git merge ‘误删编号’： 本地合并误删的文件内容</p>
<h2 id="7git分支重命名">7.git分支重命名</h2>
<p>在git中重命名远程分支，就是先删除远程分支，然后重命名本地分支，再重新提交一个远程分支。</p>
<p>git push --delete origin 老分支</p>
<p>git branch -m 老分支 新分支</p>
<p>git push origin 新分支</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前言   ——俊劫、]]></title>
        <id>https://alexwjj.github.io//post/foreword</id>
        <link href="https://alexwjj.github.io//post/foreword">
        </link>
        <updated>2019-05-31T12:27:28.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><strong>首先</strong> 如果你能看到这个博客，茫茫人海中，都是缘分。</p>
<p><strong>QQ</strong>  798595965  <strong>VX</strong>  18697737169  欢迎骚扰哈。</p>
<p><strong>2019-05-31</strong>  blog-version5.0 上线。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><strong>首先</strong> 如果你能看到这个博客，茫茫人海中，都是缘分。</p>
<p><strong>QQ</strong>  798595965  <strong>VX</strong>  18697737169  欢迎骚扰哈。</p>
<p><strong>2019-05-31</strong>  blog-version5.0 上线。</p>
</blockquote>
<!-- more -->
<h2 id="1说点啥">1.说点啥</h2>
<hr>
<p>作为一个<strong>程序员</strong> ， 文笔可能有点差，但是都没关系。第一篇文章嘛，写写搭建这个博客的背景及未来想做的事情</p>
<h2 id="2关于博客网站">2.关于博客网站</h2>
<hr>
<p>从2018年6月份开始，为了找工作，开始了做博客网站的历程。</p>
<p><strong>第一版</strong>，找的<strong>BootStrap</strong> 的模板，然后进行修改，搞了挺长时间的，写了一个静态页面，放在阿里云学生服务器上。由于不懂性能优化，导致界面加载很卡，也在后续的面试演示中丢了面子，但还是靠着它找到了第一份实习（干了一周）。（刚开始不会用 github，源码就找不到了）</p>
<p><strong>第二版</strong>，自学前端的时用<strong>BootStrap</strong>练手写了一个简洁的响应式界面，把自己学习的时候做的一些小项目都放上去了，靠着它来杭州找到了第二份实习（至今）。GitHub:<a href="https://github.com/alexwjj/Alex">blog-version2.0</a>
<img src="https://alexwjj.github.io//post-images/1559720968955.png" alt=""></p>
<p><strong>第三版</strong>，用的<strong>wordPress</strong>搭建动态博客，写了一些东西，但是感觉不自由，放在阿里云服务器一直也没怎么维护。GitHub:<a href="https://github.com/alexwjj/alex-blog">blog-version3.0</a>
<img src="https://alexwjj.github.io//post-images/1559721023136.png" alt=""></p>
<p><strong>第四版</strong>，之前老师定的毕业论文题目是基于 Java 的 XXX，后来和老师商量了下，说自己不太懂 Java 就换成了基于Node.js 的博客系统。刚好服务器6月份到期，当初的目的也只是练习 Node.js 和应付论文。
GitHub:<a href="https://github.com/alexwjj/dissertation">blog-version4.0</a>
<img src="https://alexwjj.github.io//post-images/1559721086585.png" alt="">
<img src="https://alexwjj.github.io//post-images/1559721070575.png" alt=""></p>
<p><strong>第五版</strong>，有了前面四次的经验，这一次我想到了 Github Pages。静态页面，永久保存，MarkDown，模板简洁。很符合自己的要求。之前fork 别人的仓库，每次编写都需要操作代码，不太喜欢。然后就搁置了很久没动。今天公司举办了儿童节活动，抽完奖(AD 钙奶)，没心思工作，无意间发现了Gridea 这款编辑器。以软件配置的方式帮助搭建 Github Pages，发博文也可以直接写 MarkDown。GitHub:<a href="https://github.com/alexwjj/alexwjj.github.io">blog-version5.0</a>
<img src="https://alexwjj.github.io//post-images/1559721118477.png" alt=""></p>
<p><strong>很完美</strong>，所以以后就要坚持写下去了，毕竟嘛，做技术的，谁没个让人家羡慕的博客。</p>
<h2 id="3规划">3.规划</h2>
<p>也没想太多，简单的规划下，至少保证每周更新两篇吧，技术学习与生活分享。</p>
<table>
<thead>
<tr>
<th>前端</th>
<th>技术学习、技术分享</th>
</tr>
</thead>
<tbody>
<tr>
<td>生活</td>
<td>心态变化、趣事分享、人生哲理(吹牛皮)</td>
</tr>
<tr>
<td>规划</td>
<td>周规划、月规划、季规划</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端面试基础知识点  20190329]]></title>
        <id>https://alexwjj.github.io//post/qian-duan-mian-shi-ji-chu-zhi-shi-dian-20190329</id>
        <link href="https://alexwjj.github.io//post/qian-duan-mian-shi-ji-chu-zhi-shi-dian-20190329">
        </link>
        <updated>2019-03-29T08:42:00.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>个人总结的面试技巧</p>
<p>针对个人基础知识点来梳理的</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>个人总结的面试技巧</p>
<p>针对个人基础知识点来梳理的</p>
</blockquote>
<!-- more -->
<h2 id="1注意点">1.注意点</h2>
<p>在js逻辑运算中，0、NaN、&quot;&quot;、null、false、undefined都会判为false，其他都为true</p>
<p>IOS 无法识别yy-mm-dd这种带 - 的时间格式</p>
<h2 id="2foreach-map">2.forEach  Map</h2>
<p>forEach()方法不会返回执行结果，而是undefined。也就是说，forEach()会修改原来的数组。而map()方法会得到一个新的数组并返回。</p>
<h2 id="3数据类型">3.数据类型</h2>
<p>六种基本类型：string, number, boolean, undefined, null，symbol 三种引用类型: function, array, object<br>
在js中， number没有整型，导致NaN 也属于 number 类型， NaN 不等于自身。</p>
<h2 id="4判断一个数组的类型">4.判断一个数组的类型</h2>
<p>1.判断是否具有数组某些方法：if(arr.sort()){}</p>
<p>2.instanceof(某些IE版本不正确)：arr instanceof Array</p>
<p>3.Array.isArray()</p>
<p>4.Object.prototype.toString.call(arr); // '[object Array]'</p>
<p>5.constructor方法</p>
<pre><code>arr.constructor === Array
var arr = []  arr instanceOf Array //true typeof arr //object 
instanceof 原型链上所有特殊对象的__proto__最终都会指向Object.prototype，
所以instanceof判断类型也不完全准确

Array.isArray 是 es5 的方法，并不兼容所有浏览器，ie9 以下浏览器都不支持

通用办法
var isArray = Array.isArray || function(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
};
</code></pre>
<h2 id="5变量提升-函数提升">5.变量提升 &amp;&amp; 函数提升</h2>
<p>js查找变量 先在当前作用域中查找 存在则返回，不存在则向上查找</p>
<p>函数的优先权是最高的，它永远被提升至作用域最顶部，然后才是函数表达式和变量按顺序执行</p>
<p>变量提升是人为实现的问题，而函数提升在当初设计时是有目的的。</p>
<p><strong>规范代码，提高可读性，先声明，后使用。</strong></p>
<h2 id="6事件">6.事件</h2>
<p>事件委托：让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！</p>
<p>事件捕获阶段(与冒泡相反)）=&gt;目标元素阶段=&gt;事件冒泡阶段</p>
<h3 id="addeventlistener">addEventListener</h3>
<p>该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false 。useCapture 决定了注册的事件是捕获事件(false)还是冒泡事件(true)。如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上。阻止事件冒泡event.stopPropagation()。阻止默认事件：event.preventDefault()</p>
<h3 id="event-loop">Event loop</h3>
<p>JS 是门非阻塞单线程语言,如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点），当然可以引入读写锁解决这个问题。</p>
<h3 id="执行环境">执行环境</h3>
<p>JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 任务（有多种任务） 队列中。一旦执行栈为空，Event Loop 就会从 任务 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。</p>
<h3 id="任务队列">任务队列</h3>
<p>不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）
微任务包括 process.nextTick ，promise ，Object.observe ，MutationObserver
宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering</p>
<p><strong>Event loop</strong> 顺序是这样的</p>
<pre><code>* 执行同步代码，这属于宏任务
* 执行栈为空，查询是否有微任务需要执行
* 执行所有微任务
* 必要的话渲染 UI
* 然后开始下一轮 Event loop，执行宏任务中的异步代码
* Node 的 Event loop 分为 6 个阶段，它们会按照顺序反复运行
</code></pre>
<h2 id="7http">7.HTTP</h2>
<h3 id="特点">特点</h3>
<p>简单快速：客户向服务器请求服务时，只需传送请求方法和路径</p>
<p>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记</p>
<p>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接 (深入-持久连接、管线化)</p>
<p>无状态：HTTP协议是无状态协议( Cookie 的出现)</p>
<p>https 即在HTTP下加入SSL层</p>
<h3 id="http-请求方法">http 请求方法</h3>
<p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</p>
<p>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>
<h3 id="一般的http连接都是">一般的http连接都是：</h3>
<pre><code>* 三次握手建立连接，
* 发送http请求报文，获取响应报文，
* 通过四次握手，中断连接
* HTTP1.1中connection默认开启keep-alive，就不需要连续的建立然后中断
</code></pre>
<h3 id="http-状态码">http 状态码</h3>
<pre><code>1xx指示信息，请求已接收，继续处理
2xx成功，请求已成功
3xx重定向，要完成请求必须要进行下一步操作
4xx客户端错误，请求有语法错误或无法实现
5xx服务端错误，服务器未能实现合法的请求
 
200：请求已成功，请求所希望的响应头或数据体将随此响应返回。
302：请求的资源临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或Expires 中进行了指定的情况下， 这个响应才是可缓存的
304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。
403：服务器已经理解请求，但是拒绝执行它。
404：请求失败，请求所希望得到的资源未被在服务器上发现。
502 Bad Gateway是指错误网关，无效网关
</code></pre>
<h2 id="8typeof-null">8.typeOf null</h2>
<p>在 JS 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。</p>
<h2 id="9浏览器渲染页面的过程">9.浏览器渲染页面的过程</h2>
<p>从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面五件事情上：</p>
<pre><code>1. DNS 查询
2. TCP 连接
3. HTTP 请求即响应
4. 服务器响应
5. 客户端渲染
</code></pre>
<p>第五个部分，即浏览器对内容的渲染，这一部分（渲染树构建、布局及绘制），又可以分为下面五个步骤：</p>
<pre><code>1. * 处理 HTML 标记并构建 DOM 树。
2. * 处理 CSS 标记并构建 CSSOM 树。
3. * 将 DOM 与 CSSOM 合并成一个渲染树。
4. * 根据渲染树来布局，以计算每个节点的几何信息。
5. * 将各个节点绘制到屏幕上。
</code></pre>
<h2 id="10objectis-objectisfoo-foo-true">10.object.is() Object.is('foo', 'foo') true</h2>
<h2 id="11原生sort使用的是哪些排序算法">11.原生sort使用的是哪些排序算法？</h2>
<p>插入排序和快速排序结合的排序算法
sort 的排序规则：</p>
<pre><code>    var values = [0, 1, 5, 10, 15];
    values.sort();
    alert(values);     //0,1,10,15,5
</code></pre>
<h2 id="12原型">12.原型</h2>
<p>所有引用类型（数组、对象、函数）都有一个__proto__隐式原型属性，属性值是一个普通对象。 此外，Object.prototype.__proto__指向null</p>
<p>所有函数都有一个prototype显式原型属性，属性值是一个普通对象。 Function.prototype.bind()没有prototype属性</p>
<p>所有引用类型（数组、对象、函数）的__proto__执行它的构造函数的prototype属性</p>
<h2 id="13-迭代方法">13. 迭代方法</h2>
<pre><code>// every()查询数组是否每一项都满足条件
// some()查询数组中是否有满足条件的项
// filter()过滤，返回true的项组成的数组
// map()对每一项运行给定函数，返回每次函数调用结果组成的数组
// forEach()对每一项运行给定函数，无返回值  
// reduce 让数组的前一项和后一项做某种计算，累计最终值
var numbers = [1,2,3,4,5,4,3,2,1];
numbers.every(function(item,index,array){
    return item&gt;2;
})  // false
numbers.some(function(item,index,array){
    return item&gt;2;
})  // true
numbers.filter(function(item,index,array){
    return item&gt;2;
})  // [3,4,5,4,3]
numbers.map(function(item,index,array){
    return item*2;
})  // [2,4,6,8,10,8,6,4,2]
numbers.forEach(function(item,index,array){
    // 执行某些操作
})  // 无返回值
</code></pre>
<h2 id="14new操作符具体干了什么">14.new操作符具体干了什么？</h2>
<pre><code>构造函数相当于一个模板
* 创建一个空对象
* 将对象的__proto指向构造函数的原型prototype
* 执行构造函数中的代码，传递参数，并将this指向这个对象
* 返回对象
</code></pre>
<h2 id="15通过new的方式创建对象和通过字面量创建的区别">15.通过new的方式创建对象和通过字面量创建的区别</h2>
<p>更推荐字面量的方式创建对象，性能和可读性都更好。使用var o=new Object()和var o={}的区别是前者会调用构造函数</p>
<h2 id="16继承">16.继承</h2>
<p>ES 5实现思路就是将子类的原型设置为父类的原型。在 ES6 中，我们可以通过 class 语法</p>
<h2 id="17闭包">17.闭包</h2>
<p>闭包指有权访问另一个函数内部变量的函数，当在函数内部定义了其他函数，也就创建了闭包</p>
<p>想要访问一个f1内的变量，在f1内在创建一个函数f2，将f2的值作为返回值，在调用f1时就能访问到f1里面的局部变量</p>
<p><strong>场景1：使用函数内部变量</strong></p>
<p><img src="https://alexwjj.github.io//post-images/1559726116412.png" alt=""></p>
<p><strong>场景2：保存变量在内存中</strong></p>
<p><img src="https://alexwjj.github.io//post-images/1559726149136.png" alt=""></p>
<p>在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。销毁闭包：res = null。闭包的this默认指向window</p>
<h3 id="内存泄露">内存泄露</h3>
<p>闭包会引用包含函数的整个变量对象，如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素无法被销毁。所以我们有必要在对这个元素操作完之后主动销毁。 = null</p>
<p>函数内部定时器
当函数内部的定时器引用了外部函数的变量对象时，该变量对象不会被销毁。</p>
<h3 id="应用场景">应用场景</h3>
<pre><code>设计私有的变量和方法
模块模式：为单例创建私有的变量和方法
单例：指的是只有一个实例的对象。一般以对象字面量的方式来创建一个单例对象。
匿名函数最大的用途是创建闭包，并且还可以构建命名空间，以减少全局变量的使用。
从而使用闭包模块化代码，减少全局变量的污染。
</code></pre>
<p><img src="https://alexwjj.github.io//post-images/1559726283838.png" alt="">
在这段代码中函数 addEvent 和 removeEvent 都是局部变量，但我们可以通过全局变量 objEvent 使用它，这就大大减少了全局变量的使用，增强了网页的安全性。</p>
<p><strong>经典面试题</strong>，循环中使用闭包解决 var 定义函数的问题</p>
<pre><code>for ( var i=1; i&lt;=5; i++) {
	setTimeout( function timer() {
		console.log( i );
	}, i*1000 );
}
</code></pre>
<p>首先因为 setTimeout 是个异步函数，所有会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出5个6。解决办法两种，第一种使用闭包</p>
<pre><code>for (var i = 1; i &lt;= 5; i++) {
  (function(j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
</code></pre>
<p>第二种就是使用 setTimeout 的第三个参数</p>
<pre><code>for ( var i=1; i&lt;=5; i++) {
	setTimeout( function timer(j) {
		console.log( j );
	}, i*1000, i);
}
</code></pre>
<p>第三种就是使用 let 定义 i 了</p>
<pre><code>for ( let i=1; i&lt;=5; i++) {
	setTimeout( function timer() {
		console.log( i );
	}, i*1000 );
}
</code></pre>
<h2 id="18bom对象">18.BOM对象</h2>
<pre><code>window JS最顶层对象
location 浏览器当前URL信息
navigator 浏览器本身信息
screen 客户端屏幕信息
history 浏览器访问历史信息
window对象的方法：
alert(),prompt(),confirm(),open(),close(),print(),focus(),blur(),
moveBy(),moveTo(),resizeBy(),resizeTo(),scrollBy(),scrollTo(),
setInterval(),setTimeout(),clearInterval(),clearTimeout()
</code></pre>
<h2 id="19拆解url的各部分">19.拆解url的各部分</h2>
<pre><code>* 使用location的属性
* href 完整url地址
* protocol 协议
* host 主机名+端口号
* hostname 主机名
* port 端口号
* pathname 相对路径
* hash #锚点
* search ?查询字符串
</code></pre>
<h2 id="20为什么操作dom慢">20.为什么操作DOM慢？</h2>
<p>因为DOM属于渲染引擎的东西，JS又是JS引擎的东西，当我们通过JS操作DOM的时候，涉及到两个线程间的通信，而且操作DOM可能会带来重绘回流的情况，所以就导致了性能问题。DOM对象本身也是一个js对象，操作了这个对象后，会触发一些浏览器行为，比如布局（layout）和绘制（paint）。重绘是当节点改变样式而不影响布局，回流是当布局或几何属性需要改变。回流必定会发生重绘，回流的成本比重绘高</p>
<h2 id="21什么情况阻塞渲染">21.什么情况阻塞渲染</h2>
<p>1.HTML和CSS都会阻塞渲染，如果想渲染快就应该降低一开始渲染的文件大小，扁平层级，优化选择器</p>
<p>2.浏览器解析到script标签时会暂停构建DOM，</p>
<h2 id="22dom">22.Dom</h2>
<pre><code>document.querySelector // 返回第一个匹配的元素
document.querySelectorAll  // 返回匹配的所有元素
// 获取文档中所有 class=&quot;example&quot; 的 &lt;p&gt; 元素
var x = document.querySelectorAll(&quot;p.example&quot;); 

DOM事件

DOM事件的级别
DOM0 element.onclick=function(){}
DOM2 element.addEventListener('click',function(){},false)
DOM3 element.addEventListener('keyup',function(){},false)
DOM0级事件就是将一个函数赋值给一个事件处理属性，缺点在于一个处理程序无法同时绑定多个处理函数。
DOM2级事件运行给一个程序添加多个处理函数，定义了addEventListener和removeEventListener两个方

法，分别用于绑定和解绑事件，方法包含三个参数分别是绑定的事件处理的属性名称，处理函数，是否在

捕获时执行事件

IE8以下使用attachEvent和detachEvent实现，不需要传入第三个参数，因为IE8以下只支持冒泡型事件
btn.attachEvent('onclick', showFn);
btn.detachEvent('onclick', showFn);
复制代码

DOM3级事件是在DOM2级事件的基础上添加很多事件类型如

load,scroll,blur,focus,dbclick,mouseup,mousewheel,textInput,keydown,keypress，
同时也允许使用者自定义一些事件
</code></pre>
<h2 id="23js获取盒模型宽高">23.js获取盒模型宽高</h2>
<pre><code>最常用，兼容性最好 dom.offsetWidth/offsetHeight
offsetWidth/offsetHeight,clientWidth/clientHeight与srcollWidth/scrollHeight的区别

* offsetWidth/offsetHeight返回包含content+padding+**border** **全部宽高**
* clientWidth/clientHeight返回包含content+padding，如果有滚动条，也不包含滚动条
* scrollWidth/scrollHeight返回包含content+paddin+溢出内容的尺寸
</code></pre>
<h2 id="24ajax">24.Ajax</h2>
<pre><code>// 创建XMLHTTPRequest对象
var xhr = new XMLHttpRequest();
// 创建一个新的http请求
xhr.open(&quot;get&quot;, url, true)
// 设置响应HTTP请求状态变化的函数
xhr.onreadystatechange = function(){
    if(xhr.readyState == 4){
        if(xhr.status == 200){
            // 获取异步调用返回的数据
            alert(xhr.responseText)
        }
    }
}
// 发送HTTP请求
xhr.send(null);
</code></pre>
<p>状态码readyState说明：0：未初始化，未调用send()；1：已调用send()，正在发生请求；2:send()方法执行完毕，已经接收到全部响应内容；3：正在解析响应内容；4：解析完成，可以在客户端调用了</p>
<h2 id="25跨域">25.跨域</h2>
<p>跨域指通过JS在不同的域之间进行数据传入或通信。 协议，域名，端口有一个不同就是跨域。同源策略是为了防止CSRF攻击，它是利用用户的登录态发起恶意请求。</p>
<h3 id="解决跨域方式">解决跨域方式</h3>
<p>1.JSONP使用简单，兼容性不错但仅限GET请求</p>
<p>2.CORS需要前后端同时支持，服务器端设置Access-Control-Origin开启CORS，该属性表明哪些域名可以访问资源。</p>
<p>3.document.domain 只适用于二级域名相同，a.test.com。在页面添加docuemtn.domain = 'test.com'表示二级域名相同即可跨域</p>
<p>4.postMessage 通常用于获取嵌入页面(iframe)的第三方页面数据，一个页面发送消息，另一个页面判断来源并接收消息.</p>
<pre><code>// 发送消息
window.parent.postMessage('message', 'http://www.test.com')
// 接收消息
let mc=new MessageChannel()
mc.addEventListener('message', event =&gt; {
    let origin = event.origin || event.originalEvent.origin;
    if(origin === 'http://www.test.com'){
        console.log('验证通过')
    }
}
</code></pre>
<h2 id="26server-worker的工作">26.Server Worker的工作？</h2>
<h3 id="缓存文件">缓存文件</h3>
<p>与缓存进行交互，当用户请求缓存中的东西时，Service Worker能立刻从缓存中获取数据不通过外部https调用,传输协议必须为https，目前该技术通常用来做缓存文件，提高首屏速度</p>
<h3 id="发送推送通知">发送推送通知</h3>
<p>运行背景同步：在离线的情况下用浏览器发送一个文件，Service Worker可以保存此任务，等网络连接恢复后将文件上传至外部服务器</p>
<h2 id="27indexdb">27.indexDB</h2>
<p>Cookie 的大小不超过4KB，且每次请求都会发送回服务器；LocalStorage 在 2.5MB 到 10MB 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。indexDB都可以做到，存储无上限</p>
<h2 id="28浅拷贝-深拷贝">28.浅拷贝 &amp;&amp; 深拷贝</h2>
<p>1.栈（stack）为自动分配的内存空间，它由系统自动释放，存放基本类型（不可改变）；而堆（heap）则是动态分配的内存，大小不定也不会自动释放，存放引用类型。</p>
<p>2.基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的；引用类型的比较是引用的比较，比较是否指向同一块堆内存</p>
<p>3.基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中。引用类型的赋值是传址。只是改变指针的指向</p>
<p>4.深拷贝：将 B 对象拷贝到 A 对象中，包括 B 里面的子对象；浅拷贝：将 B 对象拷贝到 A 对象中，但不包括 B 里面的子对象</p>
<pre><code>深拷贝： JSON.parse(JSON.stringify(Obj))对象中存在循环对象无法处理
Object.create()
Object.assign() 对象只有一层
obj2 = _.cloneDeep(obj1) 复杂情况的深拷贝使用lodash实现
浅拷贝： 
= 赋值
...  es6展开符
object.assign()  对象有多层
</code></pre>
<h2 id="29flex-rem-vw-wh">29.flex + rem + vw wh</h2>
<p>flexible+vue    使用lib-flexible和px2rem</p>
<h3 id="flex">flex</h3>
<p>flex 是 flex-grow（放大），flex-shrink （缩放）和 flex-based （基本）的缩写  默认flex:0 1 auto;</p>
<p>flex-grow 控制的是 flex 项的拉伸比例，而不是占据 flex 容器的空间比例。当设置为 0 时，该 flex 项将不会被拉伸去填补剩余空间；两个项的比例是 1:2，意思是在被拉伸时，第一个 flex 项将占用 1/3，而第二个 flex 项将占据余下的空间。flex-shrink相反；flex-based 自定义元素宽度，200px ,10%都行</p>
<p>以下6个属性设置在容器上。</p>
<pre><code>* 		flex-direction
* 		flex-wrap
* 		flex-flow
* 		justify-content
* 		align-items
* 		align-content
</code></pre>
<p>以下6个属性设置在项目上。</p>
<pre><code>* 		order
* 		flex-grow
* 		flex-shrink
* 		flex-basis
* 		flex
* 		align-self
</code></pre>
<h3 id="rem">rem</h3>
<p>计算方式： 设计稿px  /  根节点px  =  真实rem；flexible实际上就是能过JS来动态改写meta标签，动态改写<meta>标签，给<html>元素添加data-dpr属性，并且动态改写data-dpr的值，给<html>元素添加font-size属性，并且动态改写font-size的值</p>
<h3 id="vh-vw">vh vw</h3>
<p>vh vw是相对视口（viewport）的宽度而定的，长度等于视口宽度的1/100，当前屏幕可见高度的1%。 假如浏览器的宽度为200px，那么1vw就等于2px（200px/100）。 vh是相对视口（viewport）的高度而定的，长度等于视口高度的1/100。 假如浏览器的高度为500px，那么1vh就等于5px（500px/100
calc(100vh - 10px)  表示整个浏览器窗口高度减去10px的大小</p>
<h2 id="30js-结果舍入运算">30.js 结果舍入运算</h2>
<pre><code>* x.toFixed( num)  将x保留num位小数  
* Math.round(x)   四舍五入 round() 方法可把一个数字舍入为最接近的整数
* parseInt() 丢弃小数部分,保留整数部分
* Math.ceil() 向上取整,有小数就整数部分加1 
* Math.floor()  向下取整
</code></pre>
<h2 id="31类型转换">31.类型转换</h2>
<p>只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。1 + '1' = '11'  2 * '2' = 4</p>
<h2 id="32防抖-节流">32.防抖 &amp;&amp; 节流</h2>
<p>防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数wait）调用函数。</p>
<p><strong>防抖</strong>：通过定时器延迟执行某个函数，点击时，只有过了自定义的time，才能再次点击</p>
<p><strong>节流</strong>：防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。</p>
<h2 id="33-this">33. this</h2>
<h3 id="this指向">this指向</h3>
<p>定义：this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象。总结：</p>
<pre><code>1.在普通函数内部，this的指向是window
2.在方法内部，this的指向是方法的拥有者。
3.在箭头函数内部，this指向是创建箭头函数时所在的环境中的this指向的值。
4.在对象中，this指向当前对象，这里的this指向会发生改变     
5.计时器中的this
6.回调函数中的this
7.事件处理函数中的this指向事件的绑定者
</code></pre>
<h2 id="34安全">34.安全</h2>
<h3 id="xss">XSS</h3>
<p>XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站。
最普遍的做法是转义（replace）输入输出的内容，对于引号，尖括号，斜杠进行转义。显示富文本的采用白名单过滤的方式
CSP CSP 本质上也是建立白名单，通常可以通过 HTTP Header 中的 Content-Security-Policy 来开启 CSP</p>
<h3 id="csrf">CSRF</h3>
<p>CSRF 就是利用用户的登录态发起恶意请求。
防御：</p>
<pre><code>1.请求时附带验证信息，比如验证码或者 token
2.验证 Referer:对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。
3.Token:服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效
4.信息加密
</code></pre>
<h3 id="sql注入">SQL注入</h3>
<p>就是攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。 攻击者通过在应用程序预先定义好的SQL语句结尾加上额外的SQL语句元素，欺骗数据库服务器执行非授权的查询,篡改命令。</p>
<p><strong>参数化查询</strong>已被视为最有效的可防御SQL注入攻击的防御方式。目前主流的ORM 框架都内置支持并且推荐使用这种方式进行持久层封装。<strong>参数化查询</strong>是指在设计与数据库链接并访问数据时，在需要填入数值或数据的地方，使用参数来给值。</p>
<h2 id="35为什么不推荐使用setinterval">35.为什么不推荐使用setInterval</h2>
<p>js 的执行原理：js引擎是单线程的，主要分为主线程和事件队列，同步操作是在主线程上执行，而异步操作的函数会先放在事件队列当中，等到js主线程空闲了，才会去事件队列取出放到主线程执行。定时器是属于异步事件，参数里面设置的时间，并不是延迟多少秒去执行回调函数，这个时间代表的是延迟多少秒，把回调函数放到异步队列，等待主线程空闲再被执行。</p>
<p>如果当事件队列当中，已经存在了定时器的回调函数，即使已经到了规定的间隔时间，也不会再把这个时间点的定时器回调函数放到事件队列当中，定时器依旧运行。当下一个约定时间又到了，如果事件队列当中依然存在定时器的回调函数，这个时间点的定时器回调函数也不会放进事件队列…</p>
<h2 id="36中文版chrome浏览器不支持12px以下字体的解决方案">36.中文版Chrome浏览器不支持12px以下字体的解决方案</h2>
<p>一般解决方案是禁止webkit浏览器配置调整网页的字体大小。如下CSS定义方式：
.classstyle{ -webkit-text-size-adjust:none; font-size:9px; }</p>
<h2 id="37const定义的对象属性是否可以改变">37.const定义的对象属性是否可以改变</h2>
<p>const仅保证指针不发生改变，修改对象的属性不会改变对象的指针，所以是被允许的。也就是说const定义的引用类型只要指针不发生改变，其他的不论如何改变都是允许的</p>
<h2 id="38函数柯里化curry">38.函数柯里化（curry）</h2>
<p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。curry 的这种用途可以理解为：参数复用。本质上是降低通用性，提高适用性。
对于需要传入多个参数的函数，可以写一个公共的函数，其他地方需要时传入对应值</p>
<pre><code>var prop = curry(function (key, obj) {
    return obj[key]
});
var name = person.map(prop('name'))
</code></pre>
<h2 id="39getelementby-和-queryselector-区别">39.getElementBy*  和 querySelector 区别</h2>
<p>getElementById / querySelector 这两个获取到的都是dom节点，结果没有区别。</p>
<p>getElement* 的实时性体现在返回集合的时候，我们知道getElementsBy*和querySelectorAll返回的都是一个节点集合，类似于数组，两种方法的区别就在于这个集合会不会自动更新。
getEle会，queryS不会</p>
<h2 id="39性能">39.性能</h2>
<h3 id="1缓存强缓存-协商缓存">1.缓存（强缓存 &amp; 协商缓存）</h3>
<p><strong>强缓存</strong>：实现强缓存可以通过两种响应头实现：Expires （1.0）和 Cache-Control （1.1）。强缓存表示在缓存期间不需要请求，state code 为 200；设置资源的到期时间</p>
<p><strong>协商缓存</strong>：缓存过期，使用协商缓存需要发送请求，如果缓存有效这返回304。两种实现方式1.Last-Modified 和 If-Modified-Since 2.ETag 和 If-None-Match</p>
<h3 id="2使用http-20">2.使用HTTP / 2.0</h3>
<p>在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小。</p>
<h3 id="3懒加载">3.懒加载</h3>
<p>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。</p>
<h3 id="4图片优化">4.图片优化</h3>
<pre><code>1.计算图片大小,减少像素点，减少每个像素点能够显示的颜色
2.使用css代替部分图片
3.移动端使用cdn根据屏幕大小加载已经剪切好的图片
4.雪碧图
5.可以的话使用webP格式图片
</code></pre>
<p>题型：如何渲染几万条数据并不卡住界面</p>
<p>可以通过 requestAnimationFrame 来每 16 ms 刷新一次。</p>
<h1 id="2019-3-29">2019-3-29</h1>
<p><strong>为了春招准备的，由于菜， 零offer。。。</strong></p>
]]></content>
    </entry>
</feed>